package commands

import (
	"context"
	"fmt"

	"github.com/kb-project/pkg/model"
	"github.com/kb-project/pkg/search"
	"github.com/kb-project/pkg/store"
)

// MockRAGClient is a mock implementation of a RAG client
type MockRAGClient struct {
	searcher *search.Searcher
}

// RAGAnswer represents an answer from the RAG system
type RAGAnswer struct {
	Text      string
	Citations []model.Chunk
}

// NewMockRAGClient creates a new mock RAG client
func NewMockRAGClient(searcher *search.Searcher, embedder interface{}) *MockRAGClient {
	return &MockRAGClient{
		searcher: searcher,
	}
}

// Ask asks a question and returns an answer
func (c *MockRAGClient) Ask(ctx context.Context, question string) (*RAGAnswer, error) {
	// In a real implementation, this would:
	// 1. Search for relevant chunks
	// 2. Format them into a prompt
	// 3. Send the prompt to an LLM
	// 4. Parse the response
	// 5. Return the answer with citations

	// For our mock, we'll just return a canned response
	chunks, err := c.searcher.SearchText(ctx, question, 3)
	if err != nil {
		return nil, fmt.Errorf("failed to search for chunks: %w", err)
	}

	// Create a mock answer
	answer := &RAGAnswer{
		Text: fmt.Sprintf("This is a mock answer to your question: \"%s\"\n\n"+
			"In a real implementation, this would be generated by an LLM based on the retrieved chunks.\n"+
			"For now, I can tell you that I found %d relevant code chunks that might help answer your question.",
			question, len(chunks)),
		Citations: chunks,
	}

	return answer, nil
}

// MockShower is a mock implementation of a shower
type MockShower struct {
	store *store.Store
}

// NewMockShower creates a new mock shower
func NewMockShower(store *store.Store) *MockShower {
	return &MockShower{
		store: store,
	}
}

// ShowByID shows a chunk by ID
func (s *MockShower) ShowByID(ctx context.Context, id string) (string, error) {
	// In a real implementation, this would retrieve the chunk and format it nicely
	chunk, err := s.store.Get(ctx, id)
	if err != nil {
		return "", fmt.Errorf("failed to get chunk: %w", err)
	}

	return formatChunk(chunk), nil
}

// ShowByFileLine shows a chunk by file and line
func (s *MockShower) ShowByFileLine(ctx context.Context, file string, line int) (string, error) {
	// In a real implementation, this would search for chunks that contain the specified line
	// For our mock, we'll just search for chunks with the file path
	chunks, err := s.store.SearchText(ctx, file, 10)
	if err != nil {
		return "", fmt.Errorf("failed to search for chunks: %w", err)
	}

	if len(chunks) == 0 {
		return "", fmt.Errorf("no chunks found for file %s", file)
	}

	// Find the chunk that contains the specified line
	var targetChunk model.Chunk
	found := false
	for _, chunk := range chunks {
		if chunk.FilePath == file && chunk.StartLine <= line && chunk.EndLine >= line {
			targetChunk = chunk
			found = true
			break
		}
	}

	if !found {
		return "", fmt.Errorf("no chunk found for file %s at line %d", file, line)
	}

	return formatChunk(&targetChunk), nil
}

// formatChunk formats a chunk for display
func formatChunk(chunk *model.Chunk) string {
	return fmt.Sprintf("ID: %s\nFile: %s\nLanguage: %s\nType: %s\nName: %s\nLines: %d-%d\n\n%s\n\n%s",
		chunk.ID, chunk.FilePath, chunk.Language, chunk.SymbolType, chunk.SymbolName,
		chunk.StartLine, chunk.EndLine, chunk.Doc, chunk.Code)
}
