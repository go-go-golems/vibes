{
  "url": "https://www.xach.com/naggum/articles/3159560088216201@naggum.no.html",
  "id": "3159560088216201@naggum.no",
  "title": "Re: Help with easy checksum",
  "content": "\nSubject: Re: Help with easy checksum\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/14\nNewsgroups: comp.lang.lisp,comp.text.interleaf\nMessage-ID: <3159560088216201@naggum.no>\n\n* Scott Sheffield <scott.y.sheffield@lmco.com>\n| I have created a binary file using Interleaf LISP and I need to put a\n| checksum at the end of the file so that it can be loaded into the\n| hardware.  The problem is though I have a good idea what a checksum is\n| and does I have no idea how to do this in LISP.  Here is what I am told I\n| need to do:\n\n  when you are told what to do in language-specific terms, there's a\n  serious flaw in the thinking of the person telling you what to do.  I'll\n  try to correct that serious flaw by simplifying your requirement to this\n  simple rule:\n\n    when the contents of the file is regarded as a sequence of 32-bit\n    integers, the value of the last 32-bit integer of the file is such that\n    the sum of the 32-bit integers throughout the file is 0 modulo 2^32.\n\n  this is fairly easy to hack together, but it depends on how you write to\n  your stream.  if you write 32-bit integers to the stream (which means it\n  should be opened with :ELEMENT-TYPE '(SIGNED-BYTE 32) or UNSIGNED-BYTE\n  ditto), just sum them up while you write each integer, then write\n  (LDB (BYTE 32 0) (- <SUM>)) to the same stream just before closing it.\n\n  if you don't write 32-bit integers to the file, you're probably better\n  off writing it in one pass and reading it as 32-bit integers in another\n  pass, only to tack on the same 32-bit integer as describe above at the\n  end.\n\n| 2) Write 32 bit chunks to the file, also accumulate the 32 bit chunks\n| into this 32 bit integer object. The accumulation is a add, ignoring\n| overflows (which is standard), then the final step is to take the\n| negative (2's complement) all the accumulations have been done.\n\n  no, ignoring overflows is _not_ standard, it's a a hardware-oriented\n  design decision local to particular languages.  the standard addition\n  function does not overflow to begin with.  please don't confuse the\n  internal hardware representation of a value with the value.\n\n  however, whether you ignore overflow or extract a bit field from an\n  integer is only a conceptual difference.  C-based life forms think in\n  terms of ignoring overflow because they don't know what it means not to.\n  Common Lisp programmers don't ignore overflows, but talk about values\n  _modulo_ some other value, instead.\n\n#:Erik\n\n",
  "date": "2000-02-14",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}