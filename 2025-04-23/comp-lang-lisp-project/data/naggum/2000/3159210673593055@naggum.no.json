{
  "url": "https://www.xach.com/naggum/articles/3159210673593055@naggum.no.html",
  "id": "3159210673593055@naggum.no",
  "title": "Re: beginner question on input from large files",
  "content": "\nSubject: Re: beginner question on input from large files\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/10\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159210673593055@naggum.no>\n\n* Joseph Dale <jdale@uclink4.berkeley.edu>\n| I'm trying to write a function that takes the name of a dictionary file\n| containing one word per line and returns the contents of that file as a\n| list of strings.\n\n  first off, it's a reasonable thing to do.\n\n| The latest of several versions is this one (I know it's not very elegant):\n\n  au contraire, it's _too_ elegant.\n\n| (defun get-words (filename)\n|   (let ((*words* '()))\n|     (defun read-loop (stream)\n|       (setf *words* (cons (read-line stream nil 0) *words*))\n|       (if (numberp (first *words*))\n| \t  (rest *words*)\n| \t(read-loop stream)))\n|     (with-open-file (stream filename :direction :input)\n| \t\t    (read-loop stream))))\n\n  whether this is compiled or not, this is needlessly complex and \"elegant\"\n  only in the Scheme sense, which is not elegant at all in Common Lisp.\n\n(defun stream-lines (input-stream)\n  (do ((lines nil)\n       (line #1=(read-line input-stream nil :eof) #1#))\n      ((eq line :eof) (nreverse lines))\n    (push line lines)))\n\n  if you're not as silly as to have an allergic reaction to LOOP, this is\n  even better:\n\n(defun stream-lines (input-stream)\n  (loop for line = (read-line input-stream nil :eof)\n\tuntil (eq line :eof)\n\tcollect line))\n\n  using a number for magic purposes and then testing for any number is\n  _really_ bad style.  where did you pick this up?  a Perl class?\n\n| The function works with files containing less than around 10,000 words,\n| but no matter what I do, whenever I call this function with a file\n| containing more words, I get a stack overflow or a core dump. How can I\n| do this with larger files? I feel like there must be a better way.\n\n  recursion has its uses.  using recursion for iteration is not one of\n  them.  Scheme educators got that one _seriously_ confused, and your code\n  is simply such Scheme code in Common Lisp.  this is _not_ a reasonable\n  thing to do, not even in Scheme.\n\n  my suggestions:\n\n1 get rid of the internal define.\n2 use iteration forms when that's what you do.\n3 use recursion for inherently recursive tasks, only.\n4 learn Common Lisp if you want to think in Common Lisp.\n5 use Scheme if you think in Scheme.\n\n  writing Scheme code in Common Lisp is also really bad for your karma.\n\n#:Erik\n\n",
  "date": "2000-02-10",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}