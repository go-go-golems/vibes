{
  "url": "https://www.xach.com/naggum/articles/3163193555464012@naggum.no.html",
  "id": "3163193555464012@naggum.no",
  "title": "Re: can lisp do what perl does easily?",
  "content": "\nSubject: Re: can lisp do what perl does easily?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/28\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163193555464012@naggum.no>\n\n* ; ; ; h e l m e r . . . <assemblage@t-three.com>\n| I have been slowly learning lisp over the past year and have had someone\n| mention to me that I should learn perl, for jobs etc.\n\n  the unemployed programmer had a problem.  \"I know\", said the programmer,\n  \"I'll just learn perl.\"  the unemployed programmer now had two problems.\n\n  having a job is not unimportant, but if knowing perl is a requirement for\n  a particular job, consider another one before taking that one.  this is\n  true even if you know perl very well.  life is too long to be an expert\n  at harmful things, including such evilness as C++ and perl.\n  \n  I once studied perl enough to read perl code and spot bugs in other\n  people's programs (but later gained the wisdom that this was not an\n  accomplishment -- spotting a bug in a perl program is like spotting the\n  dog that brought the fleas), but I don't write in it and I don't ever\n  plan to use it for anything (part of my new position is quality assurance\n  for the systems I'm inheriting responsibility for, and part of any\n  serious QA is removing perl code the same way you go over a dilapidated\n  building you inherit to remove chewing gum and duct tape and fix whatever\n  was kept together for real).  also, very much unlike any other language I\n  have ever studied, perl has failed to stick to memory, a phenomenon that\n  has actually puzzled me, but I guess there are some things that are so\n  gross you just have to forget, or it'll destroy something with you.  perl\n  is the first such thing I have known.\n\n  this is your brain.  this is perl.  this is your brain on perl.  any\n  questions?\n\n| If I learn lisp well will I be able to do what people do with perl[?]\n\n  no, you won't.  however, there is a very important clue to be had from\n  this: what people do with perl is wrong.  perl makes a whole lot of tasks\n  easy to do, but if you look closely, you will see that those tasks are\n  fundamentally braindamaged, and should never have been initiated.  perl\n  is perhaps the best example I can think of for a theory I have on the\n  ills of optimization and the design choices people make.  most people,\n  when faced with a problem, will not investigate the cause of the problem,\n  but will instead want to solve it because the problem is actually in the\n  way of something more important than figuring out why something suddenly\n  got in their way out of nowhere.  if you are a programmer, you may reach\n  for perl at this point, and perl can remove your problem.  happy, you go\n  on, but find another problem blocking your way, requiring more perl --\n  the perl programmer who veers off the road into the forest will get out\n  of his car and cut down each and every tree that blocks his progress,\n  then drive a few meters and repeat the whole process.  whether he gets\n  where he wanted to go or not is immaterial -- a perl programmer will\n  happily keep moving forward and look busy.  getting a perl programmer\n  back on the road is a managerial responsibility, and it can be very hard:\n  the perl programmer is very good at solving his own problems and assure\n  you that he's on the right track -- he looks like any other programmer\n  who is stuck, and this happens to all of us, but the perl programmer is\n  very different in one crucial capacity: the tool is causing the problems,\n  and unlike other programmers who discover the cause of the problem sooner\n  or later and try something else, perl is rewarding the programmer with a\n  very strong sense of control and accomplishment that a perl programmer\n  does _not_ try something else.\n\n  it's not that perl programmers are idiots, it's that the language rewards\n  idiotic behavior in a way that no other language or tool has ever done,\n  and on top of it, it punishes conscientiousness and quality craftsmanship\n  -- put simply: you can commit any dirty hack in a few minutes in perl,\n  but you can't write an elegant, maintainabale program that becomes an\n  asset to both you and your employer; you can make something work, but you\n  can't really figure out its complete set of failure modes and conditions\n  of failure.  (how do you tell when a regexp has a false positive match?)\n\n  a person's behavior is shaped by the rewards and the punishment he has\n  received while not thinking about his own actions.  few people habitually\n  engage in the introspection necessary to break out of this \"social\n  programming\" or decide to ignore the signals that other people send them,\n  so this is a powerful mechanism for programming the unthinking masses.\n  rewarding idiotic behavior and punishing smart behavior effectively\n  brainwashes people, destroying their value systems and their trust in\n  their own understanding and appreciation of the world they live in, but\n  if you're very good at it, you can create a new world for them in which\n  all of this makes sense.\n\n  to really destroy any useful concepts of how software is supposed to work\n  together, for instance, the best possible way is to ridicule the simple\n  and straightforward concepts inherent in Lisp's read and print syntax,\n  then ridicule the overly complex and entangled concepts in stuff like IDL\n  and CORBA, which does basically the same thing as Lisp's simple syntax,\n  and then hail the randomness of various programs that output junk data,\n  because you can easily massage the data into the randomness that some\n  other program accepts as input.  instead of having syntax-driven data\n  sharing between programs, you have code-driven glue between programs, and\n  because you are brainwashed perl idiot, this is an improvement, mostly to\n  your job security.  and once you start down this path, every move forward\n  is a lot cheaper than any actual improvements to the system that would\n  _obviate_ the need for more glue code.  however, if you never start down\n  this path, you have a chance of making relevant and important changes.\n\n  that's why, if you learn Lisp and become a good programmer, you will\n  never want to do what people do with perl.  as such a good programmer,\n  one in five managers will notice that you solve problems differently and\n  will want to hire you to clean up after the perl programmers he used to\n  be mortally afraid of firing, and you can push any language you want at\n  this point -- just make sure you can find more programmers he can hire\n  who know it and always keep your code well-documented and readable -- you\n  do _not_ want to make any other programming language appear as random as\n  perl to any manager.  perl is already a \"necessary evil\", but still evil,\n  while other languages don't have the \"necessary\" label, so if you screw\n  up, it will hurt other programmers, too.  this problem can always be\n  minimized by simply being good at what you do.  few perl programmers are\n  actually good at anything but getting perl to solve their _immediate_\n  problems, so you have an incredible advantage if you're a good Lisper.\n\n  I'll concede, however, that it is very important to be able to understand\n  what perl programmers do.  if you don't understand what they are talking\n  about, you won't understand what they are actually trying to accomplish\n  with all the incredibly braindamaged uses of hash tables and syntactic\n  sadomasochism, and you won't be able to see through their charades and\n  \"just one more hack, and I'll be there\" lies.\n\n  here's a simple rule to use on perl programmers.  if a solution is clean\n  and complete, it will immediately look like a tremendous amount of work\n  to a perl programmer, which it will: writing code that does the right\n  thing in perl is incredibly arduous.  this is the only positive use for\n  perl programmers.  like a really bad horror movie, where the evil guys\n  have no redeeming qualities whatsoever and will hate anything beautiful\n  or good, a true perl programmer will have a strong emotional reaction to\n  any really good solution: there's no way he can improve on it with his\n  perl hackery, and the very existence of his expertise is threatened.\n\n  then there are good programmers who know and use perl for some tasks, but\n  more than anything else know when _not_ to use it.  they are _very_ rare.\n  \n#:Erik\n\n",
  "date": "2000-03-28",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}