{
  "url": "https://www.xach.com/naggum/articles/3161442459191997@naggum.no.html",
  "id": "3161442459191997@naggum.no",
  "title": "Re: Eureka! Lexical bindings can be guaranteed!",
  "content": "\nSubject: Re: Eureka! Lexical bindings can be guaranteed!\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/07\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161442459191997@naggum.no>\n\n* Andrew Cooke <andrew@andrewcooke.free-online.co.uk>\n| This is a serious question, and not meant to trigger a flame-fest, so\n| maybe it's best answered and asked (sorry) be email.  Here goes...\n\n  it's a contentious issue because there's no relevant research to support\n  the static-typing crowd, yet they have an \"intuitive edge\" that is very\n  hard both to defend formally and to attack informally.  it's like arguing\n  against adults needing milk.  (we don't.  really.)\n\n| While I like Lisp a lot, it strikes me that a statically typed language\n| might be preferable in extreme reliability situations (I'm thinking of\n| ML, for example).  Is that an issue in your experience, and how do you\n| defend Lisp against that criticism?\n\n  in my current setting, which is somewhat more down to earth than NASA's\n  lofty projects despite dealing with financial news distribution, handling\n  errors _gracefully_ has virtually defined the success of the project,\n  which is expanding and providing new services at increasing speed.  the\n  reason explicitly cited has been that the old system that mine replaced\n  died completely and randomly when a component died, while mine stops in a\n  state that is usually continuable right away and never fatal.  running a\n  production system under Emacs under screen may seem rather odd to the old\n  batch-oriented school, but what it means is that I can connect to the\n  Emacs process controlling Allegro CL and examine the system state, talk\n  to background debugging streams, and fix whatever goes wrong if the\n  system hiccups in any way, which it has so far done only with really\n  weird input from the outside world.\n\n  to obtain this level of gracefulness in one of the usual statically typed\n  languages would have required _massive_ amounts of code, simply because\n  you can't combine the dynamism with static typing without recompiling,\n  since _only_ the compiler is privy to the type information.\n\n  conversely, if you need all the type information hanging around at\n  run-time, anyway, why not make _full_ use of it?  sadly, the static\n  typing crowd believes this is inefficient because they never had to make\n  it perform optimally, using their static typing the proof that it is so\n  much easier to do it compile-time, but that only proves they never spent\n  the effort to make it fast at run-time.\n\n  incidentally, my main gripe with static typing is when it is explicit.\n  implicit static typing (like type inference) has a bunch of specific\n  advantages over both dynamic and explicitly typed languages, but in\n  general fall short in terms of dynamism on one hand and the programmer's\n  ability to predict what the system is doing on the other.\n  \n| (In my very limited opinion I get the impression that static checking has\n| improved a lot recently (but it may be that this is decade old work that\n| has stalled) and that a statically typed language with flexibility\n| approaching that of Lisp might be possible - that's a separate issue\n| since you are dealing with existing languages, but is teh background to\n| my question).\n\n  I think it's important to differentiate not on the basis of what the\n  compiler can do with the type information, but what something other than\n  the compiler can do with the type information.  this is largely, but not\n  fully, orthogonal to whether the language is statically or dynamically\n  typed.  debuggers for most languages maintain type information (mainly in\n  order to access the memory they use, of course), but you can't use it if\n  you aren't the debugger.  in some development environments, you get help\n  calling functions and using variables, but what's the big difference\n  between a lookup system only available in some program after compilation\n  and manual pages in external documentation?  the dynamism of _current_\n  information is missing in all of these systems.\n\n  I don't think it's possible to make a statically typed language as\n  dynamic as Common Lisp environments are simply because the work involved\n  in making a statically typed language able to handle the dynamism will\n  involve _very_ intelligent recompilation strategies, mounds of debugging\n  information that people will want to discard, and introspection will have\n  to be added to these languages in environment-specific ways.\n\n#:Erik\n\n",
  "date": "2000-03-07",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}