{
  "url": "https://www.xach.com/naggum/articles/3159124272806425@naggum.no.html",
  "id": "3159124272806425@naggum.no",
  "title": "Re: Are there any LISP development systems that are VC, or other GUI IDE  like?",
  "content": "\nSubject: Re: Are there any LISP development systems that are VC, or other GUI IDE  like?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/09\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159124272806425@naggum.no>\n\n* Robert Posey <muddy@raytheon.com>\n| While the interpreted, or incremental compiled nature of LISP is growing on \n| me I still find all the systems I have used to be a pain.\n\n  Common Lisp systems provide more powerful hammers.  if you are used to\n  C/C++, you are numbed to the pain of hitting your thumb with a puny\n  hammer (at least conceptually), but now that you hit your thumb that much\n  harder, it hurts again, that much more.  the solution is to quit hitting\n  your thumb, not to pad your thumb or stifle the hammer's power.\n\n  at some point in time, you learned the C/C++ way, without reference to\n  much anything, right?  at this point in time, you should endeavor to\n  learn the Common Lisp way, without reference to much anything.  study how\n  people experience in the Common Lisp way do it.  do not attempt to use\n  your C++ expertise in Common Lisp.  what works for C/C++ has evolved over\n  time to be the least painful and/or most efficient.  what governs\n  qualities such as \"least painful\" and \"most efficient\", however, are\n  vastly different for Common Lisp.  it's that simple, really.  _after_ you\n  have established rapport with your environment, you should compare them\n  in terms of what you can accomplish in each with how much work, not in\n  terms of how well a later experience emulates some environment that just\n  happened to be a prior experience.\n\n  most people, when they have learned something, tend to think in extremely\n  concrete terms about what they are doing.  they think they click on menu\n  bars, drag an object, double-click on icons, etc.  they _don't_ think in\n  terms of the operation that said physical activity causes to take place,\n  even though that is why they perform these physical actions.  so when\n  they want to perform that operation in a new environment, they completely\n  _ignore_ the fact that they once had to associate the operation with\n  these actions, and now request the actions, as if the action and the\n  operation were the same.  well, they very obviously aren't, and if they\n  think that way, they failed to learn what they were doing in a productive\n  and efficient way -- they instead learned to parrot actions.  the sooner\n  human beings get out of this modus operandi and become _thinking_ beings,\n  the better, and if it hurts a little to get out of parrot mode, so be it.\n  most everything worth doing is associated with effort and some pain.\n\n  so, to answer your real question: no, we don't debug functions the same\n  way in Common Lisp as in static languages.\n\n  inserting code to get the equivalent of (conditional) breakpoints isn't a\n  problem, btw, since you can edit and recompile a function in seconds, and\n  if you have to do it with a mouse click, teach Emacs to insert \"(break)\"\n  and recompile the function upon a mouse click.  I fail to see the value\n  of such a user interface function, but, hey, it's been years since I set\n  a breakpoint in any C code, too, precisely because I'm much more used to\n  the Common Lisp way, and even the best C debuggers _suck_, so I spend a\n  little more time thinking about the code I write and experimenting in --\n  you guessed it, Common Lisp -- before I commit the design to C, almost as\n  if by hand-compiling code in a real language into machine instructions\n  burned into an EEPROM or something equivalently hardware-like and way\n  cumbersome to deal with.  odd as it may seem, writing bug-free C code is\n  really a breeze once you have come to appreciate and think in Common Lisp.\n\n#:Erik\n\n",
  "date": "2000-02-09",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}