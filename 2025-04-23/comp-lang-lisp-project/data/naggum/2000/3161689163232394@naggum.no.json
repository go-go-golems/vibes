{
  "url": "https://www.xach.com/naggum/articles/3161689163232394@naggum.no.html",
  "id": "3161689163232394@naggum.no",
  "title": "Re: Inline Functions (was: Eureka! Lexical bindings can be guaranteed!)",
  "content": "\nSubject: Re: Inline Functions (was: Eureka! Lexical bindings can be guaranteed!)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/10\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161689163232394@naggum.no>\n\n* Robert Monfera <monfera@fisec.com>\n| As long as the inter-dependency of named functions is known, it would be\n| possible to propagate the invalidation of old definitions and recompile\n| with the new ones.  This may admittedly lead to avalanche effect, and I\n| don't know how to trigger recompilation of closures without some\n| heavyweight administration though.\n\n  the granularity that we get for free when redefining normal, non-inlined\n  functions should thus be eminently implementable, but there are no such\n  systems around.  there aren't even any systems around that automatically\n  recompile functions which use macros that have changed, and that's a much\n  more acute problem.\n\n  in some circumstances, there's a need to upgrade a bunch of functions to\n  the next generation en bloc, preserving calls within the older generation\n  to avoid version skew, but this kind of version control is unavailable.\n\n  what makes you think something like what you propose would be available?\n\n| Inlining reduces debuggability, but reporting accuracy is already\n| reduced at high speed optimization settings, and inlining built-in\n| functions is one of the several existing and valid reasons.\n\n  but users don't generally debug built-in functions.\n\n| Yes, but isn't this effect the same for compiler macros if you use them\n| for the same purpose?\n\n  no, and this is the crucial difference between compiler macros and\n  inlining.  a compiler macro can decide to punt on the expansion, which\n  causes a normal function call.  a compiler macro can also decide to\n  redirect the function call to some other function, or handle part of the\n  function call and punt on the rest.  this means that you have make an\n  informed choice about the expansion.  you don't have that choice in an\n  inlined function's expansion.q\n\n| Do you think that it's too easy to declare a function inlined, and it's a\n| good idea to make this non-trivial concept a little harder by having to\n| use compiler macros?\n\n  since it doesn't help to declare it inline in Allegro CL, I haven't\n  noticed the problem, and in any case, I agree with the decision not to\n  honor inline declarations.  languages that require such features are\n  typically unable to provide meaningful alternatives -- something Common\n  Lisp actually does.\n\n#:Erik\n\n",
  "date": "2000-03-10",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}