{
  "url": "https://www.xach.com/naggum/articles/3163862476772157@naggum.no.html",
  "id": "3163862476772157@naggum.no",
  "title": "Re: howto string->symbol",
  "content": "\nSubject: Re: howto string->symbol\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/04\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163862476772157@naggum.no>\n\n* Tim Bradshaw <tfb@cley.com>\n| Sorry, my mistake, that should have been:\n| \n| \t(format nil \"~A~S\" (symbol-name ...) ...)\n\n  I'm not sure this is really good advice.\n\n  we really want to concatenate a few strings to make a new string.  format\n  does a whole bunch of weird stuff that may look right, but the exhaustive\n  test case is non-trivial to construct, and it really can't be caught any\n  other way until you know what you're doing with an exceptionally high\n  level of precision and attention to detail.  (since this topic comes up\n  every once in a while, a search engine hit rate increaser: static typing\n  -- it won't help at all in such interesting real-life cases.)\n\n  a simple mistake like using ~S with symbols involves the *print-case* of\n  symbols, which, while some people might be happy with the default, will\n  encounter a user who prefers to see lower-case symbol names, the same way\n  he writes them, and it bombs in ways mysterious to the uninitiate.\n\n  a simple mistake like using ~S with numbers involves the *print-base* of\n  numbers, and if the programmer has the skills to set *print-radix* to\n  true while using non-standard read bases, its effects intervene, too.\n\n(let ((*print-case* :downcase)\n      (*print-base* 3)\n      (*print-radix* t))\n  (format nil \"~S~S\" 'hello 3))\n=> \"hello#3r10\"\n\n  format is exceptionally good at producing output suitable for humans.  it\n  is not very good at producing values suitable for the Lisp reader, yet it\n  is so often called upon to do that it hurts.  here's a different solution\n  that uses the proper tools for the job, in my usual, unhumble opinion:\n\n(with-output-to-string (*standard-output*)\n  (with-standard-io-syntax\n    (prin1 'hello)\n    (prin1 3)))\n=> \"HELLO3\"\n\n  an \"optimized\" solution suitable for direct consumption for intern, which\n  is what's really sought in this case:\n\n(concatenate 'string\n    (symbol-name 'hello)\n    (with-standard-io-syntax\n      (write-to-string 3)))\n=> \"HELLO3\"\n\n  this might look less convenient than the wrong format solution, but\n  that's why we have defun.  constructing a new symbol out of constituent\n  parts, however that is defined, is (more or less unfortunately) _not_\n  child's play -- it is a sufficiently specialized task that even \"software\n  pattern\" arguments that this should be an idiom fail: it is not something\n  users are likely to find just one pattern for, and if they find one,\n  it would probably be just as wrong as the wrong format solution.  in\n  other words, they need to find out how this stuff works, and then apply\n  that knowledge to their domain _every_ time.\n\n  incidentally, this is also one of the reasons I favor WYSIWYG print names\n  for symbols.  all of this symbol-hacking stuff would be _significantly_\n  simpler with agreement on that principle.\n\n#:Erik\n\n",
  "date": "2000-04-04",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}