{
  "url": "https://www.xach.com/naggum/articles/3160367893782736@naggum.no.html",
  "id": "3160367893782736@naggum.no",
  "title": "Re: [constants] from a reader macro",
  "content": "\nSubject: Re: [constants] from a reader macro\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/24\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160367893782736@naggum.no>\n\n* Tunc Simsek <simsek@tudor.EECS.Berkeley.EDU>\n| Suppose I define a reader macro:\n| \n| (defun foo (stream char)\n|     `(make-array 10000 :element-type 'double-float))\n| \n| (set-macro-character #\\@ #'foo)\n\n  I assume this is either a serious confusion or an instructive example\n  whose purpose I don't understand, but to which you can apply answers.\n\n| In this silly example each time lisp sees a @ it will return a big array.\n\n  answering the confusion part: it is important to keep in mind exactly\n  which part of \"lisp\" sees it under which conditions, and what it returns,\n  not to forget to what it returns it.  the Lisp reader will see the @ and\n  return the _list_ it received from foo.  if supplied at the top-level,\n  this list is now a form the _evaluation_ of which returns an array, but\n  the Lisp reader is by now long gone, having completed its job.  if read\n  as part of some source code, it will only be folded into the source and\n  later processed with that source code.\n\n| The question is whether I can make it return the same array each time it\n| sees it:\n| \n| (dotimes (i 10000)\n|   @)\n\n  as indicated above, this is exactly identical to\n\n(dotims (i 10000)\n  (make-array 10000 :element-type 'double-float))\n\n  and what happens from then on is not related to the Lisp reader at all,\n  but to the normal behavior of the evaluator and compiler.\n\n| should only create one array, i.e. in my opinion, a CONSTANT.\n\n  however, if you remove the backquote in your misguided reader macro, foo\n  will return a new array that will be treated as a constant by whatever\n  called the Lisp reader each time, but again, the Lisp reader is long gone\n  when this decision is made.\n\n  it seems by your use of the backquote that your core confusion is to\n  believe that \"macro\" in \"reader macro\" is the same kind of \"macro\" as in\n  \"macro function\".  it isn't.  reader macros is a very powerful mechanism\n  to change the syntax of the language, move certain operations into\n  read-time (essentially pre-compile-time), and to abbreviate common forms.\n  reader macros actually make up all the syntax of the language, such that\n  the reader macro for #\\( builds lists.\n\n  I think the reader macro system is absolutely fantastic, but it takes a\n  lot of skill to use it productively, and a lot of serious concern to see\n  when not to use it, just as it takes a lot of intellectual effort to keep\n  syntax simple and clean in general, much more than people generally think\n  -- as witness C++ and Perl, but I'll avoid the digression.\n\n#:Erik\n\n",
  "date": "2000-02-24",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}