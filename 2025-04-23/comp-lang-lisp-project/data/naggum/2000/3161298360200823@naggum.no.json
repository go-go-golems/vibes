{
  "url": "https://www.xach.com/naggum/articles/3161298360200823@naggum.no.html",
  "id": "3161298360200823@naggum.no",
  "title": "Re: Types (in arrays)",
  "content": "\nSubject: Re: Types (in arrays)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/06\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161298360200823@naggum.no>\n\n* Andrew Cooke <andrew@andrewcooke.free-online.co.uk>\n| I have a program that needs to store many arrays of words (16 bits).\n\n  the available types are then (unsigned-byte 16), (signed-byte 16), (mod\n  65536), (integer 0 65535), (integer -32768 +32767), etc, which all should\n  mean the same thing: 16 bits of allocated data per element of the array.\n  if they don't behave the same, you probably have a broken Common Lisp\n  implementation.\n\n| My questions are really:\n| - How do I know which type specifiers are simple enough for a compiler\n| to understand the implications (1 clearly wasn't - although I may be\n| wrong in thinking it is a valid type specifier)?\n\n  the function upgraded-array-element-type will return the internal type it\n  has deemed most optimal for the array element type you have requested.\n\n| - Why does case (3) fail silently?\n\n  probably because the implementation only checks for types it knows, and\n  consider it risky to comment on stuff it doesn't know about.\n\n| - How are types used?  There seem to be several different things going\n| on at once - memory size allocation, testing when new values are stored,\n| initial value allocation (I get zeroes rather than nill if the type is\n| numeric, for example).\n\n  this is a very big question.  the simple answer is that the vendor has\n  made a number of decisions that are believed to give optimal performance,\n  both in time and space, given the type information you have provided.\n  now, this is not quite the useless answer it looks like, because it means\n  that each vendor will make \"personal\" decisions about what constitutes\n  \"optimal performance\" -- and these decisions will naturally differ quite\n  a bit from person to person.  one rule of thumb prevails, however: useful\n  optimizations always reflect the capabilities of the aunderlying hardware,\n  so you have to have a fairly good grasp of how the implementation uses\n  machine resources to make the decisions.  I'll leave it at that for now,\n  since this is issue that very quickly becomes suiteable for comp.arch.\n\n#:Erik\n\n",
  "date": "2000-03-06",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}