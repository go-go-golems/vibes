{
  "url": "https://www.xach.com/naggum/articles/3161299902310489@naggum.no.html",
  "id": "3161299902310489@naggum.no",
  "title": "Re: That place.. (was: How to make a mutually recursive macro and   function)",
  "content": "\nSubject: Re: That place.. (was: How to make a mutually recursive macro and   function)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/06\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161299902310489@naggum.no>\n\n* Christopher Browne\n| What it *really* says is that Scheme has some significant differing\n| underlying assumptions from Common Lisp.\n\n  we all know this to be a deep and fundamental truth, already.\n\n| b) The \"call/cc thing\" parallels the \"tail recursion thing\" where\n|    Scheme requires that implementations have some common primitives.\n|    CL requires no such thing, which provides implementors greater\n|    flexibility, but which diminishes some of the expectations on how\n|    things work that can be made with Scheme.\n\n  this is also one of the differences between the Scheme and the Common\n  Lisp communities.  the Scheme community uses the specification as the\n  source for its expectations and when it can't find something in the\n  specification for Common Lisp, claims that Common Lisp cannot expect it.\n  the Common Lisp community uses the specification and the common sense of\n  vendors and the functioning of the market as its source of expectations,\n  and consequently doesn't have a problem with any of the things that\n  Scheme people have problems with in Common Lisp.  on the other hand, the\n  Common Lisp community recognizes the Scheme community's need for its very\n  thin specification, and argues that the Scheme community cannot expect to\n  have any useful functions in a Scheme environment at all, to which the\n  Scheme community always responds that every Scheme implementation has a\n  lot of goodies that you can rely on, and then there's slib and whatnot,\n  so in the end it seems rather specious of the Scheme adherents to argue\n  that the Common Lisp community cannot expect tail-call merging, which\n  every implementation offers given sufficent optimization settings.\n\n| c) The *problem* with Scheme (which the SRFI process may help remedy)\n|    that the \"call/cc\" thing shows off is that call/cc was intended to\n|    be treated as a *primitive* that would be used to implement control\n|    structures.\n\n  and Common Lisp has all those control structures that Scheme people\n  implement with call/cc.  it's like giving programmers access to a\n  primitive of creating, linking, and unlinking call frames, but no\n  function call primitive.  (Scheme doesn't have funcall, as you know. :)\n\n| In short, it's not that call/cc is particularly bad, it's that call/cc is\n| merely a primitive, and isn't widely useful until you use the primitive\n| to build specifically useful structures.\n\n  which implies that the usefulness of implementing these control\n  structures with call/cc has to be questioned, since none of the Common\n  Lisp implementations even use the primitive operation call/cc underneath,\n  and they also don't generally heap-allocate call frames, but remain with\n  the stack-allocation paradigm.  in short, call/cc is a primitive that is\n  too primitive for its own good: it demands a particular way to do things\n  that doesn't reflect how people have come to conclude they should be\n  done.  the same is true of Scheme's tail calls.  it doesn't make sense to\n  force every tail call to be a jump, as it messes with argument passing\n  conventions and stack unwinding and many forms of debuggability and a\n  host of other issues tha makes communication with other languages hard.\n\n  so in my view, Scheme's core function call model is simply a mistake, and\n  both tail calls and call/cc make the design mistakes explicitly visible\n  to the users.  learning from such mistakes is an important part of moving\n  forward in language design, and this may indeed be why no other language\n  has picked up on these ideas, despite having picked up on a number of\n  other valuable contributions from Scheme.  some of this reflects badly on\n  \"adjacent ideas\" in Scheme, too.\n\n  again in my view, there are probably mistakes in Common Lisp's design\n  that makes it hard for people to pick up on adjacent ideas, too.  for one\n  thing, I have started to believe that the use of upper-case symbol names\n  is a serious communications bottleneck with other languages that we need\n  to talk to these days.  it's not that we can't overcome it, it's that\n  it's such a hassle to overcome it.  and it's not a technical issue, just\n  like start-up time is not a technical issue, it's a matter of perception\n  and how we approach contrary views when they necessarily come up.\n  \n#:Erik\n\n",
  "date": "2000-03-06",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}