{
  "url": "https://www.xach.com/naggum/articles/3162506888111902@naggum.no.html",
  "id": "3162506888111902@naggum.no",
  "title": "Re: strings and characters",
  "content": "\nSubject: Re: strings and characters\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/20\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162506888111902@naggum.no>\n\n* Gareth McCaughan <Gareth.McCaughan@pobox.com>\n| What about the complete absence of any statement anywhere in the standard\n| (so far as I can tell) that it's legal for storing characters in a string\n| to throw away their attributes?\n\n  what of it?  in case you don't realize the full ramification of the\n  equally completely absence of any mechanism to use, query, or set these\n  implementation-defined attributes to characters, the express intent of\n  the removal of bits and fonts were to remove character attributes from\n  the language.  they are no longer there as part of the official standard,\n  and any implementation has to document what it does to them as part of\n  the set of implementation-defined features.  OBVIOUSLY, the _standard_ is\n  not the right document to prescribe the consequences of such features!\n  an implementation, consequently, may or may not want to store attributes\n  in strings, and it is free to do or not to do so, and the standard cannot\n  prescribe this behavior.\n\n  conversely, if implementation-defined attributes were to be retained,\n  shouldn't they have an explicit statement that they were to be retaiend,\n  which would require an implementation to abide by certain rules in the\n  implementation-defined areas?  that sounds _much_ more plausible to me\n  than saying \"implementation-defined\" and then defining it in the standard.\n\n  when talking about what an implementation is allowed to do on its own\n  accord, omitting specifics means it's free to do whatever it pleases.  in\n  any requirement that is covered by conformance clauses, an omission is\n  treated very differently: it means you can't do it.  we are not talking\n  about _standard_ attributes of characters (that's the code, and that's\n  the only attribute _required_ to be in _standard_ strings), but about\n  implementation-defined attributes.\n\n| I don't see why #1 is relevant. #2 is interesting, but the language is\n| defined by what the standard says, not by what it used to say.\n\n  it says \"implementation-defined attributes\" and it says \"subtype of\n  character\", which is all I need to go by.  you seem to want the standard\n  to prescribe implementation-defined behavior.  this is an obvious no-go.\n\n  it is quite the disingenious twist to attempt to rephrase what I said as\n  \"what the standard used to say\", but I'm getting used to a lot of weird\n  stuff from your side already, so I'll just point out to you that I'm\n  referring to how it came to be what it is, not what it used to say.  if\n  you can't see the difference, I can't help you understand, but if you do\n  see the difference, you will understand that no standard or other\n  document written by and intended for human beings can ever be perfect in\n  the way you seem to expect.  expecting standards to be free of errors or\n  of the need of interpretation by humans is just mind-bogglingly stupid,\n  so I'm blithly assuming that you don't hold that view, but instead don't\n  see that you are nonetheless flirting with it.\n\n| The point here is simply that there can be several different kinds of\n| string.  The standard says that there may be string types that only\n| permit a subtype of CHARACTER; it doesn't say that there need be no\n| string type that permits CHARACTER itself.\n\n  sigh.  the point I'm trying to make is that it doesn't _require_ there to\n  be one particular string type which can hold characters with all the\n  implementation-defined attributes.\n\n|    (make-array 10 :element-type 'character)   [S]\n|    (make-string 10 :element-type 'character)  [S']\n| \n| Therefore S and S' are arrays of the same type.\n\n  sorry, this is a mere tautology that brings nothing to the argument.\n\n| Therefore there is at least one string (namely S) that can hold arbitrary\n| characters.\n\n  but you are not showing that it can hold arbitrary characters.  _nothing_\n  in what you dig up actually argues that implementation-defined attributes\n  have standardized semantics.  an implementation is, by virtue of its very\n  own definition of the semantics, able to define a character in isolation\n  as having some implementation-defined attributes and strings to contain\n  characters without such implementation-defined attributes.  this is the\n  result of the removal of the type string-char and the subsequent merging\n  of the semantics of character and string-char.\n\n| It doesn't require *every* string type to be able to hold all character\n| values.  It does, however, require *some* string type to be able to hold\n| all character values.\n\n  where do you find support for this?  nowhere does the standard say that a\n  string must retain implementation-defined attributes of characters.  it\n  does say that the code attribute is the only standard attributes, and it\n  is obvious that that attribute must be retained wherever.  it is not at\n  all obvious that implementation-defined attributes must survive all kinds\n  of operations.\n\n  you've been exceedingly specific in finding ways to defend your position,\n  but nowhere do you find actual evidence of a requirement that there exist\n  a string type that would not reject at least some character objects.  I'm\n  sorry, but the premise that some string type _must_ be able to hold _all_\n  characters, including all the implementation-defined attributes that\n  strings never were intended to hold to begin with, is no more than\n  unsupported wishful thinking, but if you hold this premise as axiomatic,\n  you won't see that it is unsupported.  if you discard it as an axiom and\n  then try to find support for it, you find that you can't -- the language\n  definition is sufficiently slippery that these implementation-defined\n  attributes don't have any standard-prescribed semantics for them at all,\n  including giving the implementation leeway to define their behavior,\n  which means: not _requiring_ anything particular about them, which means:\n  not _requiring_ strings to retain them, since that would be a particular\n  requirement about an implementation-defined property of the language.\n  \n| The reason why STRING is a union type is that implementors might want to\n| have (say) an \"efficient\" string type that uses only one byte per\n| character, for storing \"easy\" strings.  Having this as well as a type\n| that can store arbitrary characters, and having them both be subtypes of\n| STRING, requires that STRING be a union type.\n\n  now, this is the interesting part.  _which_ string would that be?  as far\n  as I understand your argument, you're allowing an implementation to have\n  an implementation-defined standard type to hold simple characters (there\n  is only one _standard_ attribute -- the code), while it is _required_ to\n  support a wider _non-standard_ implementation-defined type?  this is\n  another contradiction in terms.  either the same requirement is standard\n  or it is implementation-defined -- it can't be both a the same time.\n\n  I quote from the character proposal that led to the changes we're\n  discussing, _not_ to imply that what isn't in the standard is more of a\n  requirement on the implementation than the standard, but to identify the\n  intent and spirit of the change.  as with any legally binding document,\n  if you can't figure it out by reading the actual document, you go hunting\n  for the meaning in the preparatory works.  luckily, we have access to the\n  preparatory works with the HyperSpec.  it should shed light on the\n  wording in the standard, if necessary.  in this case, it is necessary.\n\nRemove all discussion of attributes from the language specification.  Add\nthe following discussion:\n\n   ``Earlier versions of Common LISP incorporated FONT and BITS as\n     attributes of character objects.  These and other supported\n     attributes are considered implementation-defined attributes and\n     if supported by an implementation effect the action of selected\n     functions.''\n\n  what we have is a standard that didn't come out and say \"you can't retain\n  bits and fonts from CLtL1 in characters\", but _allowed_ an implementation\n  to retain them, in whatever way they wanted.  since the standard removed\n  these features, it must be interpreted relative to that (bloody) obvious\n  intent if a wording might be interpreted by some that the change would\n  require providing _additional_ support for the removed features -- such\n  an interpretation _must_ be discarded, even if it is possible to argue\n  for it in an interpretative vacuum, which never exists in any document\n  written by and for human beings regardless of some people's desires.\n  (such a vacuum cannot even exist in mathematics -- which reading a\n  standard is not an exercise in, anyway -- any document must always be\n  read in a context that supplies and retains its intention, otherwise\n  _human_ communication breaks down completely.)\n  \n#:Erik\n\n",
  "date": "2000-03-20",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}