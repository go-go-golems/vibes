{
  "url": "https://www.xach.com/naggum/articles/3160735878041395@naggum.no.html",
  "id": "3160735878041395@naggum.no",
  "title": "Re: [executables] was: why Haskell hasn't replaced CL yet?",
  "content": "\nSubject: Re: [executables] was: why Haskell hasn't replaced CL yet?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/28\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160735878041395@naggum.no>\n\n* not.for.email@not.for.spam\n| On 28 Feb 2000 11:39:14 +0000, Erik Naggum <erik@naggum.no> wrote:\n| \n| >time (for x in 0 1 2 3 4; do for y in 0 1 2 3 4 5 6 7 8 9; do ./allegro -batch -kill & done; done; wait)\n| \n| That looks like you're starting up 50 copies and waiting for them all to\n| exit.  (If I understand what the '&' does.)\n\n  you don't.  waiting for zombies doesn't take time, and processes aren't\n  started up _all_ in parallell.  as you could have seen from the output if\n  you had cared to, the processes clearly start up and terminate fairly\n  sequentially.  this is a pretty good indication that we are not starting\n  up 50 copies all in parallell, not to mention the fact that we manage to\n  squeeze 50 full instantiations within one second.  regardless of what you\n  think, the fact that this loop terminates in less than 1 second actually\n  means that all of them started up and terminated within an average of 20\n  ms of real time each.  and since this is a dual processor system, it\n  would be pretty stupid not to take advantage of it, so you got what you\n  asked for: 50 copies started and terminated in less than 1 second.  now\n  is a good time to _believe_, heathen.\n\n| What would the results be if you waited for each to exit before starting\n| the next?\n\n  a miniscule waste of time in the looping construct.  the user and system\n  time total 1.5 seconds.  the real time is < 1 s.  you do the math.\n\n| Is Allegro written in Lisp?\n\n  yes.  that is, more than 98% is written in Lisp.  (writing a Common Lisp\n  system in anything else is _really_ painful.)  the operating system\n  interface substrate is written in C because that's what the Unix\n  operating system requires for portable substrate code.  if the Unix\n  operating system had been intelligently designed and hadn't outboarded so\n  much of the kernel interface to the C libraries, it would have been\n  easier to deal with the kernel through small, well-defined system calls\n  in assembly language, but that's just too much to maintain from version\n  to version, where the only stable link to the kernel is the C library.\n\n  I'm somewhat amazed by the resilience of your prejudices.\n  \n#:Erik\n\n",
  "date": "2000-02-28",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}