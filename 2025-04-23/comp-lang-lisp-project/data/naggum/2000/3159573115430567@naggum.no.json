{
  "url": "https://www.xach.com/naggum/articles/3159573115430567@naggum.no.html",
  "id": "3159573115430567@naggum.no",
  "title": "Re: Benefits of tail recursion (was: Cost of Recursion)",
  "content": "\nSubject: Re: Benefits of tail recursion (was: Cost of Recursion)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/15\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159573115430567@naggum.no>\n\n* Robert Munyer <munyer@mcs.com>\n| For me, a loop written with ITERATE is easier to read than the same loop\n| written with DO.  With ITERATE, the process of computation has a more\n| linear \"flow\" through the text of the function.  With DO, the step forms\n| are interleaved with the initialization forms, which makes the flow of\n| computation feel like it's been \"scattered\" all over the text of the\n| function.\n\n  what's keeping you from writing an ITERATE macro that expands into DO\n  (or, rather, TAGBODY and GO forms)?  it should be eminently doable in the\n  majority of cases where it is indeed only (tail-recursive) iteration.\n\n| In summary: the next time you're programming a loop, and the code doesn't\n| seem to \"fit,\" try using recursion.  You might be surprised how well it\n| works.\n\n  there is no semantic difference between (PSETQ FOO X BAR Z) (GO TAG) and\n  (ITERATOR :FOO X :BAR Z) as long as both \"resolve\" to tail recursion.\n  (I'm using keyword arguments only to be explicit.)\n\n| In fact, I think the whole concept of \"iteration vs. recursion\" is a\n| wrong way to think, a left-over distinction from the days before we\n| understood tail recursion.  I think it makes sense to think of a\n| tail-recursive program as being both iterative AND recursive.\n\n  I agree with you on this.\n\n| Now, on to the example I promised earlier.  Below is a function I wrote a\n| couple of years ago.  As I recall, I tried several times to write it with\n| DO, and every time the code came out UGLY.  So I tried doing it with\n| recursion, and it \"just worked.\"  It was easier to write, and easier to\n| read, and just as efficient as the version I wrote with DO.\n| \n| ; Returns INV such that (= (MOD (* NUMBER INV) MODULUS) (GCD NUMBER MODULUS)).\n| ; Note that if NUMBER and MODULUS are relatively prime, the GCD is 1, and INV\n| ; is the multiplicative inverse of NUMBER over the Galois field of MODULUS.\n| \n| (defun mod-inverse (number modulus)\n|   (check-type number  (integer 1))\n|   (check-type modulus (integer 1))\n|   (iterate iter ((a modulus) (b number) (c 0) (d 1))\n|     (multiple-value-bind (q r) (floor a b)\n|       (cond ((plusp r) (iter b r d (- c (* q d)))) ; thanks Euclid!\n|             ((minusp d) (+ d modulus))\n|             (t d)))))\n\n(do ((a modulus) (b number) (c 0) (d 1))\n    ((multiple-value-bind (q r) (floor a b)\n       (if (plusp r) (psetq a b b r c d d (- c (* q d))) t))\n     (if (minusp d) (+ d modulus) d)))\n\n  it _is_ unfortunate that DO et al were invented so long before multiple\n  values that we sometimes have to expand out the forms manually.\n\n  hope this helps.\n\n#:Erik\n\n",
  "date": "2000-02-15",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}