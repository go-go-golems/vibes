{
  "url": "https://www.xach.com/naggum/articles/3161565178384561@naggum.no.html",
  "id": "3161565178384561@naggum.no",
  "title": "Re: newbie Lisp question",
  "content": "\nSubject: Re: newbie Lisp question\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/09\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161565178384561@naggum.no>\n\n* Robert Monfera <monfera@fisec.com>\n| When is it encouraged to put together symbol names though?  By default,\n| DEFSTRUCT produces a host of functions with glued names, but it isn't\n| common in CL.\n| \n| Is it an indication that automagical function (or whatever) creation with\n| glued names is rarely encouraged?  Any examples when it's the best way of\n| achieving something other than system integration?\n\n  recently, I wrote that making some concepts hard to express didn't cause\n  people to suffer from having to express them, but made the concepts\n  suffer because they would be underutilized.  humans, falling prey to the\n  siren song of convenience, will always think this way.  therefore, the\n  languages we use must make smart concepts convenient to express and dumb\n  concepts inconvenient to express.  the natural tendency is the opposite.\n\n(intern (concatenate 'string (symbol-name #:make-) (symbol-name symbol))\n        (symbol-package symbol))\n\n  will return a new symbol prefixed with \"make-\" in the same package as the\n  symbol without the prefix (thanks for that careful bit, Pierre), but is\n  this hard to read?  is it a lot of \"internal stuff\" that people shouldn't\n  ned to worry about?  I dont' think so.  I think this is the smallest you\n  can do, short of writing a function specifically to glue symbol names\n  that does all this, but think about its hypothetical interface for a\n  second: it would naturally want two symbols, but which one is prefix and\n  which one is suffix?  (resist the temptation to search for the hyphen!)\n  so either you get two functions or you supply the package separately, or\n  perhaps you think you could supply one string and one symbol, but either\n  way, you have caused the user of your function to exercise a lot more\n  brainpower on your symbol-glue function than on the expression above,\n  which should be a no-brainer for an experienced Common Lisp programmer in\n  a way the symbol-glue functions wouldn't be because they are infrequently\n  used.  and if they aren't infrequently used, we're back to Robert's\n  question: should we encourage this?  I don't think we should, either, so\n  it would be bad if it were too convenient to do it.\n\n  FORMAT is clearly in the \"too convenient\" camp, since it makes doing it\n  the wrong way so convenient, and burdens the user with case conversion\n  issues in the reader and the printer at the same time.\n\n  but consider a More Common Lisp that does no case conversion in the\n  reader or the printer (which is more common than doing it, hence my\n  punnish name), with what-you-see-is-what-you-get symbol names:\n\n(intern (format nil \"make-~a\" symbol) (symbol-package symbol))\n\n  consider all the idiomatic stuff we got rid of: either an uninterned or\n  keyword symbol just to get the symbol name right or an upper-case prefix\n  string literal, and extracting the symbol-name part.  this idiomatic\n  burden is a no-brainer to an experienced Common Lisp programmer, but\n  _acquiring_ the expertise so it becomes a no-brainer is not effortless at\n  all, and probably involves struggling and lots of confusion until the\n  full ramifications of Common Lisp's attitude to case are internalized.\n\n  so instead of encouraging the convenient creation of symbols, we have an\n  elaborate scheme to discourage people from looking at symbol names and\n  only use the symbols as symbols, but this works directly against the work\n  needed to acquire the expertise in using them correctly!  since symbols\n  is very powerful abstraction mechanism, and case conversion is also a\n  very powerful mechanism in human communication (it has definite value,\n  but by informed choice, not default), we've forced ourselves out on a\n  limb every time we have to deal with them, and some are worrying that any\n  proposal to fix this is akin to cutting the limb on the dumb side.  this\n  is a case of making a smart concept cumbersome to express, and forces us\n  to consider more convenient options merely for the sake of convenience --\n  it should have been _sufficiently_ convenient to begin with not to have\n  to worry about case conversion details.\n\n  let's find a way to make Common Lisp work with readtable-case :preserve\n  and lower-case symbol names, so what-you-see-is-what-you-get-ness is also\n  preserved for experienced and novice programmer alike, and we can do\n  smart stuff without having to be too clever, too.\n\n#:Erik\n\n",
  "date": "2000-03-09",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}