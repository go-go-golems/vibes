{
  "url": "https://www.xach.com/naggum/articles/3159296157829526@naggum.no.html",
  "id": "3159296157829526@naggum.no",
  "title": "Re: What is LISP?",
  "content": "\nSubject: Re: What is LISP?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/11\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159296157829526@naggum.no>\n\n* Erik Naggum\n| C++-style overloading is fundamentally evil, and is therefore not\n| supported by good languages.  (note: this is not an opinion.)\n\n* Vladimir Nesterovsky\n| So far it's the only C++ feature as I know of, that has no correspondence\n| in Common LISP.  That's the only argument of the C++ people that I don't\n| know how to answer to.\n| \n| While I'll take your word for it, could you please just provide me with\n| some explanation, so that whenever that argument comes, I'd have an\n| answer.\n\n  sure.\n\n  the main semantic argument against C++-style operator overloading is that\n  there is nothing in the language that helps maintain consistency of any\n  kind for each implementation of an overloaded operator.  in particular,\n  each implementation may well have completely different argument lists,\n  commutativity may differ at will, but you still have to cope with the\n  same associativity and order of precedence.  a + is not a +, anymore.\n  (witness the absurd and decidedly overcute use of << and >> for I/O.)\n\n  the main pragmatic argument against C++-style operator overloading is a\n  fatal design decision.  the choice of which function to call makes the\n  use of overloaded operators downright dangerous: the return type of an\n  overloaded operator is _not_ taken into account when choosing the\n  particular implementation, which causes a cascade of decisions in nested\n  or sequential forms over which you have no control.  in particular, code\n  changes anywhere in an interconnected system can affect such decisions\n  adversely, without even the possibility of warning or traceability since\n  editing and (re-)compiling are so separated tasks.\n\n  the main stylistic argument is that a reader of the code has no idea what\n  to expect from _any_ expression that uses operators that _might_ have\n  been overloaded, without _manually_ checking for surprises, _remembering_\n  the types of objects, and trying to reconstruct the whole decision chain\n  made by the compiler.\n\n  so what makes a language feature evil?  first, when it wastes human brain\n  time on minutiae that language features are supposed to help _conserve_\n  or at least spend _more_ wisely.  second, when it forces people to\n  second-guess the compiler to figure out what's going on.  third, when you\n  despite second-guessing the compiler can no longer know for _certain_\n  what will happen, but have to makes guesses in the first place.  all in\n  all, a language feature is evil when it removes from the programmer's\n  control what, precisely, he is doing, at all levels of abstraction and\n  semantics and he is left with uncertainty and doubt, if not obscure bugs\n  that are extremely hard to find and which makes systems using such\n  features frightfully fragile.\n\n  even the good uses of operator overloading, for which they were added to\n  that miserable excuse for a programming language, destroy the ability of\n  _any_ \"visiting\" programmer to know what _any_ expression means, meaning\n  that the required level of intimacy with the code is tremendously high,\n  which translates to \"job security\" for Joe C++ Programmer and \"how to get\n  royally screwed\" for his employer.\n\n  so not only is operator overloading evil, programmers who want it are\n  looking for \"insurance\" if they should ever have any serious gripes with\n  their employers.  as I have said previously, in connection with the need\n  among C++ programmers to \"protect\" their data and methods, C++ is for\n  thieves and bums who expect _others_ to steal, too; operator overloading\n  is just more of the same: bad people are attracted to features with high\n  abusiveness potential along with anal-retentive protection schemes\n  because they expect everybody else to screw them, too.\n\n  (very little of this is _mere_ opinion.)\n\n#:Erik\n\n",
  "date": "2000-02-11",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}