{
  "url": "https://www.xach.com/naggum/articles/3160383123856271@naggum.no.html",
  "id": "3160383123856271@naggum.no",
  "title": "Re: [constants] from a reader macro",
  "content": "\nSubject: Re: [constants] from a reader macro\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/24\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160383123856271@naggum.no>\n\n* Erik Naggum\n| it seems by your use of the backquote that your core confusion is to\n| believe that \"macro\" in \"reader macro\" is the same kind of \"macro\" as in\n| \"macro function\".  it isn't.\n\n* Tunc Simsek\n| I must confess that I don't understand this remark, they behave in the\n| same way, their ranges are lisp code.\n\n  no.  that's the issue.  the \"range\" of macros is Lisp code which will be\n  processed by the caller, usually the compiler on code it processes.  the\n  \"range\" of reader macros is Lisp objects the Lisp reader was asked to\n  pick up from some textual input source, such as by the compiler when it\n  compiles files.  viz, a macro to build a matrix would return the code to\n  be evaluated or compiled instead of the macro form, while a reader macro\n  to build a matrix would return the matrix as a constant object.\n\n  moreover, they do not behave in the same way.  a macro function is called\n  with Lisp code it can transform at will, while a reader macro is expected\n  to build Lisp objects from parsing input.  the \"domain\" of the former is\n  Lisp objects and code, while the \"domain\" of the latter is characters and\n  streams.  this must be understood in depth before you can make use of\n  reader macros productively.  most Lisp programmers don't know how the\n  Lisp reader and printer work to begin with, or how to add new objects to\n  the read-write-consistency paradigm.  indeed, not understanding how Lisp\n  has solved this very difficult problem is why most designers of protocols\n  and syntaxes get them so incredibly wrong.\n\n| My intent is to get a simple way of expressing constant matrices which I\n| use a lot and don't like to type in (make-matrix ... all the time.\n\n  this is good.  however, you should regard your reader macro as a\n  short-cut for #.(make-matrix ...), not for (make-matrix ...) if you want\n  to build the matrix in the reader macro (and nothing else makes sense).\n\n| I actually know of one problem with using #\\[ as a macro character:\n| allegro uses it as a super paranthesi.\n\n  which \"allegro\" is that?  Allegro CL does not violate the standard by\n  interpreting [ and ] as anything but ordinary symbol name constituents.\n\n#:Erik\n\n",
  "date": "2000-02-24",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}