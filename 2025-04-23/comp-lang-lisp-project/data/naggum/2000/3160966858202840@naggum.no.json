{
  "url": "https://www.xach.com/naggum/articles/3160966858202840@naggum.no.html",
  "id": "3160966858202840@naggum.no",
  "title": "Re: A modest proposal (long)",
  "content": "\nSubject: Re: A modest proposal (long)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/02\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160966858202840@naggum.no>\n\n* Erann Gat\n| The problem is not special variables.  The problem is the way you tell\n| Lisp which variables you want to make special and which you don't.\n\n  so let me disagree vociferously with that, too.  if we make necessary\n  things inconvenient to express, it is not their expression that will\n  suffer the most, but common recognition of their necessity.  the fact\n  that special variables solve a problem that exist in _every_ programming\n  language so conveniently, namely how to ascertain proper restoration of\n  global variables, means that people aren't going to reinvent tricks with\n  unwind-protect and the like (if they know about unwind-protect -- Kent\n  Pitman has made the cogent argument that languages can be judged on the\n  existence of such a language feature -- I'll argue that the same applies\n  to programmers and whether they know about it).\n\n  as soon as you start to make these special variables stand out as the\n  wart on the language that you appear to believe they are, people will\n  naturally avoid them (and the more so the more weirdo syntax soup you\n  introduce, the threat of which I now realize is part of my objection to\n  your syntax-heavy proposal), and choose the next best thing that looks\n  like it could be sufficiently convenient.  then they start to make buggy\n  or needlessly verbose code, which they'll loathe.  you're rocking the\n  boat and making life miserable for those who _need_ special variables and\n  need them _not_ to look _too_ special, because that destroys their very\n  significant convenience factor.  I say: don't do that.  solve the actual\n  problems, don't just push your special brand of cosmetics.\n\n| The issue is not just one of querying.  It's also one of control.  There's\n| no way to undo the effects of a defvar short of uninterning the symbol.\n\n  so let's find a way to do that, instead, then.  (how hard can this be?)\n\n  I think a Common Lisp environment needs universal functionality to \"undo\"\n  or \"kill\" all definition forms.  Allegro CL has a nifty feature to kill\n  various definitions from the Emacs interface, and I use it seldom enough\n  to appreciate it very highly every time, but it does not accept defvar.\n  (I'll file a request for enhancement for that.)  this might be considered\n  annoying, but in the meantime, here's a couple tiny functions to muck\n  with the gory internals of symbols in a way that is guaranteed to make a\n  whole slew people want to puke violently, but if they get over it and\n  realize that Common Lisp is all about _exporting_ an elegant interface to\n  lots of really hairy stuff to begin with, they might actually rejoice and\n  use these functions.\n\n(in-package :excl)\n\n#+allegro-v5.0.1\n(defun symbol-special-p (symbol)\n  (declare (optimize (speed 3) (safety 0)) (symbol symbol))\n  (check-type symbol symbol)\n  (if (and (not (eq nil symbol))\n\t   (zerop (ldb (byte 1 #.(system::mdparam 'compiler::md-symbol-flag-constant-bit))\n\t\t       (excl::sy_flags symbol))))\n    (not (zerop (ldb (byte 1 #.(system::mdparam 'compiler::md-symbol-flag-globally-special-bit))\n\t\t     (excl::sy_flags symbol))))\n    nil))\n\n#+allegro-v5.0.1\n(defun (setf symbol-special-p) (special symbol)\n  (declare (optimize (speed 3) (safety 0)) (symbol symbol))\n  (check-type symbol symbol)\n  (if (and (not (eq nil symbol))\n\t   (zerop (ldb (byte 1 #.(system::mdparam 'compiler::md-symbol-flag-constant-bit))\n\t\t       (excl::sy_flags symbol))))\n    (setf (excl::sy_flags symbol)\n      (dpb (if special 1 0)\n\t   (byte 1 #.(system::mdparam 'compiler::md-symbol-flag-globally-special-bit))\n\t   (excl::sy_flags symbol)))\n    (error \"Cannot change special status of constant symbol ~S.\" symbol)))\n\n  perhaps needless to say, you can hurt your Allegro CL system with the\n  latter function, even though I have tried to restrict a few particular\n  damages that users are likely to try (and I know how to restrict).\n\n  if you don't have Allegro CL 5.0.1, this won't necessarily fail, but _you_\n  had to remove the read-time conditionals so _you_ take the responsibility.\n\n| >   again, there is a need to change the language to make it more amenable to\n| >   beginners and experienced users alike: unlike all other languages now in\n| >   current and widespread use, Common Lisp violates the notion that what you\n| >   see is what you get with respect to the _names_ of the symbols.\n| \n| Maybe it would help to review the distinction between a variable and a\n| symbol (and the name of a symbol) just to make sure we are all on\n| the same page.\n\n  find, but sometimes, it isn't everybody else who need to be on your page.\n\n| The point is that none of this has anything to do with symbol names.\n\n  duh.  I'm trying to redirect your attention to a worth-while problem,\n  entirely _away_ from messing with stuff you shouldn't be messing with.\n\n| I thought that's what I was doing, but it seems I still have not made\n| myself clear.   You seem to think that I am saying that the problem is\n| the existence of dynamic variables and symbol-value.   I'm not saying\n| that at all.   What I am saying is that the way things currently stand,\n| when you write 'X' you can't in general know whether what you've written\n| is a reference to a stack frame or a slot in an object on the heap.\n| And, in fact, as you yourself pointed out the meaning of X can change\n| over time if you are running interpreted.  IMO that's bad.\n\n  and IMNSHO, it isn't bad at all.  I have pointed out that we need a few\n  accessors into the environment to solve your uncertainty problem, and\n  perhaps we need a `notspecial' or `lexical' declaration to be able to\n  undo the pervasive effects of the `special' declaration.  however, I care\n  so much about the language that I'm unwilling to consider your proposal\n  when I understand the issues so much better than you do and I consider\n  your proposal to be a major disturbance over a petty issue that mainly\n  has to do with a disportional sense of uncertainty.  now, I fully\n  recognize that uncertainty is one of those things that make people go\n  nuts and that it is vitally important in a community to avoid swarms of\n  neurotics who run around with proposals that are mainly intended to\n  affect their mental state in some vaguely positive way, so I instead\n  propose something that will make the uncertainty go away by adding a very\n  low-level certainty instead of making any changes to superficial features\n  that will take yet more forms as the swarm of neurotics has only been\n  decimated for now, not actually cured of their unhealthy uncertainty.\n\n| >  it's not a question of case,\n| >   it's a matter of making (setf (readtable-case *readtable*) :preserve)\n| >   work the way people _actually_ expect it to.  think about it.  please.\n| \n| It would help if you would stop talking in riddles.\n\n  geez.  there are no riddles.  I'm talking about something other than you\n  do, because I think what you're talking about is counter-productive.  you\n  missed that point entirely when you thought I was still talking about\n  your concerns over specialness when I talked about symbol names.  I'm a\n  little concerned with the breakdown of communication that occurs when\n  people don't notice that others aren't talking about the same thing they\n  are, anymore, but just keep on and on about whatever they had in mind.\n\n| Works the way I'd expect it to.\n\n  so try typing in (setf (readtable-case *readtable*) :upcase) and tell me\n  what you expect to happen and/or that this is not a useful thing to do.\n  (note again that this is no longer a question of special variables.)\n\n#:Erik\n\n",
  "date": "2000-03-02",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}