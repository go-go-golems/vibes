{
  "url": "https://www.xach.com/naggum/articles/3162184639382952@naggum.no.html",
  "id": "3162184639382952@naggum.no",
  "title": "Re: strings and characters",
  "content": "\nSubject: Re: strings and characters\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/16\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162184639382952@naggum.no>\n\n* Tim Bradshaw <tfb@cley.com>\n| The particular thing I don't understand is what type a literal string\n| has.  It looks at first sight as if it should be something capable of\n| holding any CHARACTER, but I'm not really sure if that's right.  It looks\n| to me as if it might be possible read things such that it's OK to return\n| something that can only hold a subtype of CHARACTER in some cases.\n\n  strings _always_ contain a subtype of character.  e.g., an implementation\n  that supports bits will have to discard them from strings.  the only\n  array type that can contain all character objects has element-type t.\n\n| I'm actually more concerned with the flip side of this -- if almost all\n| the time I get some `good' subtype of CHARACTER (probably BASE-CHAR?)\n| but sometimes I get some ginormous multibyte unicode thing or something,\n| because I need to be able I have to deal with some C code which is\n| blithely assuming that unsigned chars are just small integers and strings\n| are arrays of small integers and so on in the usual C way, and I'm not\n| sure that I can trust my strings to be the same as its strings.\n\n  this is not a string issue, it's an FFI issue.  if you tell your FFI that\n  you want to ship a string to a C function, it should do the conversion\n  for you if it needs to be performed.  if you can't trust your FFI to do\n  the necessary conversions, you need a better FFI.\n\n| I realise that people who care about character issues are probably\n| laughing at me at this point, but my main aim is to keep everything as\n| simple as I can, and especially I don't want to have to keep copying my\n| strings into arrays of small integers (which I was doing at one point,\n| but it's too hairy).\n\n  if you worry about these things, your life is already _way_ more complex\n  than it needs to be.  a string is a string.  each element of the string\n  is a character.  stop worrying beyond this point.  C and Common Lisp\n  agree on this fundamental belief, believe it or not.  your _quality_\n  Common Lisp implementation will ensure that whatever invariants are\n  maintained in _each_ environment.\n\n| The practical question I guess is -- are there any implementations which\n| do currently have really big characters in strings?\n\n  yes, and not only that -- it's vitally important that strings take up no\n  more space than they need.  a system that doesn't support both\n  base-string (of base-char) and string (of extended-char) when it attempts\n  to support Unicode will fail in the market -- Europe and the U.S. simply\n  can't tolerate the huge growth in memory consumption from wantonly using\n  twice as much as you need.  Unicode even comes with a very intelligent\n  compression technique because people realize that it's a waste of space\n  to use 16 bits and more for characters in a given character set group.\n\n| I know there's an international Allegro, so those might have horrors in\n| them.\n\n  sure, but in the same vein, it might also have responsible, intelligent\n  people behind it, not neurotics who fail to realize that customers have\n  requirements that _must_ be resolved.  Allegro CL's international version\n  deals very well with conversion between the native system strings and its\n  internal strings.  I know -- not only do I run the International version\n  in a test environment that needs wide characters _internally_, the test\n  environment can't handle Unicode or anything else wide at all, and it's\n  never been a problem.\n\n  incidentally, I don't see this as any different from whether you have a\n  simple-base-string, a simple-string, a base-string, or a string.  if you\n  _have_ to worry, you should be the vendor or implementor of strings, not\n  the user.  if you are the user and worry, you either have a problem that\n  you need to take up with your friendly programmer-savvy shrink, or you\n  call your vendor and ask for support.  I don't see this as any different\n  from whether an array has a fill-pointer or not, either.  if you hand it\n  to your friendly FFI and you worry about the length of the array with or\n  without fill-pointer, you're simply worrying too much, or you have a bug\n  that needs to be fixed.\n\n  \"might have horrors\"!  what's next?  monster strings under your bed?\n\n#:Erik\n\n",
  "date": "2000-03-16",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}