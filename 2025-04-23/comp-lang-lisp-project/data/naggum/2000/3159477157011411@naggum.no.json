{
  "url": "https://www.xach.com/naggum/articles/3159477157011411@naggum.no.html",
  "id": "3159477157011411@naggum.no",
  "title": "Re: About the usage of throw/catch",
  "content": "\nSubject: Re: About the usage of throw/catch\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/14\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159477157011411@naggum.no>\n\n* arolambler@aol.com (ArolAmbler)\n| I phrased it in a way subject to misintrepretation.  Since the dynamic\n| scope of a tag ends with the dynamic scope of the tagbody, it is not\n| legal tn CL to create closures over recursive tagbodies, and go to tags\n| for tagbodies that have been exited.  (Although I strongly suspect some\n| implementations do not detect the problem, and some may even support it\n| properly.).\n\n  well, I asked for an example, got it, and now I'm asking for more.  why\n  this \"strongly suspect\" point?  it seems you're creating problems for the\n  purpose of creating or showing off complexity, not for the opposing, much\n  more reasonable, purpose of solving them and reducing overall complexity.\n  (this is a more verbose version of the \"ivory tower\" accusation.)\n\n| Thus, foo is called recursively, so there are multiple closures and\n| tagbodies active.\n\n  a GO is explicitly defined to reach the innermost accessible tag, so this\n  is not a semantic problem.  it may be a pragmatic or stylistic problem in\n  that you can't easily figure out which tag is the innermost, however.\n\n| As to \"throw/catch\" being \"needed\".  That is true, WHEN you have to glue\n| together stuff in a hurry, and can't change the interfaces to some of it.\n\n  I think you should consider the possibility that you have overlooked\n  something when you make sweeping generalizations like this.  it is quite\n  annoying to have to deal with statements that are true but incomplete,\n  yet false when completed or extended to their natural context.  that is,\n  your assessment of the situation is relevant, yet not the only one that\n  needs to be considered, and therefore, the conclusion does not hold for\n  anyone but those who restrict themselves to your particular context.\n  again, \"ivory tower\" might apply to such strong yet narrow arguments.\n\n| BUT: it is far better to make the result value have one or more\n| \"exceptional\" values (such as null in ANSII SQL, or the NANs of IEEE\n| floating point arithmetic).  The operations all \"propagate\" the\n| exceptional VALUE, without any non-local control transfer.\n\n  I was disappointed when waiting for the capitalized WHEN to support the\n  \"it is far better\" sweeping generalization sans reservations or context.\n  in some contexts, what you propose is indeed a good idea.  few people use\n  CATCH/THROW or other exception-handling mechanisms in such contexts, for\n  the very simple reason that the first time they run into a problem, they\n  will most probably swear and even more probably redesign their code.  in\n  the context of an exception-handling mechanism that is ill-designed, we\n  do have the option of talking to the people who wrote the code and even\n  in many cases to do what you consider so gross -- to wrap up the code in\n  some advice or whatever to protect you from harm, but doing so in cases\n  where it clearly has no value is an argument against your generalization.\n\n| As I said in the first post on this issue: non-local transfer of control\n| is dirty, because it does not \"reuse\" well.\n\n  yes, this is so, in _some_ contexts, but I'm getting increasingly curious\n  why you exclude all _other_ contexts as inherently irrelevant to any\n  discussion of this language feature or of exception-handling in general.\n\n| Said in a more sophisticated way, incomprehensible probably to the\n| original poster, neither functors nor combinators in general, nor any\n| function that maps a function over a set of values can easily use any\n| function that sometimes throws, unless the function is first \"cleaned up\"\n| by wrapping a catch, return exceptional value piece around it.  And\n| repetitively \"cleaning up\" every time I reuse a function means the\n| function has a bad behavior.\n\n  this is obviously a bogus general claim.  most of the time, we are not\n  faced with irreversible side effects of our functions, and we are not\n  therefore in need of a transactional approach to \"committing\" or not\n  \"committing\" whole executions of complex pieces of code.  it helps, and\n  I'll easily grand you that, to know _when_ to require a simple \"completed\n  or not done at all\" result from a function, however.\n\n  \"best effort\"-functions that return some \"impossible\" values may actually\n  have the annoying consequence that the failure mode is _less_ predictable\n  than an exception, as _some_ transactions were \"committed\" after some\n  failure had occurred, meaning that the failed transactions now have to be\n  committed out of order, or not at all, which is very different from an\n  _aggregate_ \"commit\".  I hope you appreciate this distinction.\n\n  I'm not interested in your ad hominem arguments: just because you have\n  shipped so-and-so-products does not lend any credibility to any of your\n  arguments -- I'm _not_ interested in who you are or what you have done; I\n  _am_ interested in whether you can support your sweeping arguments\n  without reference to such claim to fame or credentials, the inclusion of\n  which in my view detracts very significantly from effective argumentation.\n\n#:Erik, who's beginning to discover that vacations have serious down-sides :)\n\n",
  "date": "2000-02-14",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}