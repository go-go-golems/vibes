{
  "url": "https://www.xach.com/naggum/articles/3160523543335494@naggum.no.html",
  "id": "3160523543335494@naggum.no",
  "title": "Re: [executables] was: why Haskell hasn't replaced CL yet?",
  "content": "\nSubject: Re: [executables] was: why Haskell hasn't replaced CL yet?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/26\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160523543335494@naggum.no>\n\n* Tunc Simsek <simsek@paleale.EECS.Berkeley.EDU>\n| Regarding this point, I was asked the following question:  \"how small of \n| an executable can you get from a CL program that simply prints HELLO WORLD\n| at the term\".\n\n  note that \"how small an executable\" actually means \"how much do the\n  operating system and the executable agree on\".  e.g., in the case of C\n  programs under Unix, so much that the executable can effectively be a few\n  hundred bytes, as the shared libraries that are involved and the\n  initialization code for the program are, after all, what the entire\n  operating system is optimized for.  this does not mean the memory\n  footprint of the executable when loaded into memory will be small, or\n  that it won't do a lot of work behind the scenes.\n\n| I don't know the answer, infact I don't even know how to produce an\n| executable from a Lisp program, I never had any need for it.\n\n  exactly.  therefore, the smallest \"executable Common Lisp program\" that\n  does the same meaningless task as the typical \"hello, world\" demo that\n  shows off how functions and interactive invocation work under Unix, is\n  either simply the string \"hello, world\" typed to a listener (and what's\n  the sport in that?) or (defun hello () \"hello, world\") which is almost as\n  unchallenging.\n\n  what we have to realize and counter with is that building lots of tiny\n  little programs in C is a very inefficient way to build an interactive\n  environment.  think of all the programs and scripts and whatnot as small\n  functions that can pass values around only as textual strings in pipes at\n  best.  each program is ephemeral and must use the disk for its variables\n  or state if it has any, or it must receive environment variables and\n  options each time and the state is maintained in the caller.  each\n  program is run by loading and dynamically linking a *huge* amount of\n  stuff every time.  in contrast, a Common Lisp system got all of this\n  interactive development environment stuff _right_, with very much simpler\n  and faster function invocation once you start it up, but you also have to\n  start up a shell to start you hello program.  so why focus on the size of\n  the \"executable\".  refocus on the amount of work involved and how having\n  to use an executable on disk for such a trivial behavior is really not a\n  good thing to begin with.\n\n#:Erik\n\n",
  "date": "2000-02-26",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}