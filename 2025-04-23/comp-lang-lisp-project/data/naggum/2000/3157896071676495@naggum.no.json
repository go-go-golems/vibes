{
  "url": "https://www.xach.com/naggum/articles/3157896071676495@naggum.no.html",
  "id": "3157896071676495@naggum.no",
  "title": "Re: reading/writing bytes smaller than 8 bits?",
  "content": "\nSubject: Re: reading/writing bytes smaller than 8 bits?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/26\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157896071676495@naggum.no>\n\n* \"Bruce L. Lambert\" <lambertb@uic.edu>\n| I just figured 1 byte = 8 bits, therefore 1 (unsigned-byte 4) = 4 bits =\n| 0.5 bytes both in Lisp and in a file on disk. Simple, yet erroneous,\n| deductive logic on my part.\n\nbyte n. 1. adjacent bits within an _integer_. (The specific number of bits\ncan vary from point to point in the program; see the _function_ BYTE.)\n                     -- from the Common Lisp the Standard (ANSI X3.226-1994)\n\n| If not the OS, then what system determines how an (unsigned-byte 4) or\n| any other object gets written to disk?  Does each application make its\n| own decisions on this point?\n\n  yes.  Unix doesn't know about file contents.  it stores only bytes (still\n  of no predetermined size).  the only common byte size these days is 8,\n  but Unix was delivered in the past on machines with 9-bit bytes.  (this\n  historical fact has even escaped most C programmers.)\n\n| I just was trying to understand the space considerations of some code I'm\n| writing.  I figured there was a direct mapping from the size of the\n| internal data structure to the size of the file.\n\n  there never are.\n\n  the first tenet of information representation is that external and\n  internal data formats are incommensurate concepts.  there simply is no\n  possible way they could be conflated conceptually.  to move from external\n  to internal representation, you have to go through a process of _reading_\n  the data, and to move from internal to external representation, you have\n  to go through a process of _writing_ the data.  these processes are\n  non-trivial, programmatically, conceptually, and physically.  that some\n  languages make them appear simple is to their credit, but as always,\n  programming languages are about _pragmatics_, and it doesn't make sense\n  to make conceptually complex things complex to use and program -- quite\n  the contrary, in fact.  so the more things that are different look the\n  same to a programmer, the higher the likelihood that there is something\n  complex and worthwhile going on behind the scenes.\n\n  the second tenet of information representation is that optimizations for\n  internal representations are invalid for external representation and vice\n  versa.  the crucial difference is that data in internal representation is\n  always under the control of the exact same software at all times, while\n  data in external representation _never_ is.  therefore, decisions you\n  make when optimizing internal representation exploit the fact that you\n  have full control over the resources that are being used to represent it,\n  such as actually knowing all the assumptions that might be involved,\n  while decisions you make when optimizing external representation must\n  yield to the fact that you have no control over the resources that are\n  being used to represent it.  a corollary is that storing any data in raw,\n  memory-like form externally (_including_ network protocols) is so stupid\n  and incompetent that programmers who do it without thinking should be\n  punished under law and required to prove that they have understood the\n  simplest concepts of computer design before they are ever let near a\n  computer again.\n\n  the third tenet of information representation is that data in _any_\n  external representation is _never_ outlived by the code, and that is an\n  inherent quality of external representation: the very reason you decided\n  to write it out to begin with is the reason it won't go away when the\n  code that wrote it did.  this fact alone so fundamentally alters the\n  parameters of optimization of external representation from internal that\n  the only consequence of not heeding it is to wantonly destroy information.\n\n  now, there is one particular software company that profits by breaking\n  all possible understanding of information representation, and who makes\n  their very living from destroying the value of information previously\n  committed to the care of their software.  this _started_ through sheer,\n  idiotic incompetence on their part, but turned into company policy only a\n  few years later: the company mission is now to destroy information like\n  no company has ever done before, for the sole purpose of causing the\n  customers to continue to pay for software that renders their past useless\n  and thus in need of re-creation, data conversion, etc.\n\n| That is, if a thousand-element array of 4-bit bytes takes 512 bytes\n| (according to time), and I write the contents of that array to disk, I\n| expected to see a 512 byte file.  Not so, apparently.\n\n  avoid the temptation to confuse internal with external representation,\n  and you will do fine.  as soon as you think the two are even remotely\n  connected (as such -- going through a read/write process is precisely the\n  point showing how they are _not_ connected as such), you lose.  big time,\n  and the way back to unconfusion is long and hard.  witness all the C\n  victims who actually think it makes sense to dump memory to files.  they\n  lose so badly you'd think somebody would learn from it, but no -- their\n  whole philosophy is to remain braindamaged in the face of danger, as that\n  kept them out of the scary, scary task of having to _think_ about things,\n  not something C programmers are very good at.\n\n  a 1000-element vector of (unsigned-byte 4) may optimally be stored as 500\n  bytes on a disk file if you are willing to _know_ what the file is like.\n  typically, hwoever, you would include metainformation that is not needed\n  once it has been processed and is in memory, versioning information, some\n  form of validation clues for the information (array bounds, etc), and in\n  all likelihood if you store binary data, some compression technique.\n  many arguments to the contrary notwithstanding, binary representation,\n  when it has been made to work, is _incredibly_ bloated compared to what\n  people set out believing it will be.  making binary representation\n  efficient is so hard that most people give up, satisfied with gross\n  inefficiency.  a Microsoft Word document is the typical example of how\n  unintelligently things _can_ be done when the real dunces are let at it.\n\n  you may actually be better off writing your vector of 4-bit bytes out as\n  hexadecimal digits, pretending that it is a huge number.  Common Lisp\n  does not offer you any _huge_ help in hacking such notations back to more\n  common internal representations, but actually trying to time the work you\n  do during I/O has left many programmers bewildered by the cost of such a\n  simple operation.  a disk read can easily take millions of times longer\n  than a memory read.  whether you decode digits in that time or map bits\n  directly into memory is completely irrelevant to the system performance.\n\n  the conditions under which these low-level things matter are so different\n  from what normal people experience that they will have studied the topic\n  of internal and external representation very carefully before they need\n  to know the details.\n\n| Allegro is my vendor.\n\n  well, no, Franz Inc is the vendor behind Allegro CL.\n\n#:Erik\n\n",
  "date": "2000-01-26",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}