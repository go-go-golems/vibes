{
  "url": "https://www.xach.com/naggum/articles/3157901044670304@naggum.no.html",
  "id": "3157901044670304@naggum.no",
  "title": "Re: Transmeta's Crusoe as a host for neo-Lispm, or not?",
  "content": "\nSubject: Re: Transmeta's Crusoe as a host for neo-Lispm, or not?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/26\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157901044670304@naggum.no>\n\n* Barry Margolin <barmar@bbnplanet.com>\n| I'm not familiar with the Pentium III architecture (I haven't really\n| studied an instruction set since the Z80).  Could you give some examples\n| of the features you're talking about?\n\n  I'd like to, but that needs delving back into the documentation and doing\n  quite a bit of research.  I have not found time for it in the past few\n  days, and a three-week break is coming up fast, so I have to disappoint\n  you with long response times on this one.\n\n| Are these things like the MMX instructions (those were in the Pentium II,\n| as well, weren't they)?\n\n  the simplest idea is to use published knowledge of the core architecture\n  to schedule register updates, memory transactions, etc, vastly more\n  efficiently.  several new instructions have also been added to make life\n  a lot easier for particular tasks -- but actually being able to use them\n  well requires significant effort on both the part of the programmers and\n  the compiler writers.\n\n| I know it has lots of bit-twiddling instructions that are supposed to be\n| useful for graphics, and I think some DSP-related instructions, but\n| neither of these seem like they would be of much assistance in Lisp.\n\n  once I understood what they were doing, they were useful mathematical\n  functions and transformations that required you to shape your problem in\n  a particular way to be able to use.  some of these \"contortions\" would\n  not be something a Lisp compiler would ordinarily engage in at all.\n  however, I wanted to be able to use these instructions and looked at how\n  I would have to go about that, but in the end, I decided against adding\n  instructions to the compiler.\n\n| How do other applications make use of these features?\n\n  inlined assembly, or even whole functions in assembly language.  there\n  are few compilers out there that can make full use of these things, but\n  the instruction scheduling isn't terribly hard to codify.  the best part\n  is that when it's done properly, it doesn't affect performance on the\n  older processors.  the new instructions are sometimes expanded as macros\n  by the better assemblers into instruction sequences for older processors.\n\n| Isn't there some way to use the instructions and trap into macrocode when\n| running on an older processor?\n\n  there are a whole bunch of CPU flags which tell you whether these new\n  features are available or not, so you would typically prepare a fat\n  binary that contained several versions of the same function according to\n  processor to make optimal use of these features.  many games do this.\n\n#:Erik\n\n",
  "date": "2000-01-26",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}