{
  "url": "https://www.xach.com/naggum/articles/3159120191728291@naggum.no.html",
  "id": "3159120191728291@naggum.no",
  "title": "Re: What is LISP?",
  "content": "\nSubject: Re: What is LISP?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/09\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159120191728291@naggum.no>\n\n* Robert Posey <muddy@raytheon.com>\n| Question 1:\n| \n| As I understand it nothing in CL standard requires an Interpreter, does\n| it even require an interactive mode?\n\n  standards always have explicitly and very strictly limited scope.  the\n  way users interact with a Common Lisp system is outside the scope of the\n  Common Lisp standard.\n\n| Question 2:\n| \n| What should LISP typing method be called?\n\n  it is already called \"dynamic typing\", \"manifest typing\", etc.\n\n| I have heard several variations, but all the more advanced code I have\n| seen makes use of typing for at least some of the symbols.\n\n  you're applying static typing terminology to dynamic typing phenomena.\n  this will hurt your understanding.  in Common Lisp, _values_ have type,\n  and variables can (normally) hold values of any type.  therefore, you\n  don't talk about the type of symbols (variables), but about the types of\n  values that a variable can hold.  in statically typed languages, the type\n  affects the layout and size of the memory allocated to a variable.  in\n  Common Lisp, a variable is always allocated the same size memory, and\n  what it holds is a pointer to the value, stored elsewhere, except in some\n  obvious optimizations like (small) integers and characters, which fit in\n  the space of such a pointer.  to make things work efficiently in this\n  model, pointers carry type information.  this is very much unlike what\n  you do in statically typed languages, where pointers are just machine\n  addresses which the compiler hopes will point to values it knows, and\n  then it tries to make sure its hopes come true by barfing on code that it\n  can see will or does violate its hopes.  it can never actually be 100%\n  certain, however.  using typed pointers, one doesn't have to deal with\n  such silly hopes, and can instead work with whatever is there.\n\n  put it another way, in a statically typed language, you may sometimes\n  need to lie to your compiler to do the right thing, like you sometimes\n  have to lie to officials who are anal-retentive about stupid laws and\n  regulations, while in dynamically typed languages, you don't have to lie,\n  because the laws and regulations can't be stupid.\n\n| Question 3:\n| \n| Is it true that you can overload(in C++ Terms) built in operators in LISP? \n\n  no.  C++-style overloading is fundamentally evil, and is therefore not\n  supported by good languages.  (note: this is not an opinion.)\n\n| Question 4:\n| \n| What does the :ntest (I think) key do for applicable functions?\n\n  whatever the function documents it to do.  the meaning of keywords\n  arguments is not added vertically to functions in Common Lisp.\n\n  :NTEST is unknown to me.  however, if you refer to the :TEST-NOT keyword,\n  common to functions which also sport a :TEST keyword, for functions that\n  support this semantics, it's a way to specify a test function to whose\n  value NOT is applied before it is used.  another way to do the same thing\n  is :TEST (COMPLEMENT <function>).\n\n#:Erik\n\n",
  "date": "2000-02-09",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}