{
  "url": "https://www.xach.com/naggum/articles/3162223661729749@naggum.no.html",
  "id": "3162223661729749@naggum.no",
  "title": "Re: strings and characters",
  "content": "\nSubject: Re: strings and characters\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/16\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162223661729749@naggum.no>\n\n* Erik Naggum\n| strings _always_ contain a subtype of character.  e.g., an implementation\n| that supports bits will have to discard them from strings.  the only\n| array type that can contain all character objects has element-type t.\n\n* Tim Bradshaw\n| I don't think this is right -- rather I agree that they contain\n| CHARACTERs, but it looks like `bits' -- which I think now are\n| `implementation-defined attributes' -- can end up in strings, or at least\n| it is implementation-defined whether they do or not (2.4.5 says this I\n| think).\n\n  trivially, \"strings _always_ contain a subtype of character\" must be true\n  as character is a subtype of character, but I did mean in the sense that\n  strings _don't_ contain full character objects, despite the relegation of\n  fonts and bits to \"implementation-defined attributes\".  that the type\n  string-char was removed from the language but the attributes were sort of\n  retained is perhaps confusing, but it is quite unambiguous as to intent.\n\n  so must \"the only array type that can contain all character objects has\n  element-type t\" be true, since a string is allowed to contain a subtype\n  of type character.  (16.1.2 is pertinent in this regard.)  it may come as\n  a surprise to people, but if you store a random character object into a\n  string, you're not guaranteed that what you get back is eql to what you\n  put into it.\n\n  furthermore, there is no print syntax for implementation-defined\n  attributes in strings, and no implementation is allowed to add any.  it\n  is perhaps not obvious, but the retention of attributes is restricted by\n  _both_ the string type's capabilities and the stream type's capabilities.\n\n  you can quibble with the standard all you like -- you aren't going to see\n  any implementation-defined attributes in string literals.  if you compare\n  with CLtL1 and its explicit support for string-char which didn't support\n  them at all, you must realize that in order to _have_ any support for\n  implementation-defined attributes, you have to _add_ it above and beyond\n  what strings did in CLtL1.  this is an extremely unlikely addition to an\n  implementation just after bits and fonts were removed from the language\n  and relegated to \"implementation-defined attributes\".\n\n  I think the rest of your paranoid conspiratorial delusions about what\n  \"horrors\" might afflict Common Lisp implementations are equally lacking\n  in merit.  like, nothing is going to start spitting Unicode at you, Tim.\n  not until and unless you ask for it.  it's called \"responsible vendors\".\n\n| The only place it will matter is network transmission of data, and I\n| don't see why normal compression techniques shouldn't deal with that.\n\n  then read the technical report and decrease your ignorance.  sheesh.\n\n#:Erik, who's actually quite disappointed, now.\n\n",
  "date": "2000-03-16",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}