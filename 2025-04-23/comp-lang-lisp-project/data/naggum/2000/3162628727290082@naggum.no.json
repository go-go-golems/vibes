{
  "url": "https://www.xach.com/naggum/articles/3162628727290082@naggum.no.html",
  "id": "3162628727290082@naggum.no",
  "title": "Re: strings and characters",
  "content": "\nSubject: Re: strings and characters\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/21\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162628727290082@naggum.no>\n\n* Gareth McCaughan <Gareth.McCaughan@pobox.com>\n| Well, this is an argument. To paraphrase (and I'm sure you'll tell me if\n| this is misleading), \"The behaviour of implementation- -defined things is\n| implementation-defined\". The trouble is that this proves too much -- if\n| the implementation-defined-ness of character attributes other than the\n| CODE means that implementations are allowed to throw them away when\n| characters are stored in strings, I don't see why it shouldn't also mean\n| that implementations are allowed to throw them away when you bind them to\n| variables, or put them in lists.\n\n  you don't see that?  well, I can't help you see that, then.  let me just\n  reiterate what I have previously said: a regular array with element-type\n  t can hold any character object.  if you insist on being silly, however,\n  there's nothing I can do to prevent this from going completely wacky.\n\n| No, I don't want the standard to prescribe implementation-defined\n| behaviour. I just don't think that \"implementation-defined\n| attributes\" means \"mysterious things whose semantics may be\n| entirely inconsistent with everything in this standard\".\n\n  that is your interpretation, Gareth, and I claim it's unsupported by\n  facts, but ever more supported by silliness and \"I don't see why\"'s.\n  now, I do see how you are reaching your conclusion, I just don't accept\n  that you have refuted the one thing I'm still claiming: that the standard\n  _requires_ there to be a specialized array (string) that must be able to\n  hold all character objects.  since you're going into silly mode, I can\n  only guess that you don't understand my argument and have to ridicule it.\n\n  and let me just say that an implementation that chooses to allow strings\n  to hold all attributes is obviously just as conforming as one that only\n  has strings that holds the code attribute.\n\n| I don't know why you think I expect the standard to be perfect.\n\n  because you use it as the basis of proofs that you expect to be\n  universally valid without recognizing your own interpretative work\n  (including omitting irrelevant points that seem irrelevant to you) in\n  constructing them.  the confidence in perfection required to do this is\n  quite staggering.\n\n| I do think that my interpretation is more natural than yours, and that\n| the amount of error the standard would have to contain if your view were\n| right is considerably more than the amount it would have to contain if\n| mine were right.  Both of these (plus the fact that it seems on the whole\n| to have very few errors) lead me to prefer my view to yours.\n\n  this, however, is a valid line of argument.  I just happen to disagree.\n\n| That observation is there for a picky pedantic reason: that I want to\n| make it explicit not only that there are things capable of holding\n| arbitrary characters, but that those things are actually strings in the\n| sense defined in the standard.\n\n  and I have already pointed out that the union type does not contain the\n  individiual type that is _required_ to hold all characters.  to get that,\n  you have to upgrade the element-type to t.\n\n| Clearly you consider my deduction flawed.  You haven't, though, said\n| what's wrong with it.\n\n  yes, I have.  I have pointed out that it ignores several important\n  factors that affect how you can interpret the standard.  in particular,\n  that the requirement you come up with _adds_ additional burden to an\n  implementation that decides to continue to support implementation-defined\n  attributes above and beyond what it needed to do before they were removed\n  from the standard.  this is clearly a serious mismatch between intent and\n  expression, and we need to understand the intent behind the standard when\n  it seems to say something that isn't very smart.\n\n| That's borne out by Barry Margolin's recollections of the discussions of\n| the standardising committee.\n\n  for some reason, I have yet to see those posted to the newsgroup.  if you\n  could mail them to me, I'd be much obliged.\n\n| My interpretation of the standard doesn't make it require anyone to add\n| support for the removed features.\n\n  now, this is just plain ridiculous or unbelievably ignorant.\n\n  strings in CLtL1 were made up of string-char elements, not character.\n  string-char explicitly excluded fonts and bits attributes.  now that\n  string-char has been removed, and you claim strings have to contain the\n  whole character type, and not only a subtype, as I claim, the string that\n  used to be able to contain only the code attribute, now has to be able to\n  contain characters _with_ implementation-defined attributes, as well.\n  this is NOT A QUIET CHANGE to the implementation -- it has a really major\n  impact on system storage requirements.  this fact, however, is recognized\n  in the reader for strings (which may dump attributes at will, however\n  they wound up in the characters read from an input stream) and intern\n  (which may also dump them at will, regardless of how they could get into\n  the string to begin with).\n\n  clearly, you don't understand the implications of what you interpret the\n  standard to say if you don't understand that it forces an implementation\n  to _add_ support for a feature the standard effectively deprecates.\n  \n#:Erik\n\n",
  "date": "2000-03-21",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}