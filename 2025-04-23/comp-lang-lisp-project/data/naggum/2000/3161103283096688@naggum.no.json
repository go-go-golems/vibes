{
  "url": "https://www.xach.com/naggum/articles/3161103283096688@naggum.no.html",
  "id": "3161103283096688@naggum.no",
  "title": "Re: A modest proposal (long)",
  "content": "\nSubject: Re: A modest proposal (long)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/03\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161103283096688@naggum.no>\n\n* Erann Gat\n| Common Lisp is case-sensitive like people expect.\n\n  we might as well conclude at this time that special variables work just\n  the way people expect, because we make a semi-conscious decision to\n  ignore those values of \"people\" where \"expect\" returns false.  _some_\n  people, however, do not expect the same as you do, and they might even\n  react the same way you do to some aspect of special variables (\"it's\n  EVIL!\") to some aspects of upper-case symbol names.  it's _so_ amusing\n  that you don't get this.\n\n  the point being, put like a nice little riddle: those who have problems\n  with symbol-value are also likely have problems with symbol-name.\n\n| I don't know whether this last item is part of the standard or simply a\n| consequence of the default read table case being :upcase.\n\n  the symbols are all upper-case and Lisp has case conversion because the\n  languages that Lisp talked to had upper-case names and case conversion,\n  FORTRAN in particular.  since symbols are first-class citizens in Lisp,\n  and not in most other languages, we have been stuck with them in a way\n  that other languages haven't.  other languages have moved on to a much\n  richer character set (the upper-case thing was merely an artifact of the\n  terminal equipment and punched cards on which the code was written) and\n  have dispensed with case conversion because it loses information that is\n  now more readily available.\n\n| In any case, to make CL act like every other language out there we'd have\n| to 1) change the default readtable-case to :preserve and 2) change the\n| names of all the standard symbols.\n\n  that's the straightforward answer, but now you're going into this\n  \"there's only one solution to this problem, and that's the one I just\n  dreamt up, but since I didn't like the problem, I dreamt up a bad\n  solution, so therefore the problem is also bad\" mode which seems to have\n  an incredible attraction to you.  I'm explicitly trying to get you _off_\n  of that path.  can you work with me on this, please?\n\n  Allegro CL has the ability to do just what you're describing, and has had\n  it forever because of the Franz Lisp legacy -- it was lower-case and case\n  sensitive.  today, excl:set-case-mode actually converts symbol names from\n  upper-case to lower-case.  Allegro CL is actually built with lower-case\n  symbol names, upper-cased as a step in building the distributed version\n  to customers.  this is not a problem for Franz Inc, and not a problem for\n  their customers.  many customers also revert to lower-case mode simply\n  because it makes a lot more sense than upper-case mode does at this time.\n  that they don't talk about it has to do with the fact that some people\n  get _really_ upset whenever case is brought up, but it finally dawned on\n  me that we're _not_ talking about case, we're talking about which other\n  languages we want to communicate with, and case issues _follow_ from\n  that.  it's not as if case is the primary factor of choice and we just\n  happen to like FORTRAN better than C.  it's that to talk to FORTRAN, you\n  had to use the same case FORTRAN did, which were upper-case, but to talk\n  to C, you have to use the same case C does, which is in both cases.  it's\n  a question of communication.  of course, we can demand that other people\n  talk to us, and refuse to listen to their arguments.  people who do that\n  on an habitual basis in real life, too, probably stick with upper-case in\n  Common Lisp, as well.\n\n  yet, however you wish to regard this, case-swapping is not something you\n  do without vendor support.  Allegro CL already has all the support it\n  needs.  in the case of CLISP or CMUCL, you're free to fix it yourself in\n  any way you want that doesn't have to be \"portable\" at all.  that leaves\n  us with what Harlequin and Digitool would do if they were asked.\n\n| Straightforward implementation-specific hacks won't work because the\n| symbol name is stored in many places, not just in the symbol.\n\n  so let's do non-straightforward implementation-specific hacks, then.\n  (again, how hard can it possibly be to realize that when you have found\n  an obvious flaw in a given _solution_, you keep looking for solutions,\n  you don't just give up and shout the _inverse_ of \"eureka!\" and declare\n  the _problem_ dead and buried.)\n\n| You could make duplicate symbols with lower-case names and copy their\n| value, function, and plist slots, but this would probably break\n| most compilers, which probably have code like (case (car form) (if ...\n\n  again, I would prefer to engage the creative part of the brain, not the\n  propaganda machine, when we encounter engineering problems.  obviously,\n  this idea is really stupid, and so it's an indirect insult to would-be\n  proposers to assume that they haven't even thought about it.  but, hey,\n  this is also something I'm trying to get you away from resorting to.\n\n  Common Lisp is often hailed as suitable for writing mini-languages.  now,\n  instead of writing a _new_ mini-language, I think it's important that we\n  find a way for a fully conforming ANSI Common Lisp implementation to be\n  able to handle source code in :preserve mode, written in lower-case.\n  this is _obviously_ not a problem, since Common Lisp is good at writing\n  mini-languages.  right?  right!  let's see if it is possible to turn code\n  written with :preserve and lower-case expectations into code that can be\n  compiled without changing much anything.  this should be eminently doable\n  for the vast majority of cases.  (if there be residiual problems, I hope\n  we can avoid more propaganda machine output and instead focus on solving\n  them or theorizing about the problems, not just sit down and wimper.)\n\n| Or you could just tell beginners not to mess with readtable-case at all\n| since the :upcase default generally does the Right Thing.\n\n  and that's what I've been telling you to do with your \"special\" hacks.\n  I'm relieved that you think this is an OK response to a silly proposal,\n  but in this case, I'm trying to show you that my proposal, which I sort\n  of expected you to dislike, is actually quite similar to your problem:\n  how to get people's expectations to fit the language they use, and vice\n  versa.  you can't dismiss this _problem_, and I certainly did not dismiss\n  it in your proposals, but you can still dismiss proposed solutions.\n  that's why I wanted you to see the difference between bundling a problem\n  with a solution and having it rejected and looking a problem square in\n  the eye and determine to solve it by submitting a whole bunch of ideas\n  for other people's rejection and perhaps that one winner.\n\n#:Erik\n\n",
  "date": "2000-03-03",
  "author": "Erik Naggum",
  "references": [],
  "source": "naggum"
}