{
  "threads": [
    {
      "id": "deep_copy_in_lisp:_how?",
      "title": "Deep copy in lisp: how?",
      "posts": [
        {
          "id": "3164291289641126@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-09",
          "display_date": "04/09/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/09\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164291289641126@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| I have a CLOS object which may contain an arbitrary graph of other\n| objects.  This graph may be cyclic.  I'm looking for an easy way to deep\n| copy the object.\n\n  the only easy way out is to write a copier that knows what it's doing.\n  any easier way out would violate \"as simple as possible, but no simpler\".\n\n| I've been told that generic deep copy might be implementing by writing\n| the object to a stream, and then reading back from that stream.\n\n  you've been told that?  what a joker that must have been!  how do you\n  think you would proceed to implement readers and writers for the objects?\n  do you think _they_ come in generic versions that do everything right?\n\n  (for the languages where you may use a generic version that does it wrong\n  most of the time, which you usuallyq observe if you try, there _is_ the\n  merit to this language design that most \"modern programmers\" (= dummies)\n  are a lot happier when they something out and see it fail, then do it\n  \"right\" (= less _obviously_ wrong), than to know it would fail and know\n  they had to do it right from the start.)\n\n  implementing a mechanism that avoids descending into cyclic structures is\n  amazingly easy.  detection is easy with the rabbit and the hare algorithm.\n  a hash table of copied objects avoids all possible problems to begin with.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3164297272958870@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-09",
          "display_date": "04/09/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/09\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164297272958870@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| I know this is possible one way or the other, for I have seen automatic\n| deep copy implemented via code generation in C++.\n\n  I'm sorry, but you have been tricked.  just because it exists for C++ is\n  not in any way, shape, or form an argument for the _correctness_ of the\n  implementation or the algorithm or even the concept to begin with.\n\n| I'm pretty new at lisp; however, so I'm not sure what language-specific\n| pitfalls I will encounter yet.\n\n  you encountered a language-specific pitfall and fell headlong into it\n  when you believed that C++ had an automatic solution.  you will get out\n  of this sorry state of affairs when you realize that such automated tools\n  are not able to do their job.  the key to understand this is that even in\n  a class for which \"deep copy\" makes non-zero sense, you don't _always_\n  want to deep copy _everything_, and if you fail to implement it right,\n  you will in fact destroy valuable information in the copying process.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3164355240918791@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-10",
          "display_date": "04/10/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/10\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164355240918791@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| Never had that happen is all of 3 years using the code generator that I\n| had, which would, in fact, copy wildly crazy and cyclic graphs of objects\n| perfectly correctly.\n\n  that's a ridiculously bold statement.  how do you _know_?  would you even\n  have _seen_ an error if it occurred?\n\n| Furthermore, if you look into the world of object oriented databases,\n| you'll find that various oodbs also do this perfectly well.\n\n  they do it by restricting the domain to fit what they implement, but it\n  fits the C++ mind-set to think this way and take it for granted that\n  others will understand that \"of _course_ we don't do the hard stuff\".  in\n  this newsgroup and in Lisp, the trivial problems are uninspiring, and so\n  we tend to think in broader terms.  this means that arbitrary limits are\n  regarded as cheating, unless yo present the limited domain up front as\n  inherent engineering decisions.  did you do that?  no.  foo on you for\n  that.\n\n| Perhaps we're having a definition of terms problem?\n\n  yes, you come from the C++ world.  C++ people are extremely arrogant the\n  way they think they invented object-orientedness.  they didn't, OK?  C++\n  doesn't even touch upon the really hard areas.  you have to face this\n  fact, or you'll make more ridiculously bold statements that reflect very\n  badly on your ability to deal with complexity.\n\n| I can't write a specific graph copier, because I don't have a- priori\n| knowledge of the structure of the objects that I will be copying.\n\n  at issue is knowing the _intent_ of the slots, not which they are.  in\n  Common Lisp we have the MOP to ask for the structure of the objects.\n  piece of cake, really.  just like databases can report on such things.\n  it doesn't help one bit in deciding whether to make a shallow or deep\n  copy, though.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3164355492179483@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-10",
          "display_date": "04/10/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/10\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164355492179483@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| A tip for some of you folks: one of the keys to successful\n| communication is not to assume that the other person is wrong,\n| but rather to figure out what they're right *for*.\n \n  do you follow this tip yourself?  if so, how come you don't listen?\n  it seems to me you're telling us we're wrong because you have \"seen\"\n  something you believe is sufficient when it isn't.\n\n  a tip for tippers: follow them yourself first, to _show_ how they work\n  well for you.  if not, just shut up about the tips.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3164356890914970@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-10",
          "display_date": "04/10/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/10\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164356890914970@naggum.no>\n\n* Philip Lijnzaad <lijnzaad@ebi.ac.uk>\n| On 09 Apr 2000 17:48:09 +0000, \n| \"Erik\" == Erik Naggum <erik@naggum.no> writes:\n| \n| Erik> implementing a mechanism that avoids descending into cyclic structures is\n| Erik> amazingly easy.  \n| \n| if slightly non-obvious at first. For those confused, you have two parts of\n| your function step through the elements of a list, one going in single steps,\n| the other in steps of two. If they ever end up in the same element, the list\n| must have been circular.\n| \n| Erik> detection is easy with the rabbit and the hare algorithm.\n| \n| Is this an optimized version of the tortoise and the hare algorithm? \n\n  yes (my silly mistake).  you just described it in the above paragraph, so\n  you must know it under a different name, but the key is to realize that\n  it only _detects_ a circularity, after it has happened -- there is no\n  guarantee that you find the first such element.\n\n#;Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3164446697303504@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-11",
          "display_date": "04/11/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/11\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164446697303504@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| I mentioned the possibility of restrictions in my second message\n| in this very thread. Did you read it? No. Foo on you for that.\n\n  this is just great.  of course I did that, and that's _why_ I criticize\n  you for not doing it UP FRONT.  perhaps you do ont know what \"UP FRONT\"\n  means?  well, it means you do it at the very start of your request for\n  help.  sort of like \"I use XLISP, and have this problem\" instead of just\n  asking people to guess based on the lack of intelligibility of the\n  problem as stated in the environments smart people use.\n\n  please go back to C++, both communities would benefit from that.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3164550783316675@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-12",
          "display_date": "04/12/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/12\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164550783316675@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| Yes, it does.  Some of us do, in fact, work on real problems which need\n| solving.  Theoretical constraints are interesting and valuable to know,\n| but the project moves on.\n\n  just because you cannot fathom the theoretical implications of your\n  questions does not mean that those who do don't solve practical problems.\n  think about this.  please.\n\n  and, incidentally, if I have \"made\" you feel like an idiot, why not just\n  do something that would put such impressions to _shame_ instead of going\n  out of your way to _prove_ that you really _are_ hopelessly lost?\n\n| I suspect that you need to look inward and not outward to solve the\n| problem that you need to work on. Usenet won't offer your ego what it's\n| looking for, no matter how hard you look for it.\n\n  I'm sure you and your shrink have worked something out that works for you\n  (although by the looks of it, you have some ways to go), but just like he\n  or she should have told you that you shouldn't give other people your\n  medication, you also shouldn't believe that your personal problems apply\n  to other people.\n\n  but I'll give you this: you are indeed courageous.  I know of few other\n  people who would expose themselves the way you do.  here's a hint: you\n  really don't need to -- nobody cares about _you_, personally, and it's an\n  affront to your audience, _any_ audience, to think they do.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3164522187493376@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-12",
          "display_date": "04/12/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/12\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164522187493376@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| It doesn't matter.  I have a practical problem to solve, here.\n\n  thank you.  I think this sums up your position admirably.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3164643995219305@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-13",
          "display_date": "04/13/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/13\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164643995219305@naggum.no>\n\n* Tim Moore <moore@herschel.bricoworks.com>\n| Topics such as \"How do I do a deep copy in Lisp?\" cause blood pressures\n| to rise because Lispers know it's impossible, but that's because the\n| language is much richer and exposes one to situations where deep copy is\n| in fact quite hard if not impossible.\n\n  you're missing the point, as one would expect from a bystander.  it isn't\n  the _topic_ that cause any problems.  it's the dimwits who come here and\n  ask for advice, and resoundingly _reject_ the advice they get from\n  well-meaning, highly educated people who try to teach pigs to sing, which\n  we know wastes your time and annoys the pig (witness the \"practical\" line\n  that just _had_ to come our way) only they don't know the dimwits they\n  try to help _are_ pigs until after a while, and then they get annoyed\n  when the pig turns out to be severely limited in learning _ability_, too.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3164632179269337@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-13",
          "display_date": "04/13/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/13\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164632179269337@naggum.no>\n\n* tom__98@my-deja.com\n| Unlike equality, where it matters if you compare too much, for the\n| semantics of a deep copy, it doesn't matter if you copy too much--it will\n| simply be inefficient.\n\n  when object identity matters, copying too much is destroying information.\n  such destruction can lead to very serious errors that are impossible to\n  trace after the fact.  if you don't get it right, you're hosed.  if you\n  don't even recognize that you can get this wrong, you're hosed a priori.\n  such is the tragic case for that hack we've been trying to teach there's\n  more to life than his C++ wonderworld.\n\n  (do we really _need_ to educate people at this level in this newsgroup?)\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3164649925932789@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-13",
          "display_date": "04/13/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/13\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164649925932789@naggum.no>\n\n* Tim Moore <moore@herschel.bricoworks.com>\n| Pigs are highly intelligent.\n\n  pardon me for elaborating on a saying.  speaking of which, this must be a\n  regional thing -- in some parts of the English-speaking world, people\n  tend to use idioms almost constantly, but do not reflect on them at all,\n  which makes them into a mere set of ersatz vocabulary, while in other\n  parts of the English-speaking world, puns and elaborations and mixing and\n  matching idioms and expressions to travel between many layers of meaning\n  is considered natural.  I tend to be puzzled when I meet people who don't\n  reflect on their language, because it's hard to tell which part of the\n  many meanings they got and which they completely missed out on.\n\n| In any event, who cares if the recipient isn't receptive?\n\n  you do, when you take the role of a bystander and raise the discussion to\n  a meta-level.  others do, when they are in middle of the discussion that\n  started it all.  many find it very annoying to see recurring dimwits fail\n  to get over a personal hangup or their desperately trying to recover\n  something they are the only ones to remember they lost.\n\n  newsgroup volume is a measure of discontent.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3164646548558686@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-13",
          "display_date": "04/13/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/13\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164646548558686@naggum.no>\n\n* Tom Breton <tob@world.std.com>\n| Apparently he can't.\n\n  Microsoft hired Ralph Reed of Christian Coalition fame as their lobbyist\n  in Washington to get George Dubya to be favorable to their antitrust\n  lawsuit.  this was widely considered a serious mistake, especially after\n  the New York Times uncovered it.\n\n  I haven't hired Tom Breton as my spokesman or lobbyist, but it would be\n  the same kind of mistake if I had.\n\n  so, can _you_ stop, Tom?  but we know the answer: \"apparently he can't\".\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3164610602078761@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-13",
          "display_date": "04/13/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/13\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164610602078761@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| Take a step back.\n\n  let me know when your advice has worked for you.  make an effort to show\n  that you can listen to anything but your own voice while you're at it.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3164603059346977@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-13",
          "display_date": "04/13/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/13\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164603059346977@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| You just can't stop, can you Erik?\n\n  if I can stop you, that's good enough for me, because I don't start the\n  kind of insane drivel you seem to enjoy starting.  but have you asked\n  yourself your own question, lately?  I don't appreciate your line of\n  psychologizing crap, but now that you get it back in your face, I see\n  that you are a lot more sensitive to the matter than I am, which is good,\n  because you may realize that if you plan to win any games that way, you\n  won't do it here, and you're clearly the kind of moron who needs to be\n  hurt to stop to think.  will _that_ make you stick to your issues,\n  whatever they may be, or will you smear more of your personality all over\n  the place with yet more moronic psychologizing and irrelevant personal\n  attacks?  it's your call, \"Courageous\".\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3164713468970761@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-14",
          "display_date": "04/14/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/14\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164713468970761@naggum.no>\n\n* Fernando <spamers@must.die>\n| Just like the proliferation of parens, he may be a minor annoyance to\n| newbies, but fortunately, parens stop annoying you in a week, and as soon\n| as you plonk him, he'll stop annoying you. ;-)\n\n  but how long before the obsessed stalkers stop annoying the newsgroup?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3164777262564002@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-15",
          "display_date": "04/15/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/15\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164777262564002@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| However, it's funny. At my place of work, I'm the one all the newbies\n| come to for answers, because I understand ...\n\n  I'm sure you think you're the hero of your work-place, but it doesn't\n  help just to _tell_ people when you have done so much damage to your\n  public impression as you have, and as a line of self-defense, it's so\n  pathetic it stinks.  _anyone_ could write a self-serving self-appraisal.\n  that's why people _don't_ write such personal defenses on the Net -- it's\n  self-defeating and on top of it, it's embarrassing when those \"newbies\"\n  who came to you for answers ask you something you don't know and search\n  for the answer on the Net, only to find that you don't have a clue in\n  some very important areas and are incredibly self-defensive and personal\n  about it.  to really top it off, you haven't understood _any_ of the many\n  very good explanations you have received to your question.  such arrogant\n  ignorance is a very questionable quality in an employee who doles out\n  answers to helpless \"newbies\" in an organization.  so you should start to\n  worry about yourself, and much less about others: if you can't take care\n  of yourself, you certainly are in no position to give advice to others.\n\n| More rhetorically, I wonder if the people over at Franz will be \"morons\"\n| if they attempt to implement the Objects By Value section of the CORBA\n| standard in their ORBLink product?\n\n  why do you want to hurt yourself so much?  you didn't have to _prove_\n  that you still have not understood the difference between implementing a\n  carefully constrained specification of a protocol and _general_ deep\n  copier, did you?  normal people don't insist on making the same mistake\n  over and over just because they don't like being called morons when they\n  do and continue with it until they are no longer called morons (it works\n  the other way around, in case you wonder).  the people over at Franz have\n  understood this difference long ago (like at _least_ 15 years ago), and\n  are in no danger at all of being called morons.  and in case you wonder\n  about more things, smart people who don't defend themselves can disagree\n  violently without even the hint of a danger of getting personal, so even\n  if implementing CORBA _were_ a really moronic thing to do, that itself\n  doesn't mean someone who does it is a moron.  it's the getting _personal_\n  that is the first hint of someone being a moron.  you have never quit\n  giving that hint, on the contrary: you have reinforced it over and over,\n  and this is a pretty strong argument that it is a correct assessment of\n  your mental acuity and childish, retarded stubbornness.  you can change\n  this by snapping out of your \"personal\" mental state and realize that\n  your ego is not under attack from anyone other than your own imagination.\n  most everyone here will utter a sigh of relief if you get the idea, and\n  nobody will ever \"remind\" you of your past mistake when you have learned\n  -- that's what makes possibly heated technical discussions _impersonal_\n  to people who aren't morons.\n\n  I'm _expecting_ another knee-jerk moronic response.  surprise me.  (of\n  course, now that I said that, your childish stubbornness prohibits you\n  from showing any trace of adult, smart behavior, but try, anyway.)\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3164898799599994@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-16",
          "display_date": "04/16/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/16\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164898799599994@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| You're complaining about *me* making matters personal.\n| Oh, that's rich. Between the two of us, who's posting\n| page-long diatribes sometimes filled with profanity?\n\n  well, here's the clue: _you_ take it personally.  _you_ cannot even\n  imagine that it _isn't_ personal, but that's _your_ choice.  you don't\n  have to make this choice.  so make another choice if you aren't satisfied\n  with it.  if you _are_ satisfied with your choice, and still complain,\n  you do in fact merit the personal insults and the label \"moron\" and much,\n  much more and much, much worse assessments of your mental state.\n\n| Says he who fills up pages with insults & profanity...\n\n  obviously, _you_ have a personal problem with what _you_ think is insults\n  and profanity because your wiener brain makes you see _nothing_ else if\n  this trigger is fired within you.  this is not somebody else's problem.\n  so just _deal_ with it if you don't like its consequences for you.\n\n  I take it that you are happy with your choice to take negative comments\n  personally and as destructively for yourself as possible, and so want\n  others to stop making negative comments that you could take personally.\n  face that facts, moron: that's not going to happen when you post as much\n  evidence of stupidity as you do.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3164940726622243@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-17",
          "display_date": "04/17/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/17\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164940726622243@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| You mean like when you say things like \"fucking retarded\" and\n| moronic and ah \"wiener brain\", and so on?\n\n  for once a personal comment: I pity you.  such insecurity as you suffer\n  from should have been protected from public exposure and treated with\n  love and professional care.  a clue: you won't get that here.\n\n  here's a another clue: you care what I think about you, but I don't think\n  about you -- only your moronic actions bother me.  how could I possibly\n  respond to anything else?  oh, forget that, I'm asking the one person\n  here who is unable to distinguish the actions from the person acting.\n  \n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3164984947664175@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-17",
          "display_date": "04/17/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/17\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164984947664175@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| You just can't stop, can you, Erik?\n\n  interestingly, this started with a general deep copier and the first\n  thing I told you about was detection of circularities.  I detect with\n  some satisfaction that you walk around in very small circles and ask the\n  same moronic questions over and over.  when will you realize it?\n\n  but now is the time we will learn whether you stop or prove again that\n  you are obsessing like the other morons who have visited this newsgroup.\n\n  since day 1, I have told you this: try some non-moronic behavior if you\n  want people to think differently about you.  this is obviously impossible\n  for you to fathom, and instead keep acting the moron because you want\n  others to stop calling you a moron before you change your moronic ways.\n\n  but sure, I can stop _calling_ you a moron, but that won't change you.\n  after all is said and done, I have said \"moron\", and you _are_ a moron.\n  is this really going to help you, you pitiful \"Courageous\" moron?\n\n  now, repeat another question for you own amusement.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3165044217260009@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-18",
          "display_date": "04/18/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/18\nNewsgroups: comp.lang.lisp\nMessage-ID: <3165044217260009@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| This isn't going to compensate for it, you know.\n\n  I said I was going to stop calling you a \"moron\".  YOUR WISH HAS BEEN\n  GRANTED!  so why do you continue with the same behavior that caused the\n  label you do not want attached yourself?  we have already established\n  that the best you think you can do in a debate is to count words, for\n  instance.  do as you were told to in the very beginning: try something\n  better, or face the consequences: people will _know_ you can't do better.\n\n  this is not going to stop until you start to behave smart.  this may take\n  a while, but the only goal I have with someone like you in this newsgroup\n  is to make them stop acting in certain ways.  if you are impervious to\n  any sort of outside signal to improve your behavior, it doesn't help what\n  I say or not -- it may in fact hurt you that I don't state my conclusion.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3165123380936230@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-19",
          "display_date": "04/19/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/19\nNewsgroups: comp.lang.lisp\nMessage-ID: <3165123380936230@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| One simply ceases.\n\n  I'm waiting for you to stop behaving in a way that needs correction.\n\n  as you have so succinctly stated, \"you can't stop, can you, Joe Kraska\"?\n  I think we have all the proof we need.  it's up to you.  in fact, it has\n  been up to you for a very long time, but your insistence on proving your\n  case has been a barrier to progress.  I draw my conclusions, but I have\n  promised to stop stating them, so won't.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3165302496305278@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-21",
          "display_date": "04/21/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/21\nNewsgroups: comp.lang.lisp\nMessage-ID: <3165302496305278@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| One of the hallmark signs of an abuser is blaming the victim.\n\n  the hallmark of a loser is one who has thoughts of \"blame\" and \"victim\"\n  and \"abuser\" and all that shit and who seems himself in one particular\n  role relative to others.  snap out of it!\n\n  no one is blaming you for anything.  you are simply being told that your\n  actions have certain consequences.  you seem to subscribe to this view,\n  yet refuse to apply it to yourself.  I find this highly indicative of\n  what I have concluded about you.  you have been told that if you don't\n  want the consequences, you should change the actions.  you refuse to\n  change your pattern of being a hapless victim and go on and on and on\n  about everything bad happening to you being my fault.  you victimize\n  _yourself_ and work very hard to _remove_ responsibility from yourself.\n  such is the hallmark of a loser without hope of recovery, but I think\n  that has been the fairly well established pattern from you already.\n\n  the problem with you is you can't stop feeling the victim, even when it's\n  clear that you're running after _me_ with your unceasing desire to blame\n  me for your _personal_ problems.  I'm not responsible for your reactions.\n  you have to accept responsibility for your own _part_ in everything that\n  happens to you and not try to shift it to somebody else.  doing so is,\n  indeed, highly indicative of what I have already concluded about you.\n\n  the big test is whether you get over this.  so far, you have not, and\n  neither has Tom Breton and a few other \"victims\".  they have another\n  thing in common: all been very seriously mistaken in some particular\n  area.  I find it very interesting that being persistently wrong about\n  something causes _some_ people to fall into the \"victim\" trap (in their\n  own mind) and never get out of it, while those who want to understand\n  accept technical counter-information the first time it is presented and\n  _learn_ from it.  people who refuse to learn, however, fall into another\n  category which is unlikely to be respected for much, and even less when\n  they start to blame others and use \"I'm a victim!\" language.\n\n  I now understand why you need to _call_ yourself \"Courageous\".\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3165322206168072@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-21",
          "display_date": "04/21/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/21\nNewsgroups: comp.lang.lisp\nMessage-ID: <3165322206168072@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n\n  while you continue your abuse, I'm waiting for your message-ID with the\n  favorite quoted text of yours which you attribute to me.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3165321443490104@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-21",
          "display_date": "04/21/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/21\nNewsgroups: comp.lang.lisp\nMessage-ID: <3165321443490104@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| Oh, and let's not forget my favorite:\n| \n| ... who deserves to be hurt.\n| \n| Very revealing that one, especially.\n| \n| You say I am an abuser? Say again?\n\n  since this one is so important to you and so important not to _forget_,\n  could you be bothered to actually locate it among what I have said to\n  you?  a message-ID will be very helpful.  a URL at deja.com will work.\n\n  if you find that I have NOT actually said that, you will admit to be a\n  moron, a liar, and a disgusting creep who is out to misrepresent others\n  in such a way as to make others look bad when in fact you are a piece of\n  reeking, self-victimizing crap yourself.\n\n  if you do find that I HAVE actually said that, I'll admit to being a\n  psychopathic abuser who has actually been out to destroy your sterling\n  reputation as a genius within BBN for no good reason.\n\n  do we have a deal, Joe \"Courageous\" Kraska?\n\n  I believe \"very revealing\" are extremely interesting words from our\n  supposed \"victim\".  the psychology of most victims is that the world\n  consists of abusers and victims, and if you aren't a victim, you are an\n  abuser.  the _fact_, however, is that every abuser is a victim and every\n  victim is an abuser.  the question is towards and with whom they have\n  their respective roles.  those who do not subscribe to this set of roles,\n  are actually neither abusers _nor_ victims.\n\n  so, what will your search _reveal_, Joe \"Victim\" Kraska?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3165384579368198@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-22",
          "display_date": "04/22/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/22\nNewsgroups: comp.lang.lisp\nMessage-ID: <3165384579368198@naggum.no>\n\n* Tom Breton <tob@world.std.com>\n| I had to tell him very basic stuff about optimization.\n\n  you still haven't read what I have written about optimization, and you\n  repeat the same idiotic comments that were proven wrong by others, but\n  pretend that I'm the only one who doesn't \"agree\" with you.  the fact is,\n  however, that _nobody_ agrees with you, but you, like any moron deserving\n  the label, decided in your own sick, demented mind, that I'm to blame for\n  your lack of brains.  this is just as brilliant as your incredibly stupid\n  ideas about optimization.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        },
        {
          "id": "3165414841017864@naggum.no",
          "subject": "Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-22",
          "display_date": "04/22/2000",
          "content": "\nSubject: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/22\nNewsgroups: comp.lang.lisp\nMessage-ID: <3165414841017864@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| Oh, and let's not forget my favorite:\n| \n| ... who NEEDS to be hurt.\n| \n| Very revealing that one, especially.\n| \n| You say I am an abuser? Say again?\n\n  others have pointed out that you're the abuser.  I'm gleefully picking up\n  on that, of course, as they are in fact right, but you would never listen\n  to them if I said it first.  I'm happy you're defensive about it, though.\n\n  incidentally, but mostly for the search engines: the full quote is \"you\n  are the kind of moron who needs to be hurt to stop to think\", Joe Kraska.\n  our society punishes destructive morons who have no respect for others.\n  if you are so retarded that you _still_ cannot fathom that this is very\n  different from your nightmarish imagination of what it is, you're also\n  clinically psychotic and probably _unable_ to distinguish reality from\n  your sick imagination.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "deep_copy_in_lisp:_how?"
        }
      ],
      "post_count": 26,
      "first_post_date": "2000-04-09",
      "last_post_date": "2000-04-22"
    },
    {
      "id": "[specialized_arrays]_which_lisp_has_them?",
      "title": "[specialized arrays] which lisp has them?",
      "posts": [
        {
          "id": "3165302816800445@naggum.no",
          "subject": "Re: [specialized arrays] which lisp has them?",
          "author_id": "erik_naggum",
          "date": "2000-04-21",
          "display_date": "04/21/2000",
          "content": "\nSubject: Re: [specialized arrays] which lisp has them?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/21\nNewsgroups: comp.lang.lisp\nMessage-ID: <3165302816800445@naggum.no>\n\n* Tunc Simsek <simsek@tudor.EECS.Berkeley.EDU>\n| This is important because the recent tool matlisp relies on (simple-array\n| double-float (*)) and that the array must have C doubles contiguous in\n| memory.\n\n  could you explain why you rely on such low-level representational issues?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[specialized_arrays]_which_lisp_has_them?"
        },
        {
          "id": "3165409740471698@naggum.no",
          "subject": "Re: [specialized arrays] which lisp has them?",
          "author_id": "erik_naggum",
          "date": "2000-04-22",
          "display_date": "04/22/2000",
          "content": "\nSubject: Re: [specialized arrays] which lisp has them?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/22\nNewsgroups: comp.lang.lisp\nMessage-ID: <3165409740471698@naggum.no>\n\n* \"Sunil Mishra\" <smishra@arslogica.com>\n| I remember reading the announcement for matlisp. Apparently it provides OO\n| facilities for working with matrices using the BLAS and LAPACK libraries,\n| high performance matrix algebra libraries orginally written in Fortran.\n| Therefore the requirements.\n\n  well, from that follows the requirements _in the FFI_, but not the native\n  representation.  I see no reason whatsoever to require the native Common\n  Lisp system to represent arrays or matrices like this, but it is obvious\n  that the ability to access arrays or matrices represented like this from\n  Common Lisp when they were declared/created/whatever from or in the FFI,\n  is a requirement of the system as a whole.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[specialized_arrays]_which_lisp_has_them?"
        }
      ],
      "post_count": 2,
      "first_post_date": "2000-04-21",
      "last_post_date": "2000-04-22"
    },
    {
      "id": "on_the_quality_of_this_newsgroup,_was:_re:_deep_co",
      "title": "On the quality of this newsgroup, was: Re: Deep copy in lisp: how?",
      "posts": [
        {
          "id": "3164963670328673@naggum.no",
          "subject": "Re: On the quality of this newsgroup, was: Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-17",
          "display_date": "04/17/2000",
          "content": "\nSubject: Re: On the quality of this newsgroup, was: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/17\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164963670328673@naggum.no>\n\n* Ian Upright <ian@oneaccordinc.com>\n| As a Smalltalker who doesn't read this newsgroup very often, I was quite\n| irritated by Mr. Naggum's absurd and highly inflamitory opinions.\n\n  I'm glad you agree that being quite irritated at other people's absurd\n  and highly inflammatory opinions is perfectly acceptable.\n\n| Are all Lisper's f***ing belligerent ass*****?  ;-)\n\n  no, but all visiting smalltalkers might perhaps be, based on the usual\n  sample of one to support generalizations.  smiley or no smiley, such\n  flaws in methodology or complete lack of methodological thinking is at\n  the core of my criticism.  people who lack the ability, or who have never\n  been trained, to think methodologically, make mistakes that nothing short\n  of fixing their methodology can change.  most intelligent people pick up\n  on this relatively fast when required to.  morons think they have a right\n  to make even less methodolically sound claims when criticized.\n\n| I still don't understand what the problem is.\n\n  well, that's odd, since you illustrated it well when you took it for\n  granted that certain object types in Smalltalk are simply not copied.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "on_the_quality_of_this_newsgroup,_was:_re:_deep_co"
        },
        {
          "id": "3165044910752775@naggum.no",
          "subject": "Re: On the quality of this newsgroup, was: Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-18",
          "display_date": "04/18/2000",
          "content": "\nSubject: Re: On the quality of this newsgroup, was: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/18\nNewsgroups: comp.lang.lisp\nMessage-ID: <3165044910752775@naggum.no>\n\n* Jon S Anthony <jsa@synquiry.com>\n| The amazing thing about this whole discussion is that this should be even\n| a remotely interesting point, let alone one capable of generating all\n| this irrelevant heat.\n\n  not at all.  some people will forever refuse to listen to the truth, if a\n  notion they have is from a source regarded as somehow \"superior\" to those\n  they would have to listen to to hear the truth.  these are non-technical\n  people, incapable of dealing with technical issues without dealing with\n  people, in the shape of trusting other people's conclusions before they\n  think on their own.  what other people say to such people is immensely\n  important to them, but you have to be the right person to say the right\n  thing before they will accept it.  refusing to think in this particular\n  way is always a source of heat, because to the people who do not want to\n  listen to the truth, it's a people issue, not a technical issue at all,\n  and to those who want to explain the truth, it never could be a people\n  issue to begin with.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "on_the_quality_of_this_newsgroup,_was:_re:_deep_co"
        },
        {
          "id": "3165123882306994@naggum.no",
          "subject": "Re: On the quality of this newsgroup, was: Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-19",
          "display_date": "04/19/2000",
          "content": "\nSubject: Re: On the quality of this newsgroup, was: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/19\nNewsgroups: comp.lang.lisp\nMessage-ID: <3165123882306994@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| Life's not like that, Erik.\n\n  we're not talking about your _life_ here.  grow a clue, now.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "on_the_quality_of_this_newsgroup,_was:_re:_deep_co"
        },
        {
          "id": "3165302603471097@naggum.no",
          "subject": "Re: On the quality of this newsgroup, was: Re: Deep copy in lisp: how?",
          "author_id": "erik_naggum",
          "date": "2000-04-21",
          "display_date": "04/21/2000",
          "content": "\nSubject: Re: On the quality of this newsgroup, was: Re: Deep copy in lisp: how?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/21\nNewsgroups: comp.lang.lisp\nMessage-ID: <3165302603471097@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| No, Erik. It's life in general.\n\n  a loser victim explains \"life in general\"...\n\n  why should I take _your_ word for it, of all the people I could listen to?\n\n  feel free to live your loser victim life, Joe Kraska.  keep me out of it.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "on_the_quality_of_this_newsgroup,_was:_re:_deep_co"
        }
      ],
      "post_count": 4,
      "first_post_date": "2000-04-17",
      "last_post_date": "2000-04-21"
    },
    {
      "id": "how_does_lisp_implement_primitive,_structured_and_",
      "title": "How does Lisp implement Primitive, Structured and User-defined data  types?",
      "posts": [
        {
          "id": "3165125538003989@naggum.no",
          "subject": "Re: How does Lisp implement Primitive, Structured and User-defined data  types?",
          "author_id": "erik_naggum",
          "date": "2000-04-19",
          "display_date": "04/19/2000",
          "content": "\nSubject: Re: How does Lisp implement Primitive, Structured and User-defined data  types?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/19\nNewsgroups: comp.lang.lisp\nMessage-ID: <3165125538003989@naggum.no>\n\n* Lisp Researcher\n| I am doing a research on Lisp and I need to know...\n\n* Courageous <jkraska1@san.rr.com>\n| I suggest you get a copy of the ANSI Common Lisp\n| standards document.\n\n  sigh.  this is a genuinely bad idea for the answers to the questions\n  asked, which have to do with implementation of the language, not the\n  specification of the semantics of the language.  anyone who has _read_\n  the standard knows that it doesn't answer any of the questions.\n\n  the answer is obviously to call up a Lisp vendor and ask a technical\n  person for some pointers.  I don't think the question merits response\n  beyond that, mainly because I don't want people who have zero clue to\n  start doing research on anything.  acquire clue, _then_ do research.\n  otherwise, you ask clueless questions, get clueless answers from people\n  who have even less clue than you do, and don't recognize the problems\n  inherent in trusting the Net.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "how_does_lisp_implement_primitive,_structured_and_"
        },
        {
          "id": "3165303464872531@naggum.no",
          "subject": "Re: How does Lisp implement Primitive, Structured and User-defined data   types?",
          "author_id": "erik_naggum",
          "date": "2000-04-21",
          "display_date": "04/21/2000",
          "content": "\nSubject: Re: How does Lisp implement Primitive, Structured and User-defined data   types?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/21\nNewsgroups: comp.lang.lisp\nMessage-ID: <3165303464872531@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| That's the point: once you've read the standard, you'll realize that for\n| *Lisp*, there is no answer.  Only a particular vendors solution.  But\n| that isn't Lisp, now, is it?\n\n  I'm disappointed.  I was waiting for a \"Lisp is not like that, Erik\".\n\n  I must assume from past experience that you won't ever understand that\n  giving somebody the standard is not an answer to implementation issues,\n  but will now proceed to call yourself \"victim\" and me \"abuser\" for\n  pointing this out to you, and _blame_ me for your lack of understanding.\n\n  instead of _actually_ going down that route, I'll just summarize it for\n  us all: Joe Kraska will never relinquish the genuinely bad idea of giving\n  someone the whole standard when they ask for _common_ implementations of\n  certain aspects of Common Lisp, but will forever think his was a highly\n  meritorious suggestion which was undeservedly bashed.  it is still wrong.\n\n  now, refrain from following up, Joe Kraska.  we know what you will say.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "how_does_lisp_implement_primitive,_structured_and_"
        }
      ],
      "post_count": 2,
      "first_post_date": "2000-04-19",
      "last_post_date": "2000-04-21"
    },
    {
      "id": "getting_a_full_symbol_name",
      "title": "getting a full symbol name",
      "posts": [
        {
          "id": "3165125191606936@naggum.no",
          "subject": "Re: getting a full symbol name",
          "author_id": "erik_naggum",
          "date": "2000-04-19",
          "display_date": "04/19/2000",
          "content": "\nSubject: Re: getting a full symbol name\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/19\nNewsgroups: comp.lang.lisp\nMessage-ID: <3165125191606936@naggum.no>\n\n* \"Marc Battyani\" <Marc_Battyani@csi.com>\n| what is the easiest way to get a full symbol name ie \"package::name\"?\n\n(let ((*package* (find-package :keyword))\n  (write-to-string object :readably t)))\n\n| is there a format directive for this?\n\n(defun fqsn (stream object colon-p atsign-p &rest format-args)\n  (declare (ignore colon-p atsign-p format-args))\n  (let ((*package* (find-package :keyword))\n    (write object :stream stream :readably t))))\n\n  now there is.  fqsn stands for fully qualified symbol name.\n\n(format nil \"~/fqsn/\" <symbol>)\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "getting_a_full_symbol_name"
        },
        {
          "id": "3165124054834383@naggum.no",
          "subject": "Re: getting a full symbol name",
          "author_id": "erik_naggum",
          "date": "2000-04-19",
          "display_date": "04/19/2000",
          "content": "\nSubject: Re: getting a full symbol name\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/19\nNewsgroups: comp.lang.lisp\nMessage-ID: <3165124054834383@naggum.no>\n\n* Barry Margolin <barmar@genuity.net>\n| If you bind *PACKAGE* to NIL, ...\n\n  ... you are violating a system-wide invariant.  just don't do it.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "getting_a_full_symbol_name"
        },
        {
          "id": "3165303001598092@naggum.no",
          "subject": "Re: getting a full symbol name",
          "author_id": "erik_naggum",
          "date": "2000-04-21",
          "display_date": "04/21/2000",
          "content": "\nSubject: Re: getting a full symbol name\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/21\nNewsgroups: comp.lang.lisp\nMessage-ID: <3165303001598092@naggum.no>\n\n* Gareth McCaughan <Gareth.McCaughan@pobox.com>\n| Very elegant, but it doesn't work if the symbol you're passed is actually\n| a keyword!\n\n  yes, it does.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "getting_a_full_symbol_name"
        }
      ],
      "post_count": 3,
      "first_post_date": "2000-04-19",
      "last_post_date": "2000-04-21"
    },
    {
      "id": "how_to_validate_input?",
      "title": "how to validate input?",
      "posts": [
        {
          "id": "3165126075587849@naggum.no",
          "subject": "Re: how to validate input?",
          "author_id": "erik_naggum",
          "date": "2000-04-19",
          "display_date": "04/19/2000",
          "content": "\nSubject: Re: how to validate input?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/19\nNewsgroups: comp.lang.lisp\nMessage-ID: <3165126075587849@naggum.no>\n\n* Friedrich Dominicus <Friedrich.Dominicus@inka.de>\n| I have written the same with a loop but it looks IMO more ugly.\n\n  it's quite strange, but people who have been trained to write iteration\n  using tail recursion tend to write the most amazingly ugly loops, and it\n  isn't a question of lack of training in writing loops, it's conceptual.\n  (yet another case of Scheme hurting people.)\n\n| (defun get-input ()\n| (let ((line))\n|   (do ((exit nil))\n|       (exit line)\n|     (format t \"Please give me a number (e for Exit): \")\n|     (setf line (read))\n|     (if (numberp line)\n|         (progn \n|           (setf exit t)\n|           line)\n|       (when (y-or-n-p \"Not a number, really exit?\")\n|         (setf exit t)\n|         (setf line nil))))))\n\n(format t \"please enter a number: \")\n(do ((input (read nil nil nil) (read nil nil nil)))\n    ((or (null input) (numberp input)) input)\n  (format t \"not a number, try again: \"))\n\n  I'd use a different input function that read, but that's your call.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "how_to_validate_input?"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-04-19",
      "last_post_date": "2000-04-19"
    },
    {
      "id": "setf_&_setq_-_revisiting",
      "title": "setf & setq - revisiting",
      "posts": [
        {
          "id": "3164940958803214@naggum.no",
          "subject": "Re: setf & setq - revisiting",
          "author_id": "erik_naggum",
          "date": "2000-04-17",
          "display_date": "04/17/2000",
          "content": "\nSubject: Re: setf & setq - revisiting\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/17\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164940958803214@naggum.no>\n\n* ;; h e l m e r . . . <assemblage@my-deja.com>\n| i'm revisitng my initial question because i found something on a scheme\n| site that clarifies (i hope) and gives me very basic definitions,\n| probelm is, i have to make sure it's lisp too . . .\n\n  it isn't.  on top of it, it's completely bogus, because ...\n\n| [note i have taken these statements where sheme's 'define' = 'setf' in\n| lisp and similarly 'set!' = 'setq']\n\n  ... this is completely unfounded.\n\n  please forget comparing Scheme and Lisp for now, but feel free to try\n  again when you know both exceedingly well on their own merits.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "setf_&_setq_-_revisiting"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-04-17",
      "last_post_date": "2000-04-17"
    },
    {
      "id": "r:_newbie_question_about_symbols",
      "title": "R: newbie question about symbols",
      "posts": [
        {
          "id": "3164962988991097@naggum.no",
          "subject": "Re: R: newbie question about symbols",
          "author_id": "erik_naggum",
          "date": "2000-04-17",
          "display_date": "04/17/2000",
          "content": "\nSubject: Re: R: newbie question about symbols\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/17\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164962988991097@naggum.no>\n\n* \"Vanna\" <vgalaffu@tiscalinet.it>\n| we will try to explain more clearly what we would like to do:\n| we deal with a package where are defined some functions that receive some\n| symbols and compare these symbols with other internal symbols;\n\n  that's not what you would _like_ to do, it's exactly what you do, and as\n  an explanation, it's useless for those who want to help you.  what you\n  would like to do is, as a guess, to refer to symbols without a pacakge\n  because you have failed to understand the package system.  this is not\n  that uncommon, but insisting that the package system is broken is only\n  half as common.\n\n  instead of using symbols internal in a given package, use keywords.\n\n| (defparameter *somesymbols* '(FOO1 FOO2 FOO3))\n\n(defparameter *somesymbols* '(:FOO1 :FOO2 :FOO3))\n\n| (search-symbol 'FOO1)\n\n(search-symbol :FOO1)\n=> T\n\n| We are wondering why it is so difficult to deal with symbols defined in\n| different packages, we think that this problem is common to many other\n| Lisp users that want to take advantage of using different packages.\n\n  this arrogance has blocked your progress both in solving the problem and\n  in recognizing the difficulties you have experienced.  you have to let go\n  of the idea that you're doing something right if it doesn't work, and at\n  the very least investigate your options.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "r:_newbie_question_about_symbols"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-04-17",
      "last_post_date": "2000-04-17"
    },
    {
      "id": "loop_syntax",
      "title": "Loop Syntax",
      "posts": [
        {
          "id": "3164119940843690@naggum.no",
          "subject": "Re: Loop Syntax",
          "author_id": "erik_naggum",
          "date": "2000-04-07",
          "display_date": "04/07/2000",
          "content": "\nSubject: Re: Loop Syntax\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/07\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164119940843690@naggum.no>\n\n* \"Jeffrey P. Sandys\" <sandysj@asme.org>\n| Should loop keywords have the colon prefix keyword syntax?\n\n  a very good question.  only the symbol-name of the loop keywords are used\n  by the macro function, so you're free to use keyword symbols.  it might\n  look odd to some people, but I find serious merit in using a distinct\n  syntax for this as long as we can't use a more Lispy syntax to begin with.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "loop_syntax"
        },
        {
          "id": "3164399680432945@naggum.no",
          "subject": "Re: Loop Syntax",
          "author_id": "erik_naggum",
          "date": "2000-04-10",
          "display_date": "04/10/2000",
          "content": "\nSubject: Re: Loop Syntax\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/10\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164399680432945@naggum.no>\n\n* Tom Breton <tob@world.std.com>\n| Well, I don't seriously mean to tar everyone in cll ...\n\n  sure, but that's OK, Tom, you're only tarring yourself, anyway.\n\n  being wrong sometimes has the _unexplainable_ effect that other people\n  _continue_ to argue against you.  isn't that just too _weird_, Tom?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "loop_syntax"
        },
        {
          "id": "3164646276653331@naggum.no",
          "subject": "Re: Loop Syntax",
          "author_id": "erik_naggum",
          "date": "2000-04-13",
          "display_date": "04/13/2000",
          "content": "\nSubject: Re: Loop Syntax\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/13\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164646276653331@naggum.no>\n\n* Tom Breton <tob@world.std.com>\n| Sorry, Erik is absolutely not someone you want to cite on optimization.\n\n  I'm fascinated that you optimized your journey from ignorance to opinion\n  by removing the normally required task of _reading_ what you opine on.\n  this reflects on most of your other opinions on optimization, a least\n  with me, because I optimize away the incredibly unrewarding task of\n  trying to get past your personal hangups with people you don't agree\n  with, which you might learn a little bit about if you read what I have\n  written on _agreement_ as part of the process of argumentation, but it is\n  by now fairly obvious that you also  optimize away what other people call\n  \"learning experience\".\n\n  sigh.  just get over it, Tom.  I don't like being so important in some\n  dreadful morons' lives as I am in yours and this \"Courageous\" fellow.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "loop_syntax"
        },
        {
          "id": "3164660350780584@naggum.no",
          "subject": "Re: Loop Syntax",
          "author_id": "erik_naggum",
          "date": "2000-04-14",
          "display_date": "04/14/2000",
          "content": "\nSubject: Re: Loop Syntax\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/14\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164660350780584@naggum.no>\n\n* Erik Naggum\n| sigh.  just get over it, Tom.  I don't like being so important in some\n| dreadful morons' lives as I am in yours and this \"Courageous\" fellow.\n\n* Courageous <jkraska1@san.rr.com>\n| Given the long chains of invective, cursing, put downs, and outright\n| temper tantrums I've been subject to one both usenet and long personal\n| email messages -- and the apologetic email I've received from the group\n| explaining that you have an established tendancy to behave the way you do\n| (were you aware that people thought of you that way?)     ... *well*.\n\n  you missed the relevant part, of course.  _you_ make me important in\n  _your_ lives.  you don't have to, yet you complain bitterly when you do,\n  and you refuse to understand that it's your very own choice to do so.\n\n  when your have reached the point in your life when _you_ become important\n  to yourself the way I am to you now, you will thank me, in your own way.\n  until then, you will hate me, or something more or less indistinguishable\n  from hate.  _that_ is the established tendency.  of course, you won't\n  believe this now, but that's _why_ I'm important to you: you _need_ to be\n  preoccupied with me and you _need_ to continue to post so much insane\n  drivel about me from inside your _own_ psyche it will make you very, very\n  embarrassed when you realize what you've done, instead of the simple and\n  easy thing you _could_ do, but which _you_ only tell other people as a\n  piece of advice you'll never follow yourself: look inside yourself.\n  there's something inside you that makes me important to you.  find it!\n\n  understandably, however, you are right now at the point where the only\n  thing that matters to you is to keep enlightenment from occuring to you,\n  and the more you can preoccupy yourself with _me_, the less you will be\n  enlightened.  once you understand, fundamentally, emotionally, and fully\n  that spending any energy at all on other _people_ is a matter of choice\n  that reflects concern, personal bonding, and apprecation for something\n  you often do not understand when it happens, you will be prepared to let\n  go of _people_ and focus on _ideas_, which will enable you to concentrate\n  on those few people that _really_ matter to you, as you will know why.\n\n  however, I don't want anything to do with _you_, yet this very rejection\n  is what drives you like a madman to keep sending me mail that is also\n  rejected, keep replying to articles, keep _preoccupying_ yourself with\n  me.  I want you morons to shut up and _listen_, not to _me_, but to _any_\n  source of englightenment you can find that will cause you to grow up and\n  relieve me of the burden of having to reject your pathetic attempts to\n  ingratiate yourself with me.  it's not _about_ me, you morons, it's about\n  what I trigger _inside_ of you, whatever the hell it is -- I wish I knew,\n  because then maybe I could get a little _control_ over your sycophants,\n  like perhaps giving me all your money, but I'm joking, of course.\n\n  and if you found this nauseating enough to read that you stop stalking me\n  with your sniveling little \"please love me!\" messages, so much the better!\n  I shall appreciate it highly when you reach enlightenment, as interaction\n  between the enlightened is always such a pleasure, but until then, you're\n  nothing but an ignorent, annoying pest attracted to the nearest source of\n  light.  seek elsewhere, you moths-for-brains, but above all: seek!\n\n#:Erik\n-- \n  statistically, only 1 in 250 people understood anything in this message.\n\n",
          "references": [],
          "thread_id": "loop_syntax"
        },
        {
          "id": "3164692830791331@naggum.no",
          "subject": "Re: Loop Syntax",
          "author_id": "erik_naggum",
          "date": "2000-04-14",
          "display_date": "04/14/2000",
          "content": "\nSubject: Re: Loop Syntax\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/14\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164692830791331@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| Seeing another full page ego-fest of a dissertation, I would\n| wager that it's the other way around by a long shot. If you're\n| like this in real life, you need therapy.\n\n  ego-fest?  geez.  is there _nothing_ that can help you get out of your\n  sick preoccupation with _me_?  but who's surprised?  you didn't\n  understand _anything_ in that message, as was predicted therein.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "loop_syntax"
        },
        {
          "id": "3164778027675622@naggum.no",
          "subject": "Re: Loop Syntax",
          "author_id": "erik_naggum",
          "date": "2000-04-15",
          "display_date": "04/15/2000",
          "content": "\nSubject: Re: Loop Syntax\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/15\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164778027675622@naggum.no>\n\n* Courageous <jkraska1@san.rr.com>\n| Oh I understood what you *want* well enough, but life's simply not like\n| that.  When you behave the way you have, certain social consequences are\n| part of the natural order of things.  Contemplate it.\n\n  so you _do_ realize that!  but of course, it applies only to other people\n  and you're exempt from the rules that apply to other people, aren't you?\n\n  focus on _yourself_.  care about _yourself_.  let other people focus on\n  themselves and care about themselves.  get off the \"getting personal\"\n  track and focus on _your_ needs, discuss matters that matter to _you_,\n  and learn what you came to learn, if you _did_ come to learn anything\n  instead of merely posturing as a moron with an agenda.  by continuing to\n  taking this so _personally_ you display a personal insecurity that is\n  disgusting to behold and which is of no value to anyone to know about in\n  the first place.  \"contemplate it.\"\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "loop_syntax"
        }
      ],
      "post_count": 6,
      "first_post_date": "2000-04-07",
      "last_post_date": "2000-04-15"
    },
    {
      "id": "how_to_make_'(--a)_equals_'a",
      "title": "How To make '(--a) equals 'a",
      "posts": [
        {
          "id": "3164645518513769@naggum.no",
          "subject": "Re: How To make '(--a) equals 'a",
          "author_id": "erik_naggum",
          "date": "2000-04-13",
          "display_date": "04/13/2000",
          "content": "\nSubject: Re: How To make '(--a) equals 'a\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/13\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164645518513769@naggum.no>\n\n* David <tiand8@cs.man.ac.uk>\n| I am a beginner in Lisp. Recently I have been doing a programming\n| exercise in Lisp which is to build a test-tree using a so-called ID3\n| algorithm in A.I. one of the smaller tasks to solve this problem is to\n| make \"not not a\" (ie. '(--a) ) equals \"a\"; where \"a\" is any atom in\n| Lisp. This is trivial in Maths, but to make this equivalence work in Lisp\n| seems very tricky to me. My main difficulty is that I don't know how to\n| separate '(--a) into \"-\", \"-\" and \"a\". once I know how to do this the\n| problem is straight forward.\n\n  if you use a richer character set, you can use the ¬ operator (found in\n  ISO 8859-1, or \"ISO Latin 1\", also known among Microsoft victims as \"the\n  ANSI character set\"), and you can teach your Common Lisp reader to make\n  that a single-character operator that either returns itself or returns\n  the \"not\" operator already in the language, listifying its argument like\n  quote (') does.\n\n(defun not-reader (stream char)\n  (list 'not (read stream nil nil t)))\n\n(set-macro-character #\\¬ #'not-reader nil)\n\n'¬¬a\n=> (not (not a))\n\n  simplifying this expression can now be done at the semantic level, which\n  basically entails walking over your expressions looking for not forms and\n  replacing the form with the cadadr of the form.\n\n  the normal evaluation rules in Common Lisp makes (not (not a)) the\n  canonical true boolean value, t, for any non-nil a, and nil for nil.\n\n  don't know if this answered your question, it's kind of vague.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "how_to_make_'(--a)_equals_'a"
        },
        {
          "id": "3164729905914698@naggum.no",
          "subject": "Re: How To make '(--a) equals 'a",
          "author_id": "erik_naggum",
          "date": "2000-04-14",
          "display_date": "04/14/2000",
          "content": "\nSubject: Re: How To make '(--a) equals 'a\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/14\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164729905914698@naggum.no>\n\n* William Deakin <willd@pindar.com>\n| You are unduly harsh on vi, as there are sufficient problems with `Numerical\n| Recipies in C' that are total not vi related,\n\n  could \"Numerical Recipes in Common Lisp\" be an idea?  as far as I can see\n  from the code in the C version, about 40% of it is directly related to\n  managing object types that don't fall naturally into the C domain, and it\n  appears that the significant reduction in object management alone would\n  make a Common Lisp implementation of much if not all of this interesting.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "how_to_make_'(--a)_equals_'a"
        }
      ],
      "post_count": 2,
      "first_post_date": "2000-04-13",
      "last_post_date": "2000-04-14"
    },
    {
      "id": "allegrocl:_how_to_write_a_huge_list_in_one_line",
      "title": "AllegroCL: How to write a huge list in one line",
      "posts": [
        {
          "id": "3164396968656316@naggum.no",
          "subject": "Re: AllegroCL: How to write a huge list in one line",
          "author_id": "erik_naggum",
          "date": "2000-04-10",
          "display_date": "04/10/2000",
          "content": "\nSubject: Re: AllegroCL: How to write a huge list in one line\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/10\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164396968656316@naggum.no>\n\n* Unai Uribarri Rodriguez <zz99f029@opalo.etsiig.uniovi.es>\n| format splits the list into several lines.\n\n  format does what it's told to do, and it doesn't have free will (it only\n  feels like it until you learn its language), so you're blaming the wrong\n  guy, here.  so, what, _exactly_, were you telling format to do?\n\n| Is there any way to write a huge list to a file in an unique line?\n\n(format <stream> \"~{~A~^ ~}~%\" <huge-list>)\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "allegrocl:_how_to_write_a_huge_list_in_one_line"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-04-10",
      "last_post_date": "2000-04-10"
    },
    {
      "id": "list_problem_and_nth,_read,_strcat",
      "title": "list problem and NTH, READ, STRCAT",
      "posts": [
        {
          "id": "3164366538827789@naggum.no",
          "subject": "Re: list problem and NTH, READ, STRCAT",
          "author_id": "erik_naggum",
          "date": "2000-04-10",
          "display_date": "04/10/2000",
          "content": "\nSubject: Re: list problem and NTH, READ, STRCAT\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/10\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164366538827789@naggum.no>\n\n* Rahul Jain <rahul@rice.edu>\n| (defun do-this (lis1 lis2)\n|     (let ((both-lis (append lis1 lis2)))\n|          (do-something-with-both-lis ...)\n|          (reverse both-lis)))\n| \n| To a lisp-person, that's much easier to understand.\n\n  really?  I wonder what a \"lis\" is.  does lisp return t on it?  :)\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "list_problem_and_nth,_read,_strcat"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-04-10",
      "last_post_date": "2000-04-10"
    },
    {
      "id": "basic_question_(probably_w/_no_good_answer)",
      "title": "basic question (probably w/ no good answer)",
      "posts": [
        {
          "id": "3164210231625803@naggum.no",
          "subject": "Re: basic question (probably w/ no good answer)",
          "author_id": "erik_naggum",
          "date": "2000-04-08",
          "display_date": "04/08/2000",
          "content": "\nSubject: Re: basic question (probably w/ no good answer)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/08\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164210231625803@naggum.no>\n\n* Joe Marshall <jmarshall@alum.mit.edu>\n| The time you might `save' in compilation is negligable, a decent compiler\n| would produce similar code in either case, even if the code were\n| different, I can't imagine it would be so different as to have a\n| noticable impact on performance or code size, and if it *really* made a\n| noticable difference, I'd imagine that the compiler would be so piss-poor\n| as to be virtually unusable.\n\n  I think \"helping the compiler\" (not expressed in so many words, but in\n  meaning) is a metaphor that relates to the \"sufficiently smart compiler\",\n  and that it is not directly related to any actual assistance.  it's more\n  like \"would it hamper the smart compiler's ability to be as smart as it\n  could be\", or, as David put it \"do the right thing\".  I don't think so,\n  but it's a good question, nonetheless.  Rob pointed out that releasing\n  the hold on the objects might help (again, metaphorically) the garbage\n  collector pick up dead objects earlier, although it is hard for me right\n  now to imagine how this could b affected: scope analysis would cause the\n  bindings to go out of scope either way, and if these variables were in\n  call-frame slots or registers, they wouldn't necessarily be any more\n  garbage unless these slots were explicitly set to nil or something\n  similarly drastic (because the savings would be so limited compared to\n  the cost of doing this all over the place).\n\n| Making a hard-and-fast rule about this would lead to ridiculous coding\n| style if taken to the limit.\n\n  I'll trust readers of hard-and-fast rules to exercise their judgment and\n  not take things to ridiculous limits.\n\n  I think the question merits thought -- it's one of those small things\n  that it's too easy to waste time on because we're _not_ thinking about\n  it, and I for one think this question and questions like it would make it\n  a lot easier for more experienced programmers to help new programmers get\n  a feel for the language in actual use.  this is the \"experience\" part\n  that you get from reading lots of code and spending your working hours\n  among other Lisp programmers.  I think it's nice to see this newsgroup\n  assume part of that role, too.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "basic_question_(probably_w/_no_good_answer)"
        },
        {
          "id": "3164150875655283@naggum.no",
          "subject": "Re: basic question (probably w/ no good answer)",
          "author_id": "erik_naggum",
          "date": "2000-04-08",
          "display_date": "04/08/2000",
          "content": "\nSubject: Re: basic question (probably w/ no good answer)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/08\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164150875655283@naggum.no>\n\n* Dave Bakhash <cadet@alum.mit.edu>\n| My guess: don't close off the LET, but keep things nested, even\n| though those final expressions don't need to be inside the LET.\n\n  my rule of thumb: unless you use a binding form for its progn value,\n  i.e., in situations where you may use only one form, move the subforms\n  that don't need the bindings out of the binding form.  this makes it\n  clear when the scope of the bindings cease to exist, reducing the amount\n  of work a reader of the code would have to go through to figure out that\n  the bindings _don't_ affect these forms, and it makes it clear that the\n  binding form does not return a useful value, but is there for side\n  effect.  clues like this can make reading code a lot easier.\n\n  this is likely a matter of some personal taste.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "basic_question_(probably_w/_no_good_answer)"
        }
      ],
      "post_count": 2,
      "first_post_date": "2000-04-08",
      "last_post_date": "2000-04-08"
    },
    {
      "id": "more_questions_about_threads...",
      "title": "more questions about threads...",
      "posts": [
        {
          "id": "3163949210384068@naggum.no",
          "subject": "Re: more questions about threads...",
          "author_id": "erik_naggum",
          "date": "2000-04-05",
          "display_date": "04/05/2000",
          "content": "\nSubject: Re: more questions about threads...\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/05\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163949210384068@naggum.no>\n\n* Tim Bradshaw <tfb@cley.com>\n| I doubt performance of sunos 4.1.3 says anything about recent solaris\n| as that was before all the multiprocessor support in sunos 5 (I'm not\n| even sure how much code they share, probably very little).\n\n  note that I was talking about the consumption of PIDs, not performance.\n  this has to do with the number of scripts and invoked interpreters and\n  such, which may or may not impact performance.  what I was suggesting was\n  that Linux is very heavily script-and-interpreters-oriented, while BSD-\n  based Unices have traditionally been less so than AT&T-based Unices, for\n  whatever this is worth.  in any case, I would expect Linux to be faster\n  at forking _because_ it is used so much more.  Linux was heavily into\n  this mode of thinking long before it had SMP support.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "more_questions_about_threads..."
        },
        {
          "id": "3163944808069043@naggum.no",
          "subject": "Re: more questions about threads...",
          "author_id": "erik_naggum",
          "date": "2000-04-05",
          "display_date": "04/05/2000",
          "content": "\nSubject: Re: more questions about threads...\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/05\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163944808069043@naggum.no>\n\n* David Hanley <djh@ncgr.org>\n| And perhaps more critically: the ability to make use of more than one\n| CPU if present.\n\n  yet this may be what slows down the threads and speeds up the processes.\n\n  I think a valuable benchmarking approach would be test the same kind of\n  communication between the various kinds of processes, like sockets and\n  some simple protocol.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "more_questions_about_threads..."
        },
        {
          "id": "3163959816816739@naggum.no",
          "subject": "Re: more questions about threads...",
          "author_id": "erik_naggum",
          "date": "2000-04-05",
          "display_date": "04/05/2000",
          "content": "\nSubject: Re: more questions about threads...\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/05\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163959816816739@naggum.no>\n\n* Andrew Cooke <andrew@andrewcooke.free-online.co.uk>\n| I don't have multithreaded Lisp experience, but work in Java, where\n| threads are part of the standard language, and they are invaluable in\n| making responsive, robust systems without complicated coupling between\n| separate parts of the program.  So they often help *good design*.\n\n  you don't need OS support to make this work the way you want.  the desire\n  for OS support can often lead you to dismiss what you can actually do as\n  \"undesirable\".  many would-be CL users have run into this \"mindset trap\"\n  where they refuse to use Common Lisp because they have this fixation that\n  some feature or another must be \"standard\" before they can use it.\n\n  investigate your Common Lisp environment.  programming only in Common\n  Lisp as per the standard _only_ is like programming in any other language\n  as per the standard _only_ (with the exception that you can actually get\n  quite a lot of interesting work done in standard CL) -- ignoring the\n  programming environment (such as Allegro CL for CL, and Unix for C) is\n  just plain stupid.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "more_questions_about_threads..."
        },
        {
          "id": "3163944702587593@naggum.no",
          "subject": "Re: more questions about threads...",
          "author_id": "erik_naggum",
          "date": "2000-04-05",
          "display_date": "04/05/2000",
          "content": "\nSubject: Re: more questions about threads...\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/05\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163944702587593@naggum.no>\n\n* Tim Bradshaw <tfb@cley.com>\n| I'm not sure what if anything this says, except that solaris has fast\n| thread creation perhaps. I'd kind of expect their thread impl to be\n| pretty good because their market is big multiprocessor machines.\n\n  I'd also expect Sun to want a \"favorable demo\" effect that shows this.\n  Linux has made fork exceptionally fast (my experience is that PIDs are\n  used up about three times faster under Linux than under SunOS 4.1.3_U1,\n  with equivalent work being performed on the systems), and has implemented\n  the performance sensitive parts of vfork in fork.  ironically, it now\n  appears that threads have to do _more_ work than processes because they\n  _share_ the memory and a bunch of other stuff that fork splits off into\n  objects with distinct identity.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "more_questions_about_threads..."
        },
        {
          "id": "3164024042624368@naggum.no",
          "subject": "Re: more questions about threads...",
          "author_id": "erik_naggum",
          "date": "2000-04-06",
          "display_date": "04/06/2000",
          "content": "\nSubject: Re: more questions about threads...\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/06\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164024042624368@naggum.no>\n\n* David Hanley <djh@ncgr.org>\n| Not for every app.  I have an app which runs on a multiple CPU machine,\n| and needs to generate a number of images ( time intensive ).  I shoot off\n| a number of threads to work on the image ( one each ) and this makes the\n| whole thing happen a *lot* faster.\n\n  how do they communicate the results back to eachother or a master?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "more_questions_about_threads..."
        }
      ],
      "post_count": 5,
      "first_post_date": "2000-04-05",
      "last_post_date": "2000-04-06"
    },
    {
      "id": "setf_functions",
      "title": "setf functions",
      "posts": [
        {
          "id": "3163950557082770@naggum.no",
          "subject": "Re: setf functions",
          "author_id": "erik_naggum",
          "date": "2000-04-05",
          "display_date": "04/05/2000",
          "content": "\nSubject: Re: setf functions\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/05\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163950557082770@naggum.no>\n\n* Harald Hanche-Olsen <hanche@math.ntnu.no>\n| My point is that, as far as I can understand the Hyperspec, there is\n| no way to do this for a function returning multiple values, since the\n| form should be a place, which by definition can only refer to a single\n| value.  I'd love to be proved wrong on this one, though.  Or even if I\n| am right, maybe there is a more natural way to attack the problem?\n\n  apart from actually working, what's wrong with this example?\n\n(defstruct display\n  x y)\n\n(defun global-pointer-position (object)\n  (values (display-x object) (display-y object)))\n\n(defsetf global-pointer-position (object) (new-x new-y)\n  `(setf (display-x ,object) ,new-x\n\t (display-y ,object) ,new-y))\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "setf_functions"
        },
        {
          "id": "3164020402912136@naggum.no",
          "subject": "Re: setf functions",
          "author_id": "erik_naggum",
          "date": "2000-04-06",
          "display_date": "04/06/2000",
          "content": "\nSubject: Re: setf functions\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/06\nNewsgroups: comp.lang.lisp\nMessage-ID: <3164020402912136@naggum.no>\n\n* Marco Antoniotti <marcoxa@parades.rm.cnr.it>\n| What about this?\n| \n| (defun (setf global-pointer-position) (new-x new-y object)\n|   (setf (values (display-x object) (display-y object))\n|         (values new-x new-y)))\n| \n| It does not work in CMUCL, but I believe it should (modulo my\n| understanding on the CLHS)\n\n  that would mean the call would have to be\n\n(setf (global-pointer-position new-y object) new-x)\n\n  this is not what we want.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "setf_functions"
        }
      ],
      "post_count": 2,
      "first_post_date": "2000-04-05",
      "last_post_date": "2000-04-06"
    },
    {
      "id": "howto_string->symbol",
      "title": "howto string->symbol",
      "posts": [
        {
          "id": "3163878195909751@naggum.no",
          "subject": "Re: howto string->symbol",
          "author_id": "erik_naggum",
          "date": "2000-04-04",
          "display_date": "04/04/2000",
          "content": "\nSubject: Re: howto string->symbol\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/04\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163878195909751@naggum.no>\n\n* Raymond Toy <toy@rtp.ericsson.se>\n| While I understood the nice explanation snipped out above, could you\n| explain more fully exactly what you mean by \"WYSIWYG print names\"?\n\n  symbols whose print names are what you see, i.e., no case conversion\n  either on input or on output.\n\n  please note that I'm no more a fan of upper-case Common Lisp code than\n  those who gave Common Lisp *print-case* and readtable-case were.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "howto_string->symbol"
        },
        {
          "id": "3163862476772157@naggum.no",
          "subject": "Re: howto string->symbol",
          "author_id": "erik_naggum",
          "date": "2000-04-04",
          "display_date": "04/04/2000",
          "content": "\nSubject: Re: howto string->symbol\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/04\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163862476772157@naggum.no>\n\n* Tim Bradshaw <tfb@cley.com>\n| Sorry, my mistake, that should have been:\n| \n| \t(format nil \"~A~S\" (symbol-name ...) ...)\n\n  I'm not sure this is really good advice.\n\n  we really want to concatenate a few strings to make a new string.  format\n  does a whole bunch of weird stuff that may look right, but the exhaustive\n  test case is non-trivial to construct, and it really can't be caught any\n  other way until you know what you're doing with an exceptionally high\n  level of precision and attention to detail.  (since this topic comes up\n  every once in a while, a search engine hit rate increaser: static typing\n  -- it won't help at all in such interesting real-life cases.)\n\n  a simple mistake like using ~S with symbols involves the *print-case* of\n  symbols, which, while some people might be happy with the default, will\n  encounter a user who prefers to see lower-case symbol names, the same way\n  he writes them, and it bombs in ways mysterious to the uninitiate.\n\n  a simple mistake like using ~S with numbers involves the *print-base* of\n  numbers, and if the programmer has the skills to set *print-radix* to\n  true while using non-standard read bases, its effects intervene, too.\n\n(let ((*print-case* :downcase)\n      (*print-base* 3)\n      (*print-radix* t))\n  (format nil \"~S~S\" 'hello 3))\n=> \"hello#3r10\"\n\n  format is exceptionally good at producing output suitable for humans.  it\n  is not very good at producing values suitable for the Lisp reader, yet it\n  is so often called upon to do that it hurts.  here's a different solution\n  that uses the proper tools for the job, in my usual, unhumble opinion:\n\n(with-output-to-string (*standard-output*)\n  (with-standard-io-syntax\n    (prin1 'hello)\n    (prin1 3)))\n=> \"HELLO3\"\n\n  an \"optimized\" solution suitable for direct consumption for intern, which\n  is what's really sought in this case:\n\n(concatenate 'string\n    (symbol-name 'hello)\n    (with-standard-io-syntax\n      (write-to-string 3)))\n=> \"HELLO3\"\n\n  this might look less convenient than the wrong format solution, but\n  that's why we have defun.  constructing a new symbol out of constituent\n  parts, however that is defined, is (more or less unfortunately) _not_\n  child's play -- it is a sufficiently specialized task that even \"software\n  pattern\" arguments that this should be an idiom fail: it is not something\n  users are likely to find just one pattern for, and if they find one,\n  it would probably be just as wrong as the wrong format solution.  in\n  other words, they need to find out how this stuff works, and then apply\n  that knowledge to their domain _every_ time.\n\n  incidentally, this is also one of the reasons I favor WYSIWYG print names\n  for symbols.  all of this symbol-hacking stuff would be _significantly_\n  simpler with agreement on that principle.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "howto_string->symbol"
        },
        {
          "id": "3163848847427556@naggum.no",
          "subject": "Re: howto string->symbol",
          "author_id": "erik_naggum",
          "date": "2000-04-04",
          "display_date": "04/04/2000",
          "content": "\nSubject: Re: howto string->symbol\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/04\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163848847427556@naggum.no>\n\n* kp gores <gores@sip.medizin.uni-ulm.de>\n| I probably have all  packages using \"SHARED\"  to re-use it??\n\n  why do you think you need to \"re-use\" those packages?\n\n| it seems like being a bad idea creating symbols which are shared over\n| packages!?\n\n  it might, but that depends on their purpose.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "howto_string->symbol"
        },
        {
          "id": "3163935044643945@naggum.no",
          "subject": "Re: howto string->symbol",
          "author_id": "erik_naggum",
          "date": "2000-04-05",
          "display_date": "04/05/2000",
          "content": "\nSubject: Re: howto string->symbol\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/05\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163935044643945@naggum.no>\n\n* kp gores <gores@sip.medizin.uni-ulm.de>\n| well, i didn't test it. but i thought that pack A using pack B knows \n| about only the (external) symbols of B existing at the time of using and \n| not later created symbols.\n\n  as I suspected, but I am curious, from an educational vantage point --\n  it's an odd assumption to make, in my view, and I wonder how you came to\n  think this way.  here's how I think: when you let a package use another\n  package, you refer to the package, as opposed to the symbols of the\n  package with, say, a use-package-symbols operator, which is what import\n  does, essentially.  my goal is to find out how to explain the difference\n  between import and use-package very succinctly.  it is not enough to\n  argue that the name \"use-package\" is sufficient, unless one also argues\n  that people pay _real_ good attention to the names, but whether that is\n  feasible or not is the underlying concern.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "howto_string->symbol"
        }
      ],
      "post_count": 4,
      "first_post_date": "2000-04-04",
      "last_post_date": "2000-04-05"
    },
    {
      "id": "concatenated-stream_-_which_component_is_being_rea",
      "title": "concatenated-stream - which component is being read from?",
      "posts": [
        {
          "id": "3163344737710362@naggum.no",
          "subject": "Re: concatenated-stream - which component is being read from?",
          "author_id": "erik_naggum",
          "date": "2000-03-29",
          "display_date": "03/29/2000",
          "content": "\nSubject: Re: concatenated-stream - which component is being read from?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/29\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163344737710362@naggum.no>\n\n* Sam Steingold <sds@gnu.org>\n| Is there a way to figure out which component of a concatenated stream is\n| being read from?\n\n  from the definition of concatenated-stream-streams:\n\nReturns a list of input streams that constitute the ordered set of streams\nthe concatenated-stream still has to read from, starting with the current\none it is reading from. The list may be empty if no more streams remain to\nbe read.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "concatenated-stream_-_which_component_is_being_rea"
        },
        {
          "id": "3163863401819617@naggum.no",
          "subject": "Re: concatenated-stream - which component is being read from?",
          "author_id": "erik_naggum",
          "date": "2000-04-04",
          "display_date": "04/04/2000",
          "content": "\nSubject: Re: concatenated-stream - which component is being read from?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/04\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163863401819617@naggum.no>\n\n* hoehle-sorry@tzd.dont.telekom.spam.de.me (Joerg-Cyril Hoehle)\n| I believe there's a need for *particular* objects which *will* close\n| constituents when it has finished with them.\n\n  you _could_ define an after method on read-char and read-byte on that\n  stream that would close it once it got exhausted, using the widely\n  available Grey streams, or something better if and when it comes along\n  with such features available.  (hi, Duane!  hint for the taking!  :)\n\n  in an application that needed a little simpler life than it could get out\n  of the box, I added code to the socket layer this way to automatically\n  shut down the input side, forcing an EOF that consequently shut down the\n  output side gracefully as well when they ran into trouble of any kind, as\n  the socket error handling in most Unices is a disgraceful mess of special\n  cases that neither match nor attempt to match the TCP or IP\n  specifications.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "concatenated-stream_-_which_component_is_being_rea"
        }
      ],
      "post_count": 2,
      "first_post_date": "2000-03-29",
      "last_post_date": "2000-04-04"
    },
    {
      "id": "alternatives_to_eval",
      "title": "Alternatives to EVAL",
      "posts": [
        {
          "id": "3163690457188144@naggum.no",
          "subject": "Re: Alternatives to EVAL",
          "author_id": "erik_naggum",
          "date": "2000-04-02",
          "display_date": "04/02/2000",
          "content": "\nSubject: Re: Alternatives to EVAL\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/02\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163690457188144@naggum.no>\n\n* \"David E. Young\" <youngde@mindspring.com>\n| I've read that if EVAL is used explicitly within a program, it probably\n| indicates poor design.\n\n  the probability is not 1.0, however.  using EVAL in servers or programs\n  that accept input from users or agents of users for the express purpose\n  of evaluation in the Lisp world is good design -- reinventing your own\n  EVAL at this point is poor design.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "alternatives_to_eval"
        },
        {
          "id": "3163862636948799@naggum.no",
          "subject": "Re: Alternatives to EVAL",
          "author_id": "erik_naggum",
          "date": "2000-04-04",
          "display_date": "04/04/2000",
          "content": "\nSubject: Re: Alternatives to EVAL\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/04\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163862636948799@naggum.no>\n\n* Scott L. Burson\n| I would additionally suggest going a bit further and making a package\n| that contains *only* the symbols you will need to read.  This will limit\n| what the incoming forms can do when EVALed... which would make me a lot\n| more comfortable with this design.\n\n  it's even a little worse than you sketch out.  ideally, you should be\n  able to force intern not to intern, i.e. to have read call find-symbol\n  and barf on uninterned symbols.  ideally, you should be able to force the\n  symbol-reader to barf on _any_ package specification other than those you\n  have specified.  neither of these are possible in fully conforming code.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "alternatives_to_eval"
        }
      ],
      "post_count": 2,
      "first_post_date": "2000-04-02",
      "last_post_date": "2000-04-04"
    },
    {
      "id": "dangling_closing_parentheses_vs._stacked_closing_p",
      "title": "Dangling Closing Parentheses vs. Stacked Closing Parentheses",
      "posts": [
        {
          "id": "3163031395198264@naggum.no",
          "subject": "Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses",
          "author_id": "erik_naggum",
          "date": "2000-03-26",
          "display_date": "03/26/2000",
          "content": "\nSubject: Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/26\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163031395198264@naggum.no>\n\n* David J. Cooper\n| The \"discussion\" has started going around in circles -- he gives his many\n| reasons (\"things are easier to insert\" \"it is closer to other languages\n| like C and C++\" etc.), but most of all his main claim is that there is no\n| \"official standard\" which says parens are to be stacked like this in\n| Lisp, so he will write his code as he pleases, thank you very much.\n\n  you can't argue for _or_ against excessive whitespace on these grounds.\n  at issue is the relative importance of the delimiters.  in C, the block\n  structure is very important and the visual clues in indentation are not\n  sufficiently perspicuous that they can be trusted for anything, so { and\n  } delimiters get extremely visually apparent formatting characteristics,\n  such as their own lines.  in Common Lisp, the list structure is much less\n  important than the indentation, and the perspicuity of normal indentation\n  rules is sufficiently high that the parens are mainly used there for the\n  machine to use, not humans.  therefore, humans would tend to get parens\n  in CL out of the (visual) way, while the braces in C must be very visible.\n\n  different languages have different optimization parameters for almost\n  every facet of their expression.  trying to optimize CL code layout with\n  the parameters from C is completely braindamaged and merits nothing but a\n  snort, and people who are _that_ underdeveloped in their understanding of\n  the differences between languages should just be sedated and put away.\n  \n  community standards grow out of such pragmatic optimization parameters,\n  and can't _actually_ be defended by reference to authority, because one\n  has to trust the authority to be representative of the community.  one\n  must instead seek to understand how they got the way they are, and why\n  there may be minority and majority communities, as well.  (a community of\n  one may be a brilliant loner or a nutcase, and it's hard to tell which is\n  which.)  I think the need to understand how things came to be applies to\n  everything, but retracing the steps of decisions made by large groups of\n  people is usually quite depressing, so there is wisdom in accepting the\n  authorities at times.  yet, accepting or rejecting authorities _because_\n  they are authorities is really retarded and people who are prone to this\n  should also be sedated and put away.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "dangling_closing_parentheses_vs._stacked_closing_p"
        },
        {
          "id": "3163273489398038@naggum.no",
          "subject": "Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses",
          "author_id": "erik_naggum",
          "date": "2000-03-28",
          "display_date": "03/28/2000",
          "content": "\nSubject: Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/28\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163273489398038@naggum.no>\n\n* Charles Hixson\n| Lots of Irritating Single Parenthesis.  I believe that there used to be a\n| dialect of Lisp where one could signal \"close all parenthesis back to the\n| root\" by using a ] character, but that seems to have disappeared.  I\n| guess that it may have been a bit error prone.\n\n* Pierre R. Mai\n| It turned out that this functionality belongs in the editor, and not the\n| language.  That's why ] will close all outstanding parentheses in many\n| Lisp modes.  This way you get the benefits, without the trouble.  ...\n\n  for what it's worth, I have found it significantly easier to write code\n  in Emacs with M-( and M-) rather than ( and ).  I guess I picked up that\n  habit when I wrote an SGML-mode that automatized the matching between\n  start- and end-tags and inserted every character of the element name in\n  _both_ the start- and the end-tag.  I generalized this to let, e.g., M-*\n  produce ** with the cursor between them, and applied it to \"\", `', {},\n  [], <>, «», ¡!, ¿?, and for that old Common Lisp reader, ||, as well as\n  comments with #||#.  in my view, it's a serious mistake to use paired\n  delimiters of any kind in a language without _actively_ supporting their\n  paired entry when writing.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "dangling_closing_parentheses_vs._stacked_closing_p"
        },
        {
          "id": "3163274599898094@naggum.no",
          "subject": "Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses",
          "author_id": "erik_naggum",
          "date": "2000-03-28",
          "display_date": "03/28/2000",
          "content": "\nSubject: Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/28\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163274599898094@naggum.no>\n\n* \"Anthony Cartmell\" <AJCartmell@csi.com>\n| Sorry for the \"newbie\" question, but I thought that the indentation was\n| based on the list structure, and not the other way round.\n\n  well, this gets a little complicated.  the indentation is automatically\n  produced for you based on the list structure by the editor.  the list\n  structure, however, becomes visually apparent to us humans through\n  indentation.  new Lispers look at the list structure and think they\n  understand the indentation.  old Lispers look at the indentation and\n  understand the list structure.  new Lispers count parentheses and swear.\n  old Lispers reindent their code and immediately spot mistakes and just\n  clean them up.  the whole Lisp enlightenment experience is about making a\n  fundamental swap between syntax and indentation.  (at least one language\n  has made this switch permanent: python.  I'm not sure this is a good\n  thing.)\n\n| If the parens were based on the indentation then we wouldn't even need to\n| use them.\n\n  this is very naive.  _some_ redundancy is a fundamental characteristic of\n  _all_ successful communication, between computers as well as humans.\n\n| My whole reason for using dangling parens in my code is to show which\n| open-paren each close-paren closes by its indentation.  I don't\n| understand why this is such a bad layout style.\n\n  that's because you have never let yourself get immersed in indentation.\n  you don't need to see the parentheses.  (if you start seeing fnords,\n  alert your local illuminati.)\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "dangling_closing_parentheses_vs._stacked_closing_p"
        },
        {
          "id": "3163275695429682@naggum.no",
          "subject": "Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses",
          "author_id": "erik_naggum",
          "date": "2000-03-28",
          "display_date": "03/28/2000",
          "content": "\nSubject: Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/28\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163275695429682@naggum.no>\n\n* Duane Rettig <duane@franz.com>\n| I've seen most of the style arguments based on philosophy posted on this\n| thread, but there is one argument I have not yet seen.  [match the\n| results of the pretty printer.]\n\n  I like this argument.  I think we can sum it up like this:\n\n    there is no whitespace after an opening parenthesis.\n    there is no whitespace before a closing parenthesis.\n    this is the law.  if you break it, it is not pretty.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "dangling_closing_parentheses_vs._stacked_closing_p"
        },
        {
          "id": "3163278794398146@naggum.no",
          "subject": "Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses",
          "author_id": "erik_naggum",
          "date": "2000-03-29",
          "display_date": "03/29/2000",
          "content": "\nSubject: Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/29\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163278794398146@naggum.no>\n\n* Dorai Sitaram\n| Well, the CLISP pretty-printer gives this \"semi-dangled\" output:\n:\n| But if you look closer, you will realize with a jolt that the lparen that\n| an rparen lines up with is _not_ its matching lparen...\n\n  someone recently said (sorry, I have been skimming news lately) that he\n  had a problem starting with Lisp because everything was in uppercase --\n  small things like that can effectively block one's entry into new areas.\n  back when I was fairly new to Lisp (eons and eons ago, of course), I came\n  across CLISP and its unf<beep>ingbelievably braindamaged pretty printer.\n  it was immediately obvious that this had been implemented in a vacuum,\n  free from influence from all knowledgable programmers on the planet and\n  beyond, and it still sucked.  to see code printed like this was such a\n  horrible experience I immediately seized upon the source code to try to\n  find out how to turn this gut-wrenching abomination off.  but what did I\n  find?  the entire source code was formatted like this!  aaaaauuugh!  and\n  everything in German, to boot.  the abyss was staring back at me.  <fade>\n\n  CLISP has since improved.  no animals have been hurt in its production.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "dangling_closing_parentheses_vs._stacked_closing_p"
        },
        {
          "id": "3163280191819937@naggum.no",
          "subject": "Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses",
          "author_id": "erik_naggum",
          "date": "2000-03-29",
          "display_date": "03/29/2000",
          "content": "\nSubject: Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/29\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163280191819937@naggum.no>\n\n* Paolo Amoroso\n| The fact that the dangling parentheses convention is closer to other\n| languages like C and C++ may be a good reason not to use it :)\n\n* Anthony Cartmell\n| Seems to me that this really is the main reason...  is the Lisp layout\n| \"standard\" really this sad?\n\n  there is another, deeper reason behind this that you may have overlooked.\n\n  in C, parentheses are used for a number of fundamentally different tasks,\n  and in C++ it gets _completely_ insane, but that's another matter.  after\n  a student of C has learned the painful precedence rules by rote and is\n  still trying to internalize them so he can just _read_ expressions, the\n  parentheses enter the picture as a source of pain or a painkiller when\n  the precedence rules do not match the requirements of the expression.\n  either way, there is pain.  you will often find C programmers battle\n  their operators and their precedence rules for hours on end, recompiling\n  frequently because they don't have an interactive environment, either.\n  the lesson learned by that vestige of primitive brain that keeps us from\n  sticking a hand into hot water the second time, is that parentheses are\n  painful.  that a C programmer could have gotten rid of the pain by using\n  parentheses consistently around his operators and arguments is lost by\n  this primitive part of the brain.\n\n  then Lisp comes around and it's all parentheses.  primitive brain shrieks.\n\n  this is probably not restricted to C, but a property of that horrible\n  mathematical infix syntax that is supposedly \"natural\" and which _also_\n  has precedence rules in which parentheses play an important role,\n  including the implied multiplication in the absence of operators.  it\n  could be that early childhood experiences with the utter mindlessness of\n  infix syntax and the need for parentheses to escape out of the stupid\n  rules they made up is actually exceptionally traumatic on young brains\n  who try to trust their ability to understand the world around them.\n  parentheses break their trust, so when they see Lisp and it's all\n  parentheses, they become psychotic.  this would explain a lot.  a LOT!\n\n  however, the parentheses in Lisp are just like the semicolon in C.\n\n  here's an experiment you can conduct at home: take a piece of C code to\n  which a large group of people have contributed, several thousand lines of\n  Open Source should do, modify it slightly in some useful and non-trivial\n  way that people would probably like, and insert a newline before every\n  semicolon and indent the line an extra tab relative to the line it used\n  to belong to, ship the code to all the people who have contributed and be\n  very enthusiastic about your improvements, but don't comment on the style\n  change.  if you do _not_ receive realistic death threats, consider the\n  experiment a failure.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "dangling_closing_parentheses_vs._stacked_closing_p"
        },
        {
          "id": "3163347243776063@naggum.no",
          "subject": "Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses",
          "author_id": "erik_naggum",
          "date": "2000-03-29",
          "display_date": "03/29/2000",
          "content": "\nSubject: Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/29\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163347243776063@naggum.no>\n\n* \"Anthony Cartmell\" <AJCartmell@csi.com>\n| Lisp (as I now understand) uses many deep nested lists, and large-multiple\n| consecutive close parens are very common.  Lisp does not tend to use long\n| list forms (except perhaps cond and case) so inserting removing items in\n| lists is not often done, and dangling parens therefore have little use.\n\n  um, excuse me, but what do you think Lisp code is made of?  there is no\n  point at all to make the artificial differences you seem to want to make.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "dangling_closing_parentheses_vs._stacked_closing_p"
        },
        {
          "id": "3163280668120222@naggum.no",
          "subject": "Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses",
          "author_id": "erik_naggum",
          "date": "2000-03-29",
          "display_date": "03/29/2000",
          "content": "\nSubject: Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/29\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163280668120222@naggum.no>\n\n* ds26@goldshoe.gte.com (Dorai Sitaram)\n| Anyway, converting between the dangling and clumped styles is\n| automatable.  An Elisp programmer should be able to implement the\n| following pseudocode in a few minutes:\n| \n| Dangling-to-clumped:\n|   While there is a line with only right parens,\n|   join that line with the previous line.  \n|   Reindent.\n\n  watch this code die a horrible flaming death:\n\n(foo a                          ; mumble\n     b                          ; frotz\n     c                          ; fnord\n     )\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "dangling_closing_parentheses_vs._stacked_closing_p"
        },
        {
          "id": "3163386232244478@naggum.no",
          "subject": "Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses",
          "author_id": "erik_naggum",
          "date": "2000-03-30",
          "display_date": "03/30/2000",
          "content": "\nSubject: Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/30\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163386232244478@naggum.no>\n\n* Tom Breton <tob@world.std.com>\n| It bears noting that Naggum's message in context was a non-sequitur.\n| Granted, it's an OK if bilious response to the strawman he was tilting\n| at in his own mind.\n\n  poor baby.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "dangling_closing_parentheses_vs._stacked_closing_p"
        },
        {
          "id": "3163496120774411@naggum.no",
          "subject": "Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses",
          "author_id": "erik_naggum",
          "date": "2000-03-31",
          "display_date": "03/31/2000",
          "content": "\nSubject: Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/31\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163496120774411@naggum.no>\n\n* \"Anthony Cartmell\" <AJCartmell@csi.com>\n| um, excuse me, as far as I can tell Lisp code is made of many short, deeply\n| nested lists per file.\n\n  that's, um, interesting.  whence this shallow opinion that \"Lisp code\" is\n  sufficiently homogeneous to warrant such a blanket generalization?\n\n| If I am wrong about Lisp source code's general form please enlighten me!\n\n  there seems to be so much to enlighten you about that it is instead much\n  more relevant at this point to use that fact to discredit your opinions.\n  this is regrettable, but your lack of insight into the topics you spend\n  so much time talking about renders any further discussion moot.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "dangling_closing_parentheses_vs._stacked_closing_p"
        },
        {
          "id": "3163496610594768@naggum.no",
          "subject": "Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses",
          "author_id": "erik_naggum",
          "date": "2000-03-31",
          "display_date": "03/31/2000",
          "content": "\nSubject: Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/31\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163496610594768@naggum.no>\n\n* \"Anthony Cartmell\" <AJCartmell@csi.com>\n| Perhaps you could explain to me how Emacs does indentation of Lisp code?\n| I'm really interested, especially if it doesn't look at the parens.\n\n  you're not getting it, are you?  Emacs looks at the parens to indent, the\n  reader of the indented code subsequently does _not_ look at the parens.\n  unless you are Emacs, parens are nearly irrelevant.  if you _are_ Emacs,\n  try M-x doctor.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "dangling_closing_parentheses_vs._stacked_closing_p"
        },
        {
          "id": "3163582467115882@naggum.no",
          "subject": "Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses",
          "author_id": "erik_naggum",
          "date": "2000-04-01",
          "display_date": "04/01/2000",
          "content": "\nSubject: Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/01\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163582467115882@naggum.no>\n\n* \"Anthony Cartmell\" <AJCartmell@csi.com>\n| Because some Lisp people get SO UPTIGHT about dangling parens ...\n:\n| Oh dear, I only asked whether my statement about Lisp code's general form\n| was correct or not.  Is it really so difficult to reply without throwing all\n| your toys out of the pram and getting personal?\n\n  your first line is indeed personal.  my reply to you concerns a matter of\n  fact that is not personal, but relates only to your _actions_.  yes, they\n  are _your_ actions, and if you want to take it personally, you are free\n  to do so for that reason, but you are equally free not to.  how could\n  anyone _not_ take \"some Lisp people get SO UPTIGHT\" as a personal insult?\n  here's another _impersonal_ suggestion: grow a clue before you accuse\n  others of ills you are worse at yourself.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "dangling_closing_parentheses_vs._stacked_closing_p"
        },
        {
          "id": "3163690209543717@naggum.no",
          "subject": "Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses",
          "author_id": "erik_naggum",
          "date": "2000-04-02",
          "display_date": "04/02/2000",
          "content": "\nSubject: Re: Dangling Closing Parentheses vs. Stacked Closing Parentheses\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/02\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163690209543717@naggum.no>\n\n* \"Anthony Cartmell\" <AJCartmell@csi.com>\n| Thanks for agreeing with me when I say that in Emacs the indentation is\n| based on the parens.\n\n  such has never been disputed.  you're amazingly exasperating, you know that?\n\n| So Andy is wrong when he said that I don't understand how Emacs indents\n| Lisp.\n\n  well, I'm sorry, but you don't.  as commonly used, \"based on\" indicates a\n  necessary condition but _not_ a sufficient one, and this is indeed the\n  case in this situation, as has been pointed out to you.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "dangling_closing_parentheses_vs._stacked_closing_p"
        }
      ],
      "post_count": 13,
      "first_post_date": "2000-03-26",
      "last_post_date": "2000-04-02"
    },
    {
      "id": "help_required:_is_there_a_way_to_split_up_one_elem",
      "title": "Help required: Is there a way to split up one element into several?",
      "posts": [
        {
          "id": "3163417605117716@naggum.no",
          "subject": "Re: Help required: Is there a way to split up one element into several?",
          "author_id": "erik_naggum",
          "date": "2000-03-30",
          "display_date": "03/30/2000",
          "content": "\nSubject: Re: Help required: Is there a way to split up one element into several?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/30\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163417605117716@naggum.no>\n\n* Erik Halvarsson <ericthorvald@hotmail.com>\n| From an external file I need to get some data, and it's stored like:\n| \n| VKA100         707898.512    78172.497    143.803\n| \n| a simple xyz coordinate.  When I use the (readline file) function, that\n| string becomes one single element in the list I assign it to.  What I\n| need is four different elements in the list but I have so far no clue\n| how to achive this.  Would be great if anyone out there could help me.\n\n  if each line is known to consist of these four elements, the first looks\n  very much a symbol, and programmer time is more important than much\n  anything else, just use the function read.  here's a quick shot at it:\n\n(let ((*package* (make-package (gensym) :use ())))\n  (unwind-protect\n      (loop for line = (loop with first = (read <stream> nil)\n\t\t\t     if (not first)\n\t\t\t     then do (loop-finish)\n\t\t\t     else collect (symbol-name first)\n\t\t\t     repeat 3\n\t\t\t     collect (read <stream>))\n\t    while line\n\t    collect line)\n    (delete-package *package*)))\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "help_required:_is_there_a_way_to_split_up_one_elem"
        },
        {
          "id": "3163497050252832@naggum.no",
          "subject": "Re: Help required: Is there a way to split up one element into several?",
          "author_id": "erik_naggum",
          "date": "2000-03-31",
          "display_date": "03/31/2000",
          "content": "\nSubject: Re: Help required: Is there a way to split up one element into several?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/31\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163497050252832@naggum.no>\n\n* \"Andrew K. Wolven\" <awolven@redfernlane.org>\n| AutoLisp is not Common Lisp.\n\n  well, comp.lang.lisp is not an AutoLisp newsgroup.\n  comp.cad.autocad might be a good place to start.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "help_required:_is_there_a_way_to_split_up_one_elem"
        },
        {
          "id": "3163690604532935@naggum.no",
          "subject": "Re: Help required: Is there a way to split up one element into several?",
          "author_id": "erik_naggum",
          "date": "2000-04-02",
          "display_date": "04/02/2000",
          "content": "\nSubject: Re: Help required: Is there a way to split up one element into several?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/04/02\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163690604532935@naggum.no>\n\n* Paolo Amoroso <amoroso@mclink.it>\n| What is the purpose of the temporary package, i.e. the one which is bound\n| to *PACKAGE*? To avoid cluttering a useful package with symbols that are\n| interned just to get their names?\n\n  yes, that is precisely the reason I chose to set up a temporary package.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "help_required:_is_there_a_way_to_split_up_one_elem"
        }
      ],
      "post_count": 3,
      "first_post_date": "2000-03-30",
      "last_post_date": "2000-04-02"
    },
    {
      "id": "threads",
      "title": "Threads",
      "posts": [
        {
          "id": "3163392393402934@naggum.no",
          "subject": "Re: Threads",
          "author_id": "erik_naggum",
          "date": "2000-03-30",
          "display_date": "03/30/2000",
          "content": "\nSubject: Re: Threads\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/30\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163392393402934@naggum.no>\n\n* Andrew Cooke <andrew@andrewcooke.free-online.co.uk>\n| - If I understood an earlier topic correctly, assigning a value to a\n| dynamic scoped variable using let copies the original value to a safe\n| place for the scope of the let before replacing it.  In a multi-threaded\n| environment this implies that the value will change for all threads - is\n| that correct?\n\n  let doesn't assign values, it creates a new binding.  how it is actually\n  implemented underneath has _some_ implications for the rest of the\n  system, but no matter how it is implemented, you should not assume that\n  the implementation violates the semantics.  this implies that the new\n  binding is local to the process (thread), since the other processes\n  (threads) are not in the dynamic scope of the new binding.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "threads"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-03-30",
      "last_post_date": "2000-03-30"
    },
    {
      "id": "when_would_it_be_better_to_use_recursion_than_a_lo",
      "title": "When would it be better to use recursion than a loop?",
      "posts": [
        {
          "id": "3163396794300015@naggum.no",
          "subject": "Re: When would it be better to use recursion than a loop?",
          "author_id": "erik_naggum",
          "date": "2000-03-30",
          "display_date": "03/30/2000",
          "content": "\nSubject: Re: When would it be better to use recursion than a loop?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/30\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163396794300015@naggum.no>\n\n* Flounder <japh@flashmail.com>\n| I come from a background of C/C++, perl, python, and more languages of\n| the sort.  I am currently learning Lisp on my own and am seeing that Lisp\n| programmers use recursion more than I have seen in the other languages\n| that I have programmed in so when is it best to use it and when would it\n| be best to use loops?  Maybe you could just give me some basic rules to\n| follow on how to decide which to use.\n\n  here's my rule of thumb: whenever the algorithm generates values from or\n  for each iteration, it is naturally recursive, and will most probably\n  find an elegant recursive expression, which, because it uses an optimized\n  storage of such values, namely the function call stack frame, will also\n  be more efficient than your hand-crafted storage unless you're very good\n  at what you're doing.  whenever the algorithm does _not_ generate values\n  from each iteration (as in: generates and consumes an equal amount of\n  values), it is in my not so humble opionion extremely unlikely that a\n  recursive implementation will make more sense than an iterative solution,\n  and not unlikely that a recursive solution will be more complex and will\n  also run slower unless you're careful.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "when_would_it_be_better_to_use_recursion_than_a_lo"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-03-30",
      "last_post_date": "2000-03-30"
    },
    {
      "id": "[q]how_to_evaluate_a_string_as_lisp_code?",
      "title": "[Q]How to evaluate a string as lisp code?",
      "posts": [
        {
          "id": "3163345278914696@naggum.no",
          "subject": "Re: [Q]How to evaluate a string as lisp code?",
          "author_id": "erik_naggum",
          "date": "2000-03-29",
          "display_date": "03/29/2000",
          "content": "\nSubject: Re: [Q]How to evaluate a string as lisp code?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/29\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163345278914696@naggum.no>\n\n* \"David J. Cooper\" <dcooper@genworks.com>\n| Let's say your string is in the variable called string.\n| \n| (eval (read-from-string string))\n| \n| This will evaluate exactly one expression from the string.  You'll have\n| to do something more (probably with subseq or something) to read and\n| evaluate multiple expressions from a string.\n\n  note that read-from-string returns two values, the secondary of which is\n  the position from which you could continue to read from the string.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[q]how_to_evaluate_a_string_as_lisp_code?"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-03-29",
      "last_post_date": "2000-03-29"
    },
    {
      "id": "summary_of_dangling_closing_parentheses_vs._stacke",
      "title": "Summary of Dangling Closing Parentheses vs. Stacked Closing Parentheses",
      "posts": [
        {
          "id": "3163239343709562@naggum.no",
          "subject": "Re: Summary of Dangling Closing Parentheses vs. Stacked Closing Parentheses",
          "author_id": "erik_naggum",
          "date": "2000-03-28",
          "display_date": "03/28/2000",
          "content": "\nSubject: Re: Summary of Dangling Closing Parentheses vs. Stacked Closing Parentheses\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/28\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163239343709562@naggum.no>\n\n* Anthony Cartmell\n| The \"Lisp\" code I write in ICAD is much more like C/C++ in that we\n| construct long relatively-shallow list structures.  Thus adding code is\n| mostly inserting into lists, and dangling parens are useful and don't\n| occur in long sequences (perhaps three or four closes maximum in a row).\n\n  you have previously given an example like this:\n\n(list a\n      (list b c d)\n      (list 0\n            (list e f g\n                  (list h))))\n\n  I didn't understand why you did this, as I would typically have written\n  it very differently, and much more compactly:\n\n`(,a (,b ,c ,d) (0 (,e ,f ,g (,h))))\n\n  for what it's worth, I don't think editing this structure is hard, even\n  in vi-clones, which do sport the % command to move to the other paren.\n\n  on the other hand, I think a fair summary of the situation is that as you\n  grow used to Lisp and the parens lose importance and \"disappear\", you\n  seek tools that help you reduce the importance of the parens, too.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "summary_of_dangling_closing_parentheses_vs._stacke"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-03-28",
      "last_post_date": "2000-03-28"
    },
    {
      "id": "can_lisp_do_what_perl_does_easily?",
      "title": "can lisp do what perl does easily?",
      "posts": [
        {
          "id": "3163193555464012@naggum.no",
          "subject": "Re: can lisp do what perl does easily?",
          "author_id": "erik_naggum",
          "date": "2000-03-28",
          "display_date": "03/28/2000",
          "content": "\nSubject: Re: can lisp do what perl does easily?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/28\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163193555464012@naggum.no>\n\n* ; ; ; h e l m e r . . . <assemblage@t-three.com>\n| I have been slowly learning lisp over the past year and have had someone\n| mention to me that I should learn perl, for jobs etc.\n\n  the unemployed programmer had a problem.  \"I know\", said the programmer,\n  \"I'll just learn perl.\"  the unemployed programmer now had two problems.\n\n  having a job is not unimportant, but if knowing perl is a requirement for\n  a particular job, consider another one before taking that one.  this is\n  true even if you know perl very well.  life is too long to be an expert\n  at harmful things, including such evilness as C++ and perl.\n  \n  I once studied perl enough to read perl code and spot bugs in other\n  people's programs (but later gained the wisdom that this was not an\n  accomplishment -- spotting a bug in a perl program is like spotting the\n  dog that brought the fleas), but I don't write in it and I don't ever\n  plan to use it for anything (part of my new position is quality assurance\n  for the systems I'm inheriting responsibility for, and part of any\n  serious QA is removing perl code the same way you go over a dilapidated\n  building you inherit to remove chewing gum and duct tape and fix whatever\n  was kept together for real).  also, very much unlike any other language I\n  have ever studied, perl has failed to stick to memory, a phenomenon that\n  has actually puzzled me, but I guess there are some things that are so\n  gross you just have to forget, or it'll destroy something with you.  perl\n  is the first such thing I have known.\n\n  this is your brain.  this is perl.  this is your brain on perl.  any\n  questions?\n\n| If I learn lisp well will I be able to do what people do with perl[?]\n\n  no, you won't.  however, there is a very important clue to be had from\n  this: what people do with perl is wrong.  perl makes a whole lot of tasks\n  easy to do, but if you look closely, you will see that those tasks are\n  fundamentally braindamaged, and should never have been initiated.  perl\n  is perhaps the best example I can think of for a theory I have on the\n  ills of optimization and the design choices people make.  most people,\n  when faced with a problem, will not investigate the cause of the problem,\n  but will instead want to solve it because the problem is actually in the\n  way of something more important than figuring out why something suddenly\n  got in their way out of nowhere.  if you are a programmer, you may reach\n  for perl at this point, and perl can remove your problem.  happy, you go\n  on, but find another problem blocking your way, requiring more perl --\n  the perl programmer who veers off the road into the forest will get out\n  of his car and cut down each and every tree that blocks his progress,\n  then drive a few meters and repeat the whole process.  whether he gets\n  where he wanted to go or not is immaterial -- a perl programmer will\n  happily keep moving forward and look busy.  getting a perl programmer\n  back on the road is a managerial responsibility, and it can be very hard:\n  the perl programmer is very good at solving his own problems and assure\n  you that he's on the right track -- he looks like any other programmer\n  who is stuck, and this happens to all of us, but the perl programmer is\n  very different in one crucial capacity: the tool is causing the problems,\n  and unlike other programmers who discover the cause of the problem sooner\n  or later and try something else, perl is rewarding the programmer with a\n  very strong sense of control and accomplishment that a perl programmer\n  does _not_ try something else.\n\n  it's not that perl programmers are idiots, it's that the language rewards\n  idiotic behavior in a way that no other language or tool has ever done,\n  and on top of it, it punishes conscientiousness and quality craftsmanship\n  -- put simply: you can commit any dirty hack in a few minutes in perl,\n  but you can't write an elegant, maintainabale program that becomes an\n  asset to both you and your employer; you can make something work, but you\n  can't really figure out its complete set of failure modes and conditions\n  of failure.  (how do you tell when a regexp has a false positive match?)\n\n  a person's behavior is shaped by the rewards and the punishment he has\n  received while not thinking about his own actions.  few people habitually\n  engage in the introspection necessary to break out of this \"social\n  programming\" or decide to ignore the signals that other people send them,\n  so this is a powerful mechanism for programming the unthinking masses.\n  rewarding idiotic behavior and punishing smart behavior effectively\n  brainwashes people, destroying their value systems and their trust in\n  their own understanding and appreciation of the world they live in, but\n  if you're very good at it, you can create a new world for them in which\n  all of this makes sense.\n\n  to really destroy any useful concepts of how software is supposed to work\n  together, for instance, the best possible way is to ridicule the simple\n  and straightforward concepts inherent in Lisp's read and print syntax,\n  then ridicule the overly complex and entangled concepts in stuff like IDL\n  and CORBA, which does basically the same thing as Lisp's simple syntax,\n  and then hail the randomness of various programs that output junk data,\n  because you can easily massage the data into the randomness that some\n  other program accepts as input.  instead of having syntax-driven data\n  sharing between programs, you have code-driven glue between programs, and\n  because you are brainwashed perl idiot, this is an improvement, mostly to\n  your job security.  and once you start down this path, every move forward\n  is a lot cheaper than any actual improvements to the system that would\n  _obviate_ the need for more glue code.  however, if you never start down\n  this path, you have a chance of making relevant and important changes.\n\n  that's why, if you learn Lisp and become a good programmer, you will\n  never want to do what people do with perl.  as such a good programmer,\n  one in five managers will notice that you solve problems differently and\n  will want to hire you to clean up after the perl programmers he used to\n  be mortally afraid of firing, and you can push any language you want at\n  this point -- just make sure you can find more programmers he can hire\n  who know it and always keep your code well-documented and readable -- you\n  do _not_ want to make any other programming language appear as random as\n  perl to any manager.  perl is already a \"necessary evil\", but still evil,\n  while other languages don't have the \"necessary\" label, so if you screw\n  up, it will hurt other programmers, too.  this problem can always be\n  minimized by simply being good at what you do.  few perl programmers are\n  actually good at anything but getting perl to solve their _immediate_\n  problems, so you have an incredible advantage if you're a good Lisper.\n\n  I'll concede, however, that it is very important to be able to understand\n  what perl programmers do.  if you don't understand what they are talking\n  about, you won't understand what they are actually trying to accomplish\n  with all the incredibly braindamaged uses of hash tables and syntactic\n  sadomasochism, and you won't be able to see through their charades and\n  \"just one more hack, and I'll be there\" lies.\n\n  here's a simple rule to use on perl programmers.  if a solution is clean\n  and complete, it will immediately look like a tremendous amount of work\n  to a perl programmer, which it will: writing code that does the right\n  thing in perl is incredibly arduous.  this is the only positive use for\n  perl programmers.  like a really bad horror movie, where the evil guys\n  have no redeeming qualities whatsoever and will hate anything beautiful\n  or good, a true perl programmer will have a strong emotional reaction to\n  any really good solution: there's no way he can improve on it with his\n  perl hackery, and the very existence of his expertise is threatened.\n\n  then there are good programmers who know and use perl for some tasks, but\n  more than anything else know when _not_ to use it.  they are _very_ rare.\n  \n#:Erik\n\n",
          "references": [],
          "thread_id": "can_lisp_do_what_perl_does_easily?"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-03-28",
      "last_post_date": "2000-03-28"
    },
    {
      "id": "shall_i_learn_lisp??",
      "title": "shall I learn LISP??",
      "posts": [
        {
          "id": "3163031932885054@naggum.no",
          "subject": "Re: shall I learn LISP??",
          "author_id": "erik_naggum",
          "date": "2000-03-26",
          "display_date": "03/26/2000",
          "content": "\nSubject: Re: shall I learn LISP??\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/26\nNewsgroups: comp.lang.lisp\nMessage-ID: <3163031932885054@naggum.no>\n\n* <xutao@mercury.ee.cornell.edu>\n| I was told that to be a good programmer, you must learn LISP, although\n| you might never use it in your real life programming, it will teach you\n| how to make good programs, is it true?\n\n  yes.  \"those who do not know Lisp are doomed to reinvent it.\"\n\n| If so, where shall I start to learn LISP, Lisp interpreters does not seem\n| to install in my LINUX system.\n\n  that's odd.  Linux systems are very well supported by Lisp systems.\n  which Linux are you using?  if you are using the programmers' favorite\n  distribution, Debian GNU/Linux, you can install CLISP and CMUCL with the\n  package system, and Franz Inc offers a trial edition for Linux that you\n  basically download and install.\n\n| But I guess that I shall be able to program lisp in Emacs, right?\n\n  you will, but Emacs Lisp is a _really_ ancient dialect of Lisp, with lots\n  of interesting stuff missing.  the modern Lisp is Common Lisp.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "shall_i_learn_lisp??"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-03-26",
      "last_post_date": "2000-03-26"
    },
    {
      "id": "new_to_lisp_(3rd_time_lucky)",
      "title": "new to lisp (3rd time lucky)",
      "posts": [
        {
          "id": "3162901564202112@naggum.no",
          "subject": "Re: new to lisp (3rd time lucky)",
          "author_id": "erik_naggum",
          "date": "2000-03-24",
          "display_date": "03/24/2000",
          "content": "\nSubject: Re: new to lisp (3rd time lucky)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/24\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162901564202112@naggum.no>\n\n* Natalia <nati@one.net.au>\n| lisp is frying my brain, i think i will stick to\n| subjects that program in c from now on.\n\n  well, take it from an old hand: the only reason it would be easier to\n  program in C is that you can't easily express complex problems in C, so\n  you don't.  I have 17 years of C programming experience, and I'm damn\n  good at it, but that's also _why_ I program in Common Lisp.  but perhaps\n  you need a few years of C programming to appreciate better languages -- I\n  have repeatedly said that programmers graduate into Common Lisp as they\n  tire of inferior languages.  however, getting too good at something that\n  is not good for you is _really_ bad for you, as it means you'll have to\n  accept a temporary reduction in living standards if you switch, and lots\n  of hard work on the side with little or no pay if you decide to combine\n  the two.  therefore, another saying: life is too long to be good at C/C++.\n\n  it is probably C that _has_ fried your brain, by the way.  not that this\n  will comfort you or anything, but note that if you are used to C, the\n  utter pointlessness of most of the exercises in recursion that Lisp and\n  Scheme teachers tend to push on unsuspecting students become so glaringly\n  visible that you would never even think of recursion again, even when it\n  is clearly the best solution.  this doesn't mean that recursion is bad,\n  it only means that iteration is better in a lot of cases where recursion\n  adds nothing to the understanding of the task at hand.  the lesson to be\n  learned from this is that giving exercises in the proper use of recursion\n  is much harder than giving lessons in the proper use of iteration, and\n  indeed requires a much deeper understanding of the problems for which\n  recursion is the optimal solution, both in terms of what you describe to\n  the intelligent programmer and what you execute on the hardware.\n\n  e.g., in your current problem, it is obviously a lot smarter to iterate\n  over a list than to recurse over it (despite what your teachers may tell\n  you about the \"instructiveness\" of such endeavors), yet you must recurse\n  if and when the element in the list is itself a list, and that's the\n  valuable part of the exercise.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "new_to_lisp_(3rd_time_lucky)"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-03-24",
      "last_post_date": "2000-03-24"
    },
    {
      "id": "common_lisp_interpretation_by_emacs",
      "title": "Common Lisp interpretation by emacs",
      "posts": [
        {
          "id": "3162927272540679@naggum.no",
          "subject": "Re: Common Lisp interpretation by emacs",
          "author_id": "erik_naggum",
          "date": "2000-03-24",
          "display_date": "03/24/2000",
          "content": "\nSubject: Re: Common Lisp interpretation by emacs\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/24\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162927272540679@naggum.no>\n\n* Barry Margolin\n| I interpreted it as \"can't be done in the current Emacs because it's not\n| written in Common Lisp\".  I was assuming that your message was referring\n| to the thread subject, and trying to interpret the phrase in that light.\n\n  holy cow -- the level at which some people here work _so_ hard to find\n  something to quarrel over is flat out amazing.  get some _sleep_, dude!\n\n  yes, it would be possible to do in some Common Lisp implementations.\n  yes, it would be possible to do in something different than Common Lisp.\n  yes, it would be possible to do in something entirely different than Emacs.\n\n  this _completely_ invalidates you quibbling \"because it's not written in\n  Common Lisp\".  the causal relationship you so adamantly seek is absent.\n\n  why do I want to do it Common Lisp?  is \"duh!\" a satisfactory answer or\n  do you actually have to have this _explained_ to you, Barry?  one could\n  almost believe you have been getting really upset over something and are\n  not getting over it.  this _has_ happened before.  is it recurring?\n\n| If I understand you correctly, the point you're making is that some CL\n| implementors have already implemented some things (like FFI) that haven't\n| been implemented in Emacs Lisp yet.  So what you're really comparing are\n| implementations, not languages.  None of these things are mentioned by,\n| nor even hinted at by, the ANSI CL spec.\n\n  I don't consider \"Common Lisp\" to be restricted to what's strictly in the\n  standard unless I explicitly and specifically name the standard or make\n  it the context.  that's why I _also_ don't require everything I think is\n  useful to be part of the standard before I can use it and why I don't\n  believe that using implementation extensions is evil or any of the other\n  numerous anal-retentive attitudes that flourish in some subcommunities of\n  this newsgroup under the guise of \"open source\".\n\n  I will regret it if it is now necessary to verbosely state \"I use an\n  implementation of Common Lisp in a development environment conducive to\n  the goals of the Common Lisp language\" every time one wishes to say \"I\n  use Common Lisp\", but considering the personal needs of some people here\n  (and their history of same, which I'm reminded of) to find flaws and\n  quarrel where it has absolutely zero constructive value, maybe it's time\n  to post in HTML with hypertext links from just about every word to pages\n  upon pages of disclaimers and explanations.\n\n| The fact that the Lisp implementations with FFI are all CL could almost\n| be considered a coincidence.\n\n  sure, and that's perfectly fine by me.  most of the interesting stuff\n  that happens in this world is by coincidence.  it would be foolish to\n  deny or belittle facts merely because they are coincidences, of course,\n  but I assume that something like that underlies your argument, which I\n  must therefore reject as rather specious.\n\n| If you can contemplate the resources being available for this, why can't\n| you imagine those same resources being applied to adding these features\n| to Emacs Lisp?\n\n  I can.  I have.  you're abaout five years too late with your question.\n  why do you assume so arrogantly that you are the first person on this\n  planet to have thought of counter-arguments?  I find that puzzling.  I\n  find it even more puzzling that the question is posed to aggressively.\n  if you have a personal problem you wish to raise, please don't feel\n  obliged to wrap it in gift paper like a pseudo-technical discussion.\n\n| It would certainly have been nice if Emacs had been written in Common\n| Lisp to begin with.  But now there's a huge body of code (the Emacs\n| source itself and all the public packages that are avaiable) that's\n| dependent on the current dialect.  If Emacs were converted to Common Lisp\n| it could essentially set it back a decade or more as we wait for people\n| to recode all their packages to be compatible.\n\n  you are certainly free to assume that this is the only way to think about\n  this problem and you are equally free to assume that noobody else would\n  have the wherewithal to solve technical problems of this kind, either.\n  the phrasing makes it abundantly clear that it has zero value to educate\n  you against your will on this topic, and so I won't even try.  it would,\n  as has been said about another pointless endeavor, waste my time and\n  annoy you.\n  \n#:Erik\n\n",
          "references": [],
          "thread_id": "common_lisp_interpretation_by_emacs"
        },
        {
          "id": "3162858618807593@naggum.no",
          "subject": "Re: Common Lisp interpretation by emacs",
          "author_id": "erik_naggum",
          "date": "2000-03-24",
          "display_date": "03/24/2000",
          "content": "\nSubject: Re: Common Lisp interpretation by emacs\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/24\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162858618807593@naggum.no>\n\n* Christopher R. Barry\n| Most people that complain that they want a CL-Emacs haven't really\n| said what they'd do with it or what applications they'd develop for it\n| that they won't make for our current Emacs.  Yes, having Gnus be able\n| to poll multiple servers simultaneously would be nice.  Is that all???\n\n  what I have wanted that can't be done in the current Emacs are:\n\n1 an Emacs server that talks to several Emacs clients that don't interfere\n  (such as one process per X window/Emacs frame).\n\n2 file-system server processes in user space which serve Emacs clients with\n  network-optimal fragments of files on remote and local hosts alike, such\n  that you can edit files with the native privileges of several users.\n\n3 integration via foreign function interfaces to other code on the system.\n  (there is now an Emacs with some dynamic loading support.)\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "common_lisp_interpretation_by_emacs"
        },
        {
          "id": "3162910141905443@naggum.no",
          "subject": "Re: Common Lisp interpretation by emacs",
          "author_id": "erik_naggum",
          "date": "2000-03-24",
          "display_date": "03/24/2000",
          "content": "\nSubject: Re: Common Lisp interpretation by emacs\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/24\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162910141905443@naggum.no>\n\n* Barry Margolin <barmar@bbnplanet.com>\n| #1 and #2 don't seem to be related to the dialect of Lisp that Emacs\n| happens to be written in.\n\n  I prefixed what I wrote with \"what I have wanted that can't be done in\n  the current Emacs are:\", so I assume you ignored that context instead of\n  merely overlooking it, but it is in fact crucial, even to your supposed\n  counter-argument.  Emacs Lisp has some _fundemental_ limitations that\n  Common Lisp the language and its several implementations don't have.\n  obviously, however, you _could_ do anything in any language given enough\n  effort and resources, but whether you want to is _usually_ a matter of\n  convenience and pragmatics for most people -- the absence of available\n  resources is usually an argument against \"can\".  if you will, Emacs Lisp\n  makes certain tasks prohibitively inconvenient and/or impractical.  for\n  me, that matters a lot.  if it doesn't matter to you, I expect a free\n  implementation soon.\n\n| #3 doesn't depend on ANSI CL, but just the fact that most CL\n| implementations also include foreign function interfaces; but there's no\n| good reason why a similar FFI couldn't be included in Emacs Lisp.\n\n  then you should have no objection to \"then go do it\", right?\n  I promise that I'll listen to your argument _after_ you have done it.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "common_lisp_interpretation_by_emacs"
        },
        {
          "id": "3162852050149389@naggum.no",
          "subject": "Re: Common Lisp interpretation by emacs",
          "author_id": "erik_naggum",
          "date": "2000-03-24",
          "display_date": "03/24/2000",
          "content": "\nSubject: Re: Common Lisp interpretation by emacs\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/24\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162852050149389@naggum.no>\n\n* Christopher R. Barry\n| Just learn to live with and love and improve the Emacs we have now,\n| since a CL one just isn't happening, and would take a lot of work to\n| make much more spectacular than our current Emacs even if it did.\n\n  regrettably, I have come to the same conclusion -- this won't fly if it\n  doesn't have a very significant advantage over the current Emacs, and\n  that means user-visible features, not just programmability in a much\n  better language.  with two major disincentives operating against any\n  Common Lisp project, the chances of sufficient popularity are also very\n  slim.  the two disincentives are primarily the close-minded attitude and\n  open hostility of the Open Source crowd towards anything that is not\n  sufficiently \"open\" -- i.e., \"philosophically impure\" in their eyes --\n  which detracts effort and would-be programmers alike, and secondarily\n  that the pool of people was already so small initially that it certainly\n  has no critical mass by the time the primary disincentive has eroded\n  popular enthusiasm.\n  \n#:Erik\n\n",
          "references": [],
          "thread_id": "common_lisp_interpretation_by_emacs"
        }
      ],
      "post_count": 4,
      "first_post_date": "2000-03-24",
      "last_post_date": "2000-03-24"
    },
    {
      "id": "setf_&_setq,_newbie_needs_short_definitions/exampl",
      "title": "setf & setq, newbie needs short definitions/examples",
      "posts": [
        {
          "id": "3162858660978623@naggum.no",
          "subject": "Re: setf & setq, newbie needs short definitions/examples",
          "author_id": "erik_naggum",
          "date": "2000-03-24",
          "display_date": "03/24/2000",
          "content": "\nSubject: Re: setf & setq, newbie needs short definitions/examples\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/24\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162858660978623@naggum.no>\n\n* Tim Bradshaw <tfb@cley.com>\n| This is useful for things like swapping variables, and other things:\n| \n| \t(psetq x y \n| \t       y x)\n| \n| exchanges x and y (although there are more idiomatic ways of doing this,\n| perhaps).\n\n  like (rotatef x y).\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "setf_&_setq,_newbie_needs_short_definitions/exampl"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-03-24",
      "last_post_date": "2000-03-24"
    },
    {
      "id": "macro_question_(bizarre)",
      "title": "Macro question (bizarre)",
      "posts": [
        {
          "id": "3162359744057189@naggum.no",
          "subject": "Re: Macro question (bizarre)",
          "author_id": "erik_naggum",
          "date": "2000-03-18",
          "display_date": "03/18/2000",
          "content": "\nSubject: Re: Macro question (bizarre)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/18\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162359744057189@naggum.no>\n\n* Tom Breton <tob@world.std.com>\n| Pardon my opinion, but multiple values are basically for when you have\n| code set in stone...\n\n  noted as opinion.\n\n| IOW, values is basically a backwards-compatibility thing.\n\n  it can definitely be used for this purpose, and may even have great value\n  used this way, but I must admit that I never thought of values like that.\n\n  values to me is a mechanism that removes the burden of agreeing on the\n  aggregate form of the returned values.  I guess this has to be explained\n  in terms of how other languages deal with the same issue: multiple values\n  are often expressed in C by passing a pointer to a structure in the\n  caller's memory to be filled in by the callee.  returning a structure is\n  _still_ not kosher in the C world, and incompatibilities exist in how it\n  is done.  this affects how people return more than one value from their\n  functions.  in some cases, the caller needs to pass multiple pointers as\n  arguments to be written to.  Ada has a clean way to do this: with in and\n  out arguments, the latter of which act just like multiple-value-setq.\n\n| When that's *not* the case, simply returning a list is better in every\n| way that springs to mind, IMO.\n\n  since consing and destructuring both have very significant costs, I'd\n  rate this is an insufficiency of things that spring to mind.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "macro_question_(bizarre)"
        },
        {
          "id": "3162477927563017@naggum.no",
          "subject": "Re: Macro question (bizarre)",
          "author_id": "erik_naggum",
          "date": "2000-03-19",
          "display_date": "03/19/2000",
          "content": "\nSubject: Re: Macro question (bizarre)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/19\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162477927563017@naggum.no>\n\n* Tom Breton <tob@world.std.com>\n| So in sum, I grant that values can do a little more than I said, on\n| the optimiztion front, but IMO optimization is not something that one\n| should think about when coding.\n\n  people who profess aggressively _not_ to care about optimizing tend to\n  work just as hard _pessimizing_ their code as those who profess to care\n  about optimizing tend to work on optimizing theirs.  the right balance is\n  the one that results from deep insight into the costs of all operations\n  involved, and the simple concept of avoiding wanton abuse of resources.\n  in my opinion, those who argue against optimization on the basis of a\n  desire to squander resources, are lazy in a very destructive sense.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "macro_question_(bizarre)"
        },
        {
          "id": "3162478065220549@naggum.no",
          "subject": "Re: Macro question (bizarre)",
          "author_id": "erik_naggum",
          "date": "2000-03-19",
          "display_date": "03/19/2000",
          "content": "\nSubject: Re: Macro question (bizarre)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/19\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162478065220549@naggum.no>\n\n* Tom Breton <tob@world.std.com>\n| OK, that basically touched the same points as Erik's, and my answer is\n| that I grant that values can do a little more than I said, on the\n| optimization front, but optimization should be a last resort.\n\n  but what kind of code do you have before you \"resort\" to optimization?\n  is this really a counter-argument to being _economical_?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "macro_question_(bizarre)"
        },
        {
          "id": "3162539209387357@naggum.no",
          "subject": "Re: Macro question (bizarre)",
          "author_id": "erik_naggum",
          "date": "2000-03-20",
          "display_date": "03/20/2000",
          "content": "\nSubject: Re: Macro question (bizarre)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/20\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162539209387357@naggum.no>\n\n* Duane Rettig\n| Returning a list always requires consing; returning multiple values\n| (mostly) does not.\n\n* Tom Breton <tob@world.std.com>\n| Which is an optimization issue.\n\n  I think this is getting closer to the point.  \"optimization\" to you\n  obviously means anything that involves thinking about resource usage.\n  such is in my view an obviously invalid and useless abstraction, and does\n  a major disservice to the work involved in writing good software.\n\n  however, I do find it rather curious that you optimize your writing to\n  the point of being unreadable with random four-letter abbreviations.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "macro_question_(bizarre)"
        },
        {
          "id": "3162507259147690@naggum.no",
          "subject": "Re: Macro question (bizarre)",
          "author_id": "erik_naggum",
          "date": "2000-03-20",
          "display_date": "03/20/2000",
          "content": "\nSubject: Re: Macro question (bizarre)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/20\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162507259147690@naggum.no>\n\n* Tom Breton <tob@world.std.com>\n| I would not call that economical.  You're spending the more important\n| resource, coding time/effort/attention, handling the multiple values.\n| \"Can I use them here, or have they degraded?\"  \"Why did my code stop\n| working?  Could this prog1 be the problem?  It couldn't possibly be,\n| the logic's exactly the same.  (pull hair out while poring over code)\"\n\n  I'm sensing fire, burned children, and fear.  being economical can either\n  be conscious and achieved by thinking, as in the unskilled programmer who\n  makes the best choices late, or automated and achived by emotion and gut\n  feeling, as in the highly skilled who makes the best choices early.  you\n  seem to think that writing efficient, economical code is something you do\n  on a conscious basis after you have done something \"clean\" that is stupid\n  and uneconomical according to the resource expenditure measures that you\n  attemt to introduce later.  this is the incompetent's credo, and I for\n  one do not subscribe to it.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "macro_question_(bizarre)"
        },
        {
          "id": "3162508890587433@naggum.no",
          "subject": "Re: Macro question (bizarre)",
          "author_id": "erik_naggum",
          "date": "2000-03-20",
          "display_date": "03/20/2000",
          "content": "\nSubject: Re: Macro question (bizarre)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/20\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162508890587433@naggum.no>\n\n* Tom Breton <tob@world.std.com>\n| One of the best things I learned as a programmer was *not* to grab at\n| everything that looked like an opportunity to optimize.\n\n  I'm sure that's true for you.  one of the best things I learned as a\n  novice programmer was that no matter what I choose to do, it has impact\n  on performance, and if I want to waste as little time as possible going\n  back over code and rewrite it, it would help me a lot to understand as\n  much as possible both about the hardware and the language used.  the more\n  factors I can deal with at the same time, the less time I spending fixing\n  up code that ignored one or more factors that turned to be important.\n  the only way to deal with a whole bunch of factors at once is to work so\n  much with them they migrate into your automated, emotional response\n  system, just like people walk and type and talk without actually thinking\n  about _any_ of the specific physical operations involved.\n\n| I find I rarely actually want the optimization enuff to be worth doing\n| later.\n\n  of course not.  that's the problem with doing optimization too late.\n\n  premature optimization can hurt you, and real bad at that.  that doesn't\n  mean thinking in terms of optimization is bad.  it means that you don't\n  do optimization stuff that is likely to hurt you, and you spend a fair\n  amount of your working life acquiring the experience that tells you that\n  some things may hurt a little, yet need to be done, anyway.  avoiding all\n  kinds of hurt is a very good way never to acquire _any_ experience.\n\n  tell you what.  I recently got a position where I'm about to hire a\n  sysadm and some programmers.  I'm looking for people who are good at what\n  they do, obviously, and to me, that has always meant an interest in stuff\n  that happens \"below\" whatever you're \"supposed\" to be doing, as in\n  _caring_.  a sysadm who doesn't care about hardware is obviously going to\n  run into a situation one day where his non-caring will impact everyone\n  else badly.  it is less obvious with a programmer, but I have decided\n  that I'm not going to hire Common Lisp programmers who don't want to know\n  how to read the disassembled code of a compiled function.  neither will I\n  let anyone who is unwilling to read RFCs to understand TCP/IP and other\n  networking fundamentals work on network protocol implementations, even\n  high-level ones.  likewise, if someone told me that he'd always optimize\n  late, I'd assume that he'd be a really bad programmer whose brain didn't\n  work or fast well enough that he could deal with economy of expression\n  and algorithm and resource use at the same time, and would have to take\n  care of each one at a time.  just as you don't disassemble code all the\n  time, and certainly don't think about IP packets and network issues all\n  the time, the fact that you care about it means you don't ignore it, and\n  not ignoring it means not overlooking something that can save you days in\n  debugging, weeks in design, and months in customer relations.\n\n  I'm not sure what you're trying to tell us, except that I get this really\n  bad feeling you're defending a programming style that optimized very much\n  for you not being hurt again.  if you optimize so heavily for that, I'm\n  sure you'll appreciate that other people may optimize for other factors\n  with at least as much effort.  the result for you is reinforced efficacy\n  in dealing with programming problems by removing a whole slew of issues.\n  the result for those who have automatized their optimization of code is\n  reinforced efficacy in dealing with programming problems by removing a\n  whole slew of issues.  the net result, however, is that you all feel\n  good, but their code also runs much more efficiently in the same time.\n  now, I want programmers who feel good about themselves, but I'm not going\n  to pay more than half the money for one that doesn't write good code.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "macro_question_(bizarre)"
        },
        {
          "id": "3162630253214665@naggum.no",
          "subject": "Re: Macro question (bizarre)",
          "author_id": "erik_naggum",
          "date": "2000-03-21",
          "display_date": "03/21/2000",
          "content": "\nSubject: Re: Macro question (bizarre)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/21\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162630253214665@naggum.no>\n\n* Tom Breton <tob@world.std.com>\n| Doing two things at once does neither thing well.\n\n  this is your personal experience.  it is not mine, which is that the more\n  we _think_ about at the same time, the less we need to do over later.\n\n| (*) Yes, it's another TLA.  It means \"In my experience\".  TLA means\n| \"three letter acronym\", a term I'm abusing slitely here.  \n\n  you just spent two whole lines explaining your \"optimized\" writing style!\n  I'm sorry, Tom, but I find this positively hilarious, to the point where\n  it has removed any credibility to your ridiculous points about optimizing.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "macro_question_(bizarre)"
        },
        {
          "id": "3162796950204470@naggum.no",
          "subject": "Re: Macro question (bizarre)",
          "author_id": "erik_naggum",
          "date": "2000-03-23",
          "display_date": "03/23/2000",
          "content": "\nSubject: Re: Macro question (bizarre)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/23\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162796950204470@naggum.no>\n\n* Tom Breton <tob@world.std.com>\n| Wow, you're getting really defensive, putting words in my mouth,\n| attacking me personally for explaining something you specifically\n| asked about, and the rest.  Well, I didn't mean to cause you such\n| emotional distress by teaching you remedial programming.  Guess I must\n| have accidentally struck a nerve.  Really sorry, hope you recover.\n\n  you think you have been teaching me remedial programming?\n  that's, like, amazing.  you really _are_ quite nuts.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "macro_question_(bizarre)"
        }
      ],
      "post_count": 8,
      "first_post_date": "2000-03-18",
      "last_post_date": "2000-03-23"
    },
    {
      "id": "building_a_\"loadable\"_tar_file.",
      "title": "Building a \"loadable\" tar file.",
      "posts": [
        {
          "id": "3162824624300417@naggum.no",
          "subject": "Re: Building a \"loadable\" tar file.",
          "author_id": "erik_naggum",
          "date": "2000-03-23",
          "display_date": "03/23/2000",
          "content": "\nSubject: Re: Building a \"loadable\" tar file.\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/23\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162824624300417@naggum.no>\n\n* Marco Antoniotti <marcoxa@parades.rm.cnr.it>\n| 1 - Yes.  I'd like LOAD to recognize a file which was the result of a\n|     collection operation of many fasl files, and \"do the right\" thing\n|     with it.\n| \n| 2 - This would require a change in the standard.\n\n  huh?  why is this?\n\n| 3 - Some CL implementations allow you to actually 'cat' fasl files\n|     together for the benefit of LOAD.\n\n  if we regard a Common Lisp source file as a sequence of individual\n  top-level forms that does not know about file boundaries between them,\n  you can easily concatenate source files and end up with something that\n  can be loaded as a unit.  if we regard the compiled fasl files the same\n  way, and this can obviously be done if each top-level form is saved to\n  disk individually, possibly including some file-specific prologue that is\n  generated by the compiler, there really is nothing special involved in\n  concatenating files.\n\n  if you can load from a stream, you can load from a concatenated-stream,\n  so there should already be support in the standard for the whole concept.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "building_a_\"loadable\"_tar_file."
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-03-23",
      "last_post_date": "2000-03-23"
    },
    {
      "id": "setting_logical_hosts_and_translations_for_a_direc",
      "title": "Setting logical hosts and translations for a directory hierarchy",
      "posts": [
        {
          "id": "3162699348428723@naggum.no",
          "subject": "Re: Setting logical hosts and translations for a directory hierarchy",
          "author_id": "erik_naggum",
          "date": "2000-03-22",
          "display_date": "03/22/2000",
          "content": "\nSubject: Re: Setting logical hosts and translations for a directory hierarchy\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/22\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162699348428723@naggum.no>\n\n* Paolo Amoroso <amoroso@mclink.it>\n| Since ACL is the most ANSI compliant, it's easy to get what I need. I have\n| added the following to ~/.clinit.cl:\n| \n| (setf (logical-pathname-translations \"clocc\")\n|       '((\"**;*.*.*\" \"/home/paolo/projects/clocc/\")\n|         (\";**;*.*.*\" \"/home/paolo/projects/clocc/\")))\n\n  although this works, you should really have matching wildcards in the\n  translation:\n\n(setf (logical-pathname-translations \"clocc\")\n  '((\"**;*.*.*\" \"/home/paolo/projects/clocc/**/*.*\")\n    (\";**;*.*.*\" \"/home/paolo/projects/clocc/**/*.*\")))\n\n  this yields the same results as the ones you have in Allegro CL, but they\n  may work better in the other CLs, too.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "setting_logical_hosts_and_translations_for_a_direc"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-03-22",
      "last_post_date": "2000-03-22"
    },
    {
      "id": "strings_and_characters",
      "title": "strings and characters",
      "posts": [
        {
          "id": "3162184639382952@naggum.no",
          "subject": "Re: strings and characters",
          "author_id": "erik_naggum",
          "date": "2000-03-16",
          "display_date": "03/16/2000",
          "content": "\nSubject: Re: strings and characters\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/16\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162184639382952@naggum.no>\n\n* Tim Bradshaw <tfb@cley.com>\n| The particular thing I don't understand is what type a literal string\n| has.  It looks at first sight as if it should be something capable of\n| holding any CHARACTER, but I'm not really sure if that's right.  It looks\n| to me as if it might be possible read things such that it's OK to return\n| something that can only hold a subtype of CHARACTER in some cases.\n\n  strings _always_ contain a subtype of character.  e.g., an implementation\n  that supports bits will have to discard them from strings.  the only\n  array type that can contain all character objects has element-type t.\n\n| I'm actually more concerned with the flip side of this -- if almost all\n| the time I get some `good' subtype of CHARACTER (probably BASE-CHAR?)\n| but sometimes I get some ginormous multibyte unicode thing or something,\n| because I need to be able I have to deal with some C code which is\n| blithely assuming that unsigned chars are just small integers and strings\n| are arrays of small integers and so on in the usual C way, and I'm not\n| sure that I can trust my strings to be the same as its strings.\n\n  this is not a string issue, it's an FFI issue.  if you tell your FFI that\n  you want to ship a string to a C function, it should do the conversion\n  for you if it needs to be performed.  if you can't trust your FFI to do\n  the necessary conversions, you need a better FFI.\n\n| I realise that people who care about character issues are probably\n| laughing at me at this point, but my main aim is to keep everything as\n| simple as I can, and especially I don't want to have to keep copying my\n| strings into arrays of small integers (which I was doing at one point,\n| but it's too hairy).\n\n  if you worry about these things, your life is already _way_ more complex\n  than it needs to be.  a string is a string.  each element of the string\n  is a character.  stop worrying beyond this point.  C and Common Lisp\n  agree on this fundamental belief, believe it or not.  your _quality_\n  Common Lisp implementation will ensure that whatever invariants are\n  maintained in _each_ environment.\n\n| The practical question I guess is -- are there any implementations which\n| do currently have really big characters in strings?\n\n  yes, and not only that -- it's vitally important that strings take up no\n  more space than they need.  a system that doesn't support both\n  base-string (of base-char) and string (of extended-char) when it attempts\n  to support Unicode will fail in the market -- Europe and the U.S. simply\n  can't tolerate the huge growth in memory consumption from wantonly using\n  twice as much as you need.  Unicode even comes with a very intelligent\n  compression technique because people realize that it's a waste of space\n  to use 16 bits and more for characters in a given character set group.\n\n| I know there's an international Allegro, so those might have horrors in\n| them.\n\n  sure, but in the same vein, it might also have responsible, intelligent\n  people behind it, not neurotics who fail to realize that customers have\n  requirements that _must_ be resolved.  Allegro CL's international version\n  deals very well with conversion between the native system strings and its\n  internal strings.  I know -- not only do I run the International version\n  in a test environment that needs wide characters _internally_, the test\n  environment can't handle Unicode or anything else wide at all, and it's\n  never been a problem.\n\n  incidentally, I don't see this as any different from whether you have a\n  simple-base-string, a simple-string, a base-string, or a string.  if you\n  _have_ to worry, you should be the vendor or implementor of strings, not\n  the user.  if you are the user and worry, you either have a problem that\n  you need to take up with your friendly programmer-savvy shrink, or you\n  call your vendor and ask for support.  I don't see this as any different\n  from whether an array has a fill-pointer or not, either.  if you hand it\n  to your friendly FFI and you worry about the length of the array with or\n  without fill-pointer, you're simply worrying too much, or you have a bug\n  that needs to be fixed.\n\n  \"might have horrors\"!  what's next?  monster strings under your bed?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "strings_and_characters"
        },
        {
          "id": "3162232362158363@naggum.no",
          "subject": "Re: strings and characters",
          "author_id": "erik_naggum",
          "date": "2000-03-16",
          "display_date": "03/16/2000",
          "content": "\nSubject: Re: strings and characters\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/16\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162232362158363@naggum.no>\n\n* Barry Margolin <barmar@bbnplanet.com>\n| Isn't (array character (*)) able to contain all character objects?\n\n  no.  specialized vectors whose elements are of type character (strings)\n  are allowed to store only values of a subtype of type character.  this is\n  so consistently repeated in the standard and so unique to strings that\n  I'm frankly amazed that anyone who has worked on the standard is having\n  such a hard time accepting it.  it was obviously intended to let strings\n  be as efficient as the old string-char concept allowed, while not denying\n  implementations the ability to retain bits and fonts if they so chose.\n\n  an implementation that stores characters in strings as if they have null\n  implementation-defined attributes regardless of their actual attributes\n  is actually fully conforming to the standard.  the result is that you\n  can't expect any attributes to survive string storage.  the consequences\n  are _undefined_ if you attempt to store a character with attributes in a\n  string that can't handle it.\n\n  the removal of the type string-char is the key to understanding this.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "strings_and_characters"
        },
        {
          "id": "3162224499405328@naggum.no",
          "subject": "Re: strings and characters",
          "author_id": "erik_naggum",
          "date": "2000-03-16",
          "display_date": "03/16/2000",
          "content": "\nSubject: Re: strings and characters\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/16\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162224499405328@naggum.no>\n\n* Tim Bradshaw <tfb@cley.com>\n| Incidentally I should make this clearer, as it looks like I'm arguing\n| against fat strings.  Supporting several kinds of strings is *obviously*\n| sensible, I quibble about the compressing stuff being worth it.\n\n  compressing strings for in-memory representation of _arrays_ is nuts.\n  nobody has proposed it, and nobody ever will.  again, read the Unicode\n  technical report and decrease both your fear and your ignorance.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "strings_and_characters"
        },
        {
          "id": "3162223661729749@naggum.no",
          "subject": "Re: strings and characters",
          "author_id": "erik_naggum",
          "date": "2000-03-16",
          "display_date": "03/16/2000",
          "content": "\nSubject: Re: strings and characters\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/16\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162223661729749@naggum.no>\n\n* Erik Naggum\n| strings _always_ contain a subtype of character.  e.g., an implementation\n| that supports bits will have to discard them from strings.  the only\n| array type that can contain all character objects has element-type t.\n\n* Tim Bradshaw\n| I don't think this is right -- rather I agree that they contain\n| CHARACTERs, but it looks like `bits' -- which I think now are\n| `implementation-defined attributes' -- can end up in strings, or at least\n| it is implementation-defined whether they do or not (2.4.5 says this I\n| think).\n\n  trivially, \"strings _always_ contain a subtype of character\" must be true\n  as character is a subtype of character, but I did mean in the sense that\n  strings _don't_ contain full character objects, despite the relegation of\n  fonts and bits to \"implementation-defined attributes\".  that the type\n  string-char was removed from the language but the attributes were sort of\n  retained is perhaps confusing, but it is quite unambiguous as to intent.\n\n  so must \"the only array type that can contain all character objects has\n  element-type t\" be true, since a string is allowed to contain a subtype\n  of type character.  (16.1.2 is pertinent in this regard.)  it may come as\n  a surprise to people, but if you store a random character object into a\n  string, you're not guaranteed that what you get back is eql to what you\n  put into it.\n\n  furthermore, there is no print syntax for implementation-defined\n  attributes in strings, and no implementation is allowed to add any.  it\n  is perhaps not obvious, but the retention of attributes is restricted by\n  _both_ the string type's capabilities and the stream type's capabilities.\n\n  you can quibble with the standard all you like -- you aren't going to see\n  any implementation-defined attributes in string literals.  if you compare\n  with CLtL1 and its explicit support for string-char which didn't support\n  them at all, you must realize that in order to _have_ any support for\n  implementation-defined attributes, you have to _add_ it above and beyond\n  what strings did in CLtL1.  this is an extremely unlikely addition to an\n  implementation just after bits and fonts were removed from the language\n  and relegated to \"implementation-defined attributes\".\n\n  I think the rest of your paranoid conspiratorial delusions about what\n  \"horrors\" might afflict Common Lisp implementations are equally lacking\n  in merit.  like, nothing is going to start spitting Unicode at you, Tim.\n  not until and unless you ask for it.  it's called \"responsible vendors\".\n\n| The only place it will matter is network transmission of data, and I\n| don't see why normal compression techniques shouldn't deal with that.\n\n  then read the technical report and decrease your ignorance.  sheesh.\n\n#:Erik, who's actually quite disappointed, now.\n\n",
          "references": [],
          "thread_id": "strings_and_characters"
        },
        {
          "id": "3162300918453715@naggum.no",
          "subject": "Re: strings and characters",
          "author_id": "erik_naggum",
          "date": "2000-03-17",
          "display_date": "03/17/2000",
          "content": "\nSubject: Re: strings and characters\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/17\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162300918453715@naggum.no>\n\n* Tim Bradshaw <tfb@cley.com>\n| Is there a useful, fast, check that that (write-sequence x y) will write\n| (length x) bytes on y if all is well for LispWorks / Liquid ...?\n\n  yes.  make the buffer and the stream have type (unsigned-byte 8), and\n  avoid the character abstraction which you obviously can't trust, anyway.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "strings_and_characters"
        },
        {
          "id": "3162290151959539@naggum.no",
          "subject": "Re: strings and characters",
          "author_id": "erik_naggum",
          "date": "2000-03-17",
          "display_date": "03/17/2000",
          "content": "\nSubject: Re: strings and characters\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/17\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162290151959539@naggum.no>\n\n* Pekka P. Pirinen\n| Who replaced #:Erik with a bad imitation?\n\n  geez...\n\n| You've read a different standard than I, since many places actually say\n| \"of type CHARACTER or a subtype\" -- superfluously, since the glossary\n| entry for \"subtype\" says \"Every type is a subtype of itself.\"\n\n  sigh.  this is so incredibly silly it isn't worth responding to.\n\n| I suspect it was removed because it was realized that there would have to\n| be many types of STRING (at least 8-byte and 16-byte), and hence there\n| wasn't a single subtype of CHARACTER that would be associated with\n| strings.  Whatever the reason, we can only go by what the standard says.\n\n  the STRING type is a union type, and there are no other union types in\n  Common Lisp.  this should give you a pretty powerful hint, if you can get\n  away from your \"bad imitation\" attitude problem and actually listen, but\n  I guess that is not very likely at this time.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "strings_and_characters"
        },
        {
          "id": "3162302923332864@naggum.no",
          "subject": "Re: strings and characters",
          "author_id": "erik_naggum",
          "date": "2000-03-17",
          "display_date": "03/17/2000",
          "content": "\nSubject: Re: strings and characters\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/17\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162302923332864@naggum.no>\n\n* Barry Margolin <barmar@bbnplanet.com>\n| But if you want a type that can hold any character, you can create it with:\n| \n| (make-string length :element-type 'character)\n\n  no, and that's the crux of the matter.  this used to be different from\n\n(make-string length :element-type 'string-char)\n\n  in precisely the capacity that you wish is still true, but it isn't.\n  when the type string-char was removed, character assumed its role in\n  specialized arrays, and you could not store bits and fonts in strings any\n  more than you could with string-char.  to do that, you need arrays with\n  element-type t.\n\n  but I'm glad we've reached the point where you assert a positive, because\n  your claim is what I've been trying to tell you guys DOES NOT HOLD.  my\n  claim is: there is nothing in the standard that _requires_ that there be\n  a specialized array with elements that are subtypes of character (i.e., a\n  member of the union type \"string\") that can hold _all_ character objects.\n\n  can you show me where the _standard_ supports your claim?\n\n| In fact, you don't even need the :ELEMENT-TYPE option, because CHARACTER is\n| the default.\n\n  sure.  however, I'm trying to penetrate the armor-plated belief that the\n  resulting string is REQUIRED to retain non-null implementation-defined\n  attributes if stored into it.  no such requirement exists: a conforming\n  implementation is completely free to provide a single string type that is\n  able to hold only simple characters.  you may think this is a mistake in\n  the standard, but it's exactly what it says, after the type string-char\n  was removed.\n\n  methinks you're stuck in CLtL1 days, Barry, and so is this bad imitation\n  jerk from Harlequin, but that's much less surprising.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "strings_and_characters"
        },
        {
          "id": "3162357232406441@naggum.no",
          "subject": "Re: strings and characters",
          "author_id": "erik_naggum",
          "date": "2000-03-18",
          "display_date": "03/18/2000",
          "content": "\nSubject: Re: strings and characters\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/18\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162357232406441@naggum.no>\n\n* Barry Margolin <barmar@bbnplanet.com>\n| I'm still not following you.  Are you saying that characters with\n| implementation-defined attributes (e.g. bits or fonts) might not satisfy\n| (typep c 'character)?\n\n  no.  I'm saying that even as this _is_ the case, the standard does not\n  require a string to be able to hold and return such a character intact.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "strings_and_characters"
        },
        {
          "id": "3162358302244558@naggum.no",
          "subject": "Re: strings and characters",
          "author_id": "erik_naggum",
          "date": "2000-03-18",
          "display_date": "03/18/2000",
          "content": "\nSubject: Re: strings and characters\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/18\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162358302244558@naggum.no>\n\n* Tim Bradshaw <tfb@cley.com>\n| Which is precisely what I want to avoid unfortunately, as it means that\n| either this code or the code that calls it has to deal with the issue of\n| copying strings too and from arrays of (UNSIGNED-BYTE 8)s, which simply\n| brings back the same problem somewhere else.\n\n  in this case, I'd talk to my vendor or dig deep in the implementation to\n  find a way to transmogrify an (unsigned-byte 8) vector to a character\n  vector by smashing the type codes instead of copying the data.  (this is\n  just like change-class for vectors.)  barring bivalent streams that can\n  accept either kind of vector (coming soon to an implementation near you),\n  having to deal with annoyingly stupid or particular external requirements\n  means it's OK to be less than nice at the interface level, provided it's\n  done safely.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "strings_and_characters"
        },
        {
          "id": "3162408282242844@naggum.no",
          "subject": "Re: strings and characters",
          "author_id": "erik_naggum",
          "date": "2000-03-18",
          "display_date": "03/18/2000",
          "content": "\nSubject: Re: strings and characters\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/18\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162408282242844@naggum.no>\n\n* Tim Bradshaw <tfb@cley.com>\n| This doesn't work (unless I've misunderstood you) because I can't use\n| it for the string->unsigned-byte-array case, because the strings might\n| have big characters in them.\n\n  sigh.  so read (unsigned-byte 8), smash the type code so it's a string of\n  non-big characters, and do _whatever_ you need to do with the string,\n  then smash the type code and write (unsigned-byte 8) to whatever.\n\n| It looks to me like the outcome of all this is that there isn't a\n| portable CL way of ensuring what I need to be true is true, and that I\n| need to ask vendors for per-implementation answers, and meantime punt on\n| the issue until my code is more stable.  Which are fine answers from my\n| point of view, in case anyone thinks I'm making the standard `lisp won't\n| let me do x' complaint.\n\n  portable languages are for portable problems.  conversely, non-portable\n  problems may require non-portable solutions.  I don't have a problem with\n  that, but many seem to have.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "strings_and_characters"
        },
        {
          "id": "3162477100853468@naggum.no",
          "subject": "Re: strings and characters",
          "author_id": "erik_naggum",
          "date": "2000-03-19",
          "display_date": "03/19/2000",
          "content": "\nSubject: Re: strings and characters\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/19\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162477100853468@naggum.no>\n\n* Gareth McCaughan <Gareth.McCaughan@pobox.com>\n| I'm not Barry, but I think I can.  Provided I'm allowed to use the\n| HyperSpec (which I have) rather than the Standard itself (which I don't).\n\n  note that this all hinges on the definition of STRING, not CHARACTER.\n\n  we all agree that character objects may have implementation-defined\n  attributes.  the crux of the matter is whether strings are _required_ to\n  support these implementation-defined attributes for characters stored in\n  them, or is _permitted_ only to hold simple characters, i.e., characters\n  that have null or no implementation-defined attributes.  sadly, nothing\n  you bring up affects this crucial argument.\n\n  there are two compelling reasons why implementation-defined attributes\n  are _not_ required to be retained in strings: (1) there is special\n  mention of which implementation-defined attributes are discarded when\n  reading a string literal from an input stream (which apparently may\n  support reading them, but nothing is indicated as to how this happens),\n  and (2) historically, strings did not retain bits and fonts, so if they\n  were to be supported by an implementation that conformed to CLtL1, they\n  would have to be _added_ to strings, while bits and fonts were explicitly\n  _removed_ from the language.\n\n| 1. MAKE-STRING is defined to return \"a string ... of the most\n|    specialized type that can accommodate elements of the given\n|    type\".\n| \n| 2. The default \"given type\" is CHARACTER.\n| \n| 3. Therefore, MAKE-STRING with the default ELEMENT-TYPE\n|    returns a string \"that can accommodate elements of the\n|    type CHARACTER\".\n\n  the question boils down to whether the character concept as defined in\n  isolation is the same as the character concept as defined as part of a\n  string.  if they are, your logic is impeccable.  if they aren't the same,\n  your argument is entirely moot.  I'm arguing that the crucial clue to\n  understand that there is a difference is indicated by the unique \"union\n  type\" of strings and the phrase \"or a subtype of character\" which is not\n  used of any other specialized array in the same way it is for strings --\n  no other types permit _only_ a subtype.\n\n  I'm arguing that an implementation is not required not to have a weaker\n  character concept in strings than in isolation, i.e., that strings may\n  _only_ hold a subtype of character, that implementation-defined\n  attributes are defined only to exist (i.e., be non-null) in isolated\n  character objects, and not in characters as stored in strings.\n\n| Now,\n| \n| 5. A \"string\" is defined as \"a specialized vector ... whose\n|    elements are of type CHARACTER or a subtype of type CHARACTER\".\n\n  _please_ note that no other specialized vector type is permitted the\n  leeway that \"or a subtype of\" implies here.  for some bizarre reason, the\n  bad imitation jerk from Harlequin thought that he could delete \"of type\n  CHARAACTER\" since every type is a subtype of itself.  however, the key is\n  that this wording effectively allows a proper subtype of character to be\n  represented in strings.  a similar wording does not exist _elsewhere_ in\n  the standard, signifying increased importance by this differentiation.\n\n| 8. There is such a thing as a specialized array with elements\n|    of type CHARACTER or some subtype thereof, which is capable\n|    of holding arbitrary things of type CHARACTER as elements.\n\n  this is a contradiction in terms, so I'm glad you conclude this, as it\n  shows that carrying \"or a subtype thereof\" with you means precisely that\n  the standard does not require a _single_ string type to be able to hold\n  _all_ character values.  that is why string is a union type, unlike all\n  other types in the language.\n  \n| I'd have thought that if strings were special in the kind of way you're\n| saying they are, there would be some admission of the fact here.  There\n| isn't.\n\n  there is particular mention of \"or a subtype of character\" all over the\n  place when strings are mentioned.  that's the fact you're looking for.\n\n  however, if you are willing to use contradictions in terms as evidence of\n  something and you're willing to ignore facts on purpose, there is not\n  much that logic and argumentation alone can do to correct the situation.\n\n| I have been unable to find anything in the HyperSpec that justifies this.\n\n  again, look for \"or a subtype of character\" in the definition of STRING.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "strings_and_characters"
        },
        {
          "id": "3162506888111902@naggum.no",
          "subject": "Re: strings and characters",
          "author_id": "erik_naggum",
          "date": "2000-03-20",
          "display_date": "03/20/2000",
          "content": "\nSubject: Re: strings and characters\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/20\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162506888111902@naggum.no>\n\n* Gareth McCaughan <Gareth.McCaughan@pobox.com>\n| What about the complete absence of any statement anywhere in the standard\n| (so far as I can tell) that it's legal for storing characters in a string\n| to throw away their attributes?\n\n  what of it?  in case you don't realize the full ramification of the\n  equally completely absence of any mechanism to use, query, or set these\n  implementation-defined attributes to characters, the express intent of\n  the removal of bits and fonts were to remove character attributes from\n  the language.  they are no longer there as part of the official standard,\n  and any implementation has to document what it does to them as part of\n  the set of implementation-defined features.  OBVIOUSLY, the _standard_ is\n  not the right document to prescribe the consequences of such features!\n  an implementation, consequently, may or may not want to store attributes\n  in strings, and it is free to do or not to do so, and the standard cannot\n  prescribe this behavior.\n\n  conversely, if implementation-defined attributes were to be retained,\n  shouldn't they have an explicit statement that they were to be retaiend,\n  which would require an implementation to abide by certain rules in the\n  implementation-defined areas?  that sounds _much_ more plausible to me\n  than saying \"implementation-defined\" and then defining it in the standard.\n\n  when talking about what an implementation is allowed to do on its own\n  accord, omitting specifics means it's free to do whatever it pleases.  in\n  any requirement that is covered by conformance clauses, an omission is\n  treated very differently: it means you can't do it.  we are not talking\n  about _standard_ attributes of characters (that's the code, and that's\n  the only attribute _required_ to be in _standard_ strings), but about\n  implementation-defined attributes.\n\n| I don't see why #1 is relevant. #2 is interesting, but the language is\n| defined by what the standard says, not by what it used to say.\n\n  it says \"implementation-defined attributes\" and it says \"subtype of\n  character\", which is all I need to go by.  you seem to want the standard\n  to prescribe implementation-defined behavior.  this is an obvious no-go.\n\n  it is quite the disingenious twist to attempt to rephrase what I said as\n  \"what the standard used to say\", but I'm getting used to a lot of weird\n  stuff from your side already, so I'll just point out to you that I'm\n  referring to how it came to be what it is, not what it used to say.  if\n  you can't see the difference, I can't help you understand, but if you do\n  see the difference, you will understand that no standard or other\n  document written by and intended for human beings can ever be perfect in\n  the way you seem to expect.  expecting standards to be free of errors or\n  of the need of interpretation by humans is just mind-bogglingly stupid,\n  so I'm blithly assuming that you don't hold that view, but instead don't\n  see that you are nonetheless flirting with it.\n\n| The point here is simply that there can be several different kinds of\n| string.  The standard says that there may be string types that only\n| permit a subtype of CHARACTER; it doesn't say that there need be no\n| string type that permits CHARACTER itself.\n\n  sigh.  the point I'm trying to make is that it doesn't _require_ there to\n  be one particular string type which can hold characters with all the\n  implementation-defined attributes.\n\n|    (make-array 10 :element-type 'character)   [S]\n|    (make-string 10 :element-type 'character)  [S']\n| \n| Therefore S and S' are arrays of the same type.\n\n  sorry, this is a mere tautology that brings nothing to the argument.\n\n| Therefore there is at least one string (namely S) that can hold arbitrary\n| characters.\n\n  but you are not showing that it can hold arbitrary characters.  _nothing_\n  in what you dig up actually argues that implementation-defined attributes\n  have standardized semantics.  an implementation is, by virtue of its very\n  own definition of the semantics, able to define a character in isolation\n  as having some implementation-defined attributes and strings to contain\n  characters without such implementation-defined attributes.  this is the\n  result of the removal of the type string-char and the subsequent merging\n  of the semantics of character and string-char.\n\n| It doesn't require *every* string type to be able to hold all character\n| values.  It does, however, require *some* string type to be able to hold\n| all character values.\n\n  where do you find support for this?  nowhere does the standard say that a\n  string must retain implementation-defined attributes of characters.  it\n  does say that the code attribute is the only standard attributes, and it\n  is obvious that that attribute must be retained wherever.  it is not at\n  all obvious that implementation-defined attributes must survive all kinds\n  of operations.\n\n  you've been exceedingly specific in finding ways to defend your position,\n  but nowhere do you find actual evidence of a requirement that there exist\n  a string type that would not reject at least some character objects.  I'm\n  sorry, but the premise that some string type _must_ be able to hold _all_\n  characters, including all the implementation-defined attributes that\n  strings never were intended to hold to begin with, is no more than\n  unsupported wishful thinking, but if you hold this premise as axiomatic,\n  you won't see that it is unsupported.  if you discard it as an axiom and\n  then try to find support for it, you find that you can't -- the language\n  definition is sufficiently slippery that these implementation-defined\n  attributes don't have any standard-prescribed semantics for them at all,\n  including giving the implementation leeway to define their behavior,\n  which means: not _requiring_ anything particular about them, which means:\n  not _requiring_ strings to retain them, since that would be a particular\n  requirement about an implementation-defined property of the language.\n  \n| The reason why STRING is a union type is that implementors might want to\n| have (say) an \"efficient\" string type that uses only one byte per\n| character, for storing \"easy\" strings.  Having this as well as a type\n| that can store arbitrary characters, and having them both be subtypes of\n| STRING, requires that STRING be a union type.\n\n  now, this is the interesting part.  _which_ string would that be?  as far\n  as I understand your argument, you're allowing an implementation to have\n  an implementation-defined standard type to hold simple characters (there\n  is only one _standard_ attribute -- the code), while it is _required_ to\n  support a wider _non-standard_ implementation-defined type?  this is\n  another contradiction in terms.  either the same requirement is standard\n  or it is implementation-defined -- it can't be both a the same time.\n\n  I quote from the character proposal that led to the changes we're\n  discussing, _not_ to imply that what isn't in the standard is more of a\n  requirement on the implementation than the standard, but to identify the\n  intent and spirit of the change.  as with any legally binding document,\n  if you can't figure it out by reading the actual document, you go hunting\n  for the meaning in the preparatory works.  luckily, we have access to the\n  preparatory works with the HyperSpec.  it should shed light on the\n  wording in the standard, if necessary.  in this case, it is necessary.\n\nRemove all discussion of attributes from the language specification.  Add\nthe following discussion:\n\n   ``Earlier versions of Common LISP incorporated FONT and BITS as\n     attributes of character objects.  These and other supported\n     attributes are considered implementation-defined attributes and\n     if supported by an implementation effect the action of selected\n     functions.''\n\n  what we have is a standard that didn't come out and say \"you can't retain\n  bits and fonts from CLtL1 in characters\", but _allowed_ an implementation\n  to retain them, in whatever way they wanted.  since the standard removed\n  these features, it must be interpreted relative to that (bloody) obvious\n  intent if a wording might be interpreted by some that the change would\n  require providing _additional_ support for the removed features -- such\n  an interpretation _must_ be discarded, even if it is possible to argue\n  for it in an interpretative vacuum, which never exists in any document\n  written by and for human beings regardless of some people's desires.\n  (such a vacuum cannot even exist in mathematics -- which reading a\n  standard is not an exercise in, anyway -- any document must always be\n  read in a context that supplies and retains its intention, otherwise\n  _human_ communication breaks down completely.)\n  \n#:Erik\n\n",
          "references": [],
          "thread_id": "strings_and_characters"
        },
        {
          "id": "3162629683063483@naggum.no",
          "subject": "Re: strings and characters",
          "author_id": "erik_naggum",
          "date": "2000-03-21",
          "display_date": "03/21/2000",
          "content": "\nSubject: Re: strings and characters\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/21\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162629683063483@naggum.no>\n\n* Barry Margolin <barmar@bbnplanet.com>\n| Wouldn't those characters be of type CHARACTER?  Mustn't a vector\n| specialized to type CHARACTER be able to hold all objects of type\n| CHARACTER?  Isn't such a vector a subtype of STRING?\n\n  what was the _intent_ of removing string-char and making fonts and bits\n  implementation-defined?  has that intent been carried forward all the way?\n\n| Where does the standard ever give license for a value to change during\n| assignment?\n\n  16.1.2 Subtypes of STRING, and I qoute:\n\nHowever, the consequences are undefined if a character is inserted into a\nstring for which the element type of the string does not include that\ncharacter.\n  \n| Well, I was there and you weren't, so I think I can comment on the intent,\n| to the best of my recollection.\n\n  that's appreciated, but I must say I find \"I was there and you weren't\"\n  to be amazingly childish as \"arguments\" go.\n\n| What we wanted to remove from the standard were the API and UI that dealt\n| with the nature of specific attributes.  We didn't want to distinguish\n| these specific attributes (bits and fonts), which often didn't make sense\n| in many implementations or applications.  But I don't think we intended\n| to destroy the notion that attributes are part of the objects, and are\n| thus included in assignments just like any attributes and slots of other\n| data types.  They could get lost during I/O, due to the fact that the\n| language can't specify the nature of external file formats, but as long\n| as you stay within the Lisp environment they should stick.\n\n  perhaps you, who were presumably there for the duration, could elaborate\n  on the intended _consequences_ of the removal of the string-char type and\n  the change to strings from being made up of a subtype of character that\n  explicitly excluded fonts and bits to a character type that didn't need\n  to include fonts and bits?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "strings_and_characters"
        },
        {
          "id": "3162628727290082@naggum.no",
          "subject": "Re: strings and characters",
          "author_id": "erik_naggum",
          "date": "2000-03-21",
          "display_date": "03/21/2000",
          "content": "\nSubject: Re: strings and characters\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/21\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162628727290082@naggum.no>\n\n* Gareth McCaughan <Gareth.McCaughan@pobox.com>\n| Well, this is an argument. To paraphrase (and I'm sure you'll tell me if\n| this is misleading), \"The behaviour of implementation- -defined things is\n| implementation-defined\". The trouble is that this proves too much -- if\n| the implementation-defined-ness of character attributes other than the\n| CODE means that implementations are allowed to throw them away when\n| characters are stored in strings, I don't see why it shouldn't also mean\n| that implementations are allowed to throw them away when you bind them to\n| variables, or put them in lists.\n\n  you don't see that?  well, I can't help you see that, then.  let me just\n  reiterate what I have previously said: a regular array with element-type\n  t can hold any character object.  if you insist on being silly, however,\n  there's nothing I can do to prevent this from going completely wacky.\n\n| No, I don't want the standard to prescribe implementation-defined\n| behaviour. I just don't think that \"implementation-defined\n| attributes\" means \"mysterious things whose semantics may be\n| entirely inconsistent with everything in this standard\".\n\n  that is your interpretation, Gareth, and I claim it's unsupported by\n  facts, but ever more supported by silliness and \"I don't see why\"'s.\n  now, I do see how you are reaching your conclusion, I just don't accept\n  that you have refuted the one thing I'm still claiming: that the standard\n  _requires_ there to be a specialized array (string) that must be able to\n  hold all character objects.  since you're going into silly mode, I can\n  only guess that you don't understand my argument and have to ridicule it.\n\n  and let me just say that an implementation that chooses to allow strings\n  to hold all attributes is obviously just as conforming as one that only\n  has strings that holds the code attribute.\n\n| I don't know why you think I expect the standard to be perfect.\n\n  because you use it as the basis of proofs that you expect to be\n  universally valid without recognizing your own interpretative work\n  (including omitting irrelevant points that seem irrelevant to you) in\n  constructing them.  the confidence in perfection required to do this is\n  quite staggering.\n\n| I do think that my interpretation is more natural than yours, and that\n| the amount of error the standard would have to contain if your view were\n| right is considerably more than the amount it would have to contain if\n| mine were right.  Both of these (plus the fact that it seems on the whole\n| to have very few errors) lead me to prefer my view to yours.\n\n  this, however, is a valid line of argument.  I just happen to disagree.\n\n| That observation is there for a picky pedantic reason: that I want to\n| make it explicit not only that there are things capable of holding\n| arbitrary characters, but that those things are actually strings in the\n| sense defined in the standard.\n\n  and I have already pointed out that the union type does not contain the\n  individiual type that is _required_ to hold all characters.  to get that,\n  you have to upgrade the element-type to t.\n\n| Clearly you consider my deduction flawed.  You haven't, though, said\n| what's wrong with it.\n\n  yes, I have.  I have pointed out that it ignores several important\n  factors that affect how you can interpret the standard.  in particular,\n  that the requirement you come up with _adds_ additional burden to an\n  implementation that decides to continue to support implementation-defined\n  attributes above and beyond what it needed to do before they were removed\n  from the standard.  this is clearly a serious mismatch between intent and\n  expression, and we need to understand the intent behind the standard when\n  it seems to say something that isn't very smart.\n\n| That's borne out by Barry Margolin's recollections of the discussions of\n| the standardising committee.\n\n  for some reason, I have yet to see those posted to the newsgroup.  if you\n  could mail them to me, I'd be much obliged.\n\n| My interpretation of the standard doesn't make it require anyone to add\n| support for the removed features.\n\n  now, this is just plain ridiculous or unbelievably ignorant.\n\n  strings in CLtL1 were made up of string-char elements, not character.\n  string-char explicitly excluded fonts and bits attributes.  now that\n  string-char has been removed, and you claim strings have to contain the\n  whole character type, and not only a subtype, as I claim, the string that\n  used to be able to contain only the code attribute, now has to be able to\n  contain characters _with_ implementation-defined attributes, as well.\n  this is NOT A QUIET CHANGE to the implementation -- it has a really major\n  impact on system storage requirements.  this fact, however, is recognized\n  in the reader for strings (which may dump attributes at will, however\n  they wound up in the characters read from an input stream) and intern\n  (which may also dump them at will, regardless of how they could get into\n  the string to begin with).\n\n  clearly, you don't understand the implications of what you interpret the\n  standard to say if you don't understand that it forces an implementation\n  to _add_ support for a feature the standard effectively deprecates.\n  \n#:Erik\n\n",
          "references": [],
          "thread_id": "strings_and_characters"
        }
      ],
      "post_count": 14,
      "first_post_date": "2000-03-16",
      "last_post_date": "2000-03-21"
    },
    {
      "id": "search_&_replace_in_sequences",
      "title": "Search & Replace in sequences",
      "posts": [
        {
          "id": "3162509869683633@naggum.no",
          "subject": "Re: Search & Replace in sequences",
          "author_id": "erik_naggum",
          "date": "2000-03-20",
          "display_date": "03/20/2000",
          "content": "\nSubject: Re: Search & Replace in sequences\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/20\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162509869683633@naggum.no>\n\n* Rudolf Schlatte\n| This works ok and the program does not have to run fast or anything, but\n| all this repeated string-building just feels wrong for me.  Are there\n| more concise ways of writing this?\n\n  yes, use with-output-to-string and write characters and strings to the\n  string stream with stream primitives like write-char and write-string.\n  the underlying buffering mechanism is very well optimized for growing\n  strings, which is what you are doing in an excessively expensive way.\n\n  C and Perl don't have string streams, so every C and Perl programmer\n  thinks in-memory string processing is more efficient than streams and\n  that you always benefit from doing your own buffering algorithm.  neither\n  is, was, or will become true.  languages shape the way we think, or don't.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "search_&_replace_in_sequences"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-03-20",
      "last_post_date": "2000-03-20"
    },
    {
      "id": "who_used_the_\"d\"_word?",
      "title": "Who used the \"D\" word?",
      "posts": [
        {
          "id": "3162003144761655@naggum.no",
          "subject": "Re: Who used the \"D\" word?",
          "author_id": "erik_naggum",
          "date": "2000-03-14",
          "display_date": "03/14/2000",
          "content": "\nSubject: Re: Who used the \"D\" word?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/14\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162003144761655@naggum.no>\n\n* \"Coby Beck\" <cbeck@mercury.bc.ca>\n| Personal attacks are NEVER productive.\n\n  then why don't you guys ever _start_ moralizing against the provokers,\n  only against the _other_ people who react to them?  don't you understand\n  that in the eyes of the village idiots, you're defending them, and very\n  much _encouraging_ further mindless drivel and braindamaged chit-chat?\n  why do you want more of that, Coby?  is this newsgroup served better by\n  your (and a few other people's) moralizing in defense of inanities than\n  the occasional personal attack against which you, TOO, have to speak up\n  to voice that ever-important concern about form and behavior?\n\n  moralizers can follow their own advice: take it to e-mail, shut up, or\n  ignore it.  if _you_ can't do that, don't ever expect anyone else to.\n\n  stick to _technical_ contents and _cut_ the meta-discussions, will you?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "who_used_the_\"d\"_word?"
        },
        {
          "id": "3162156255970575@naggum.no",
          "subject": "Re: Who used the \"D\" word?",
          "author_id": "erik_naggum",
          "date": "2000-03-16",
          "display_date": "03/16/2000",
          "content": "\nSubject: Re: Who used the \"D\" word?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/16\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162156255970575@naggum.no>\n\n* Coby Beck <cbeck@mercury.bc.ca>\n| This is rather ironic considering the source.\n\n  it's stuff like \"considering the source\" that defines \"ad hominem\", dude.\n\n  don't you at least find it kinda funny that you're the one committing\n  this error in argument while you're _pretending_ to be concerned about\n  proper form and expression?  you know, here's my understanding of why you\n  react: it has to be \"unpleasant\" for you to react to something, while\n  \"pleasant\" insults and ad hominems are perfectly OK, indeed so OK that\n  you find yourself more than willing to use them to \"fight\" unpleasantness.\n\n| But i don't think a certain level of meta-discussion is out of line when\n| so many very bad feelings fly around in any group of people.\n\n  be a smart lad, now, and consider the _overwhelming_ probability that the\n  \"bad feelings\" _you_ see are figments of _your_ imagination and artefacts\n  of how _you_ interact with the world and thus imagine that others do,\n  too.  basically, the only serious mistake you can make about other people\n  is to believe you can put yourself in their place.  moralism is all about\n  making this mistake and being self-righteous about it.\n\n  a piece of advice, though, since you're into this bad feelings business:\n  just because you, a bystander, feel obliged to feel bad on behalf of\n  someone else, doesn't mean anyone else is actually feeling anything like\n  you do, particularly not anyone who is actually _involved_ in what you're\n  just looking at and not understanding because you're responding to them\n  by _purely_ emotional means (which is, before you deny it, evidenced by\n  the lack of _anything_ outside of your displeasure with the form that\n  causes your negative reactions).  you thereby _introduce_ bad feelings\n  into this frail equilibrium.  which is really brilliant, since it proves\n  your point and virtually removes the possibility of proving you wrong,\n  which moralists get _so_ immensely upset when they are, which makes them\n  even more eager to project their dismal world view on everybody else.\n  \n#:Erik\n\n",
          "references": [],
          "thread_id": "who_used_the_\"d\"_word?"
        },
        {
          "id": "3162224372338902@naggum.no",
          "subject": "Re: Who used the \"D\" word?",
          "author_id": "erik_naggum",
          "date": "2000-03-16",
          "display_date": "03/16/2000",
          "content": "\nSubject: Re: Who used the \"D\" word?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/16\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162224372338902@naggum.no>\n\n* \"Coby Beck\" <cbeck@mercury.bc.ca>\n| i don't believe for one second\n\n  and I don't care for one second what you \"believe\" or not, Coby. the\n  reason is this one line:\n\n| Again, you cannot possibly be sincere.\n\n  ... which tells people more about you than you should ever have wished to\n  tell _anyone_.  some day, you'll understand why it matters that you shift\n  from \"I don't believe\" to \"you cannot be sincere\", and then you'll stop\n  moralizing in the name of avoiding personal attacks while engaging in the\n  most hypocritical activities seen here for a very long time.  good luck\n  with your unusual opportunity to learn something fundamental about ethics.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "who_used_the_\"d\"_word?"
        }
      ],
      "post_count": 3,
      "first_post_date": "2000-03-14",
      "last_post_date": "2000-03-16"
    },
    {
      "id": "acl_bug_(was:_re:_series_2.1_released)",
      "title": "ACL bug (was: Re: Series 2.1 released)",
      "posts": [
        {
          "id": "3162224605441717@naggum.no",
          "subject": "Re: ACL bug (was: Re: Series 2.1 released)",
          "author_id": "erik_naggum",
          "date": "2000-03-16",
          "display_date": "03/16/2000",
          "content": "\nSubject: Re: ACL bug (was: Re: Series 2.1 released)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/16\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162224605441717@naggum.no>\n\n* Lieven Marchand <mal@bewoner.dma.be>\n| The problem is in the closure that gets stored in the gen-fn field of\n| the series struct. It goes wrong for every use of MASK. Anyway, the\n| patch had to work at that level too, so I had to make sure my changes\n| to defS MASK had the correct effect.\n\n  I'm curious about all this work you're putting in.  have you bothered to\n  alert bugs@franz.com with a test case so they could fix it and you could\n  do something more useful with your life?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "acl_bug_(was:_re:_series_2.1_released)"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-03-16",
      "last_post_date": "2000-03-16"
    },
    {
      "id": "stupid_question_regarding_#",
      "title": "stupid question regarding #",
      "posts": [
        {
          "id": "3162108567548247@naggum.no",
          "subject": "Re: stupid question regarding #",
          "author_id": "erik_naggum",
          "date": "2000-03-15",
          "display_date": "03/15/2000",
          "content": "\nSubject: Re: stupid question regarding #\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/15\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162108567548247@naggum.no>\n\n* Richard James Panturis Giuly <rgiuly@surfsouth.com>\n| In the context of lisp, what is the pronunciation of the # symbol?  That\n| is, what do you call it?\n\n  in the ANSI standard, it is called \"number sign\", which is the official\n  nomenclature of the standards bodies, or \"sharpsign\".\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "stupid_question_regarding_#"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-03-15",
      "last_post_date": "2000-03-15"
    },
    {
      "id": "testing_approaches",
      "title": "Testing approaches",
      "posts": [
        {
          "id": "3162005254869991@naggum.no",
          "subject": "Re: Testing approaches",
          "author_id": "erik_naggum",
          "date": "2000-03-14",
          "display_date": "03/14/2000",
          "content": "\nSubject: Re: Testing approaches\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/14\nNewsgroups: comp.lang.lisp\nMessage-ID: <3162005254869991@naggum.no>\n\n* Ray Blaak <blaak@infomatch.com>\n| For example, how many kinds of invalid values can you pass to a function?\n| A string, an atom, a list, a vector, a float, an integer,... If your\n| function was restricted to integers, say, then you could simply\n| concentrate on the invalid integer values.\n\n  (check-type <argument> <restricted-type>) takes care of this one for you,\n  or you can use assert or throw your own errors if you really have to.  I\n  don't see the problem.  writing safe code isn't hard in Common Lisp.\n\n| Static typing is dramatically useful in integration tests.  A unit test\n| will not exhaustively exercise other units.  Static typing allows units\n| to fit together without the piles of dumb stupid interface errors,\n| allowing you to concentrate on the smart stupid logic errors :-).\n\n  when the compiler stores away the type information, this may be true.\n  when the programmers have to keep them in sync manually, it is false.\n\n  static typing is like a religion: it has no value outside the community\n  of believers.  inside the community of believers, however, it is quite\n  impossible to envision a world where static types do not exist, and they\n  think in terms that restrict their concept of \"type\" to that which fits\n  the static typing religion.\n\n  to break out of the static typing faith, you have to realize that there\n  is nothing conceptually different between an object of type t that holds\n  a value you either know or don't know how to deal with, and an object of\n  a very narrow type that holds a value you either know or don't know how\n  to deal with.  the issue is really programming pragmatics.  static typing\n  buys you exactly nothing over dynamic typing when push comes to shove.\n  yes, it does buy you something _superficially_, but look beneath it, and\n  you find that _nothing_ has actually been gained.  the bugs you found are\n  fixed, and the ones you didn't find aren't fixed.  the mistakes you made\n  that escaped the testing may differ very slightly in expression, but they\n  are still there.  the mistakes you did find may also differ slightly in\n  expression, but they are still gone.  what did you gain by believing in\n  static typing?  pain and suffering and a grumpy compiler.  what did you\n  gain by rejecting this belief and understanding that neither humans nor\n  the real world fits the static typing model?  freedom of expression!  of\n  course, it comes with a responsibility, but so did the static typing,\n  only the dynamic typing responsibility is not to abuse freedom, while the\n  static typing responsibility is not to abuse the power of restriction.\n\n  personally, I think this is _actually_ a personality issue.  either you\n  want to impose control on your environment and believe in static typing,\n  or you want to understand your environment and embrace whatever it is.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "testing_approaches"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-03-14",
      "last_post_date": "2000-03-14"
    },
    {
      "id": "referential_transparency_support_missing",
      "title": "Referential transparency support missing",
      "posts": [
        {
          "id": "3161959623274993@naggum.no",
          "subject": "Re: Referential transparency support missing",
          "author_id": "erik_naggum",
          "date": "2000-03-13",
          "display_date": "03/13/2000",
          "content": "\nSubject: Re: Referential transparency support missing\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/13\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161959623274993@naggum.no>\n\n* Pekka P. Pirinen\n| I rather like the idea of having a way to say \"this function\" in\n| declaration lists (since we have anonymous functions):\n|   (lambda (x)\n|     (declare (pure self))\n|     (+ 2 x))\n\n  `lambda' seems to me a much better choice than `self'.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "referential_transparency_support_missing"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-03-13",
      "last_post_date": "2000-03-13"
    },
    {
      "id": "feature_allocation",
      "title": "Feature allocation",
      "posts": [
        {
          "id": "3161810369666971@naggum.no",
          "subject": "Re: Feature allocation",
          "author_id": "erik_naggum",
          "date": "2000-03-12",
          "display_date": "03/12/2000",
          "content": "\nSubject: Re: Feature allocation\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/12\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161810369666971@naggum.no>\n\n* \"Fernando D. Mato Mira\" <matomira@iname.com>\n| #+(or :cmu :sbcl)\n| (cl:eval-when (load eval compile)\n|   (cl:pushnew :pittsburgh cl:*features*))\n| \n| OK?\n\n  it seems counterintuitive and random, as in \"project code name\".\n\n  what is it _really_ supposed to identify?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "feature_allocation"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-03-12",
      "last_post_date": "2000-03-12"
    },
    {
      "id": "newbie_lisp_question",
      "title": "newbie Lisp question",
      "posts": [
        {
          "id": "3161565178384561@naggum.no",
          "subject": "Re: newbie Lisp question",
          "author_id": "erik_naggum",
          "date": "2000-03-09",
          "display_date": "03/09/2000",
          "content": "\nSubject: Re: newbie Lisp question\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/09\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161565178384561@naggum.no>\n\n* Robert Monfera <monfera@fisec.com>\n| When is it encouraged to put together symbol names though?  By default,\n| DEFSTRUCT produces a host of functions with glued names, but it isn't\n| common in CL.\n| \n| Is it an indication that automagical function (or whatever) creation with\n| glued names is rarely encouraged?  Any examples when it's the best way of\n| achieving something other than system integration?\n\n  recently, I wrote that making some concepts hard to express didn't cause\n  people to suffer from having to express them, but made the concepts\n  suffer because they would be underutilized.  humans, falling prey to the\n  siren song of convenience, will always think this way.  therefore, the\n  languages we use must make smart concepts convenient to express and dumb\n  concepts inconvenient to express.  the natural tendency is the opposite.\n\n(intern (concatenate 'string (symbol-name #:make-) (symbol-name symbol))\n        (symbol-package symbol))\n\n  will return a new symbol prefixed with \"make-\" in the same package as the\n  symbol without the prefix (thanks for that careful bit, Pierre), but is\n  this hard to read?  is it a lot of \"internal stuff\" that people shouldn't\n  ned to worry about?  I dont' think so.  I think this is the smallest you\n  can do, short of writing a function specifically to glue symbol names\n  that does all this, but think about its hypothetical interface for a\n  second: it would naturally want two symbols, but which one is prefix and\n  which one is suffix?  (resist the temptation to search for the hyphen!)\n  so either you get two functions or you supply the package separately, or\n  perhaps you think you could supply one string and one symbol, but either\n  way, you have caused the user of your function to exercise a lot more\n  brainpower on your symbol-glue function than on the expression above,\n  which should be a no-brainer for an experienced Common Lisp programmer in\n  a way the symbol-glue functions wouldn't be because they are infrequently\n  used.  and if they aren't infrequently used, we're back to Robert's\n  question: should we encourage this?  I don't think we should, either, so\n  it would be bad if it were too convenient to do it.\n\n  FORMAT is clearly in the \"too convenient\" camp, since it makes doing it\n  the wrong way so convenient, and burdens the user with case conversion\n  issues in the reader and the printer at the same time.\n\n  but consider a More Common Lisp that does no case conversion in the\n  reader or the printer (which is more common than doing it, hence my\n  punnish name), with what-you-see-is-what-you-get symbol names:\n\n(intern (format nil \"make-~a\" symbol) (symbol-package symbol))\n\n  consider all the idiomatic stuff we got rid of: either an uninterned or\n  keyword symbol just to get the symbol name right or an upper-case prefix\n  string literal, and extracting the symbol-name part.  this idiomatic\n  burden is a no-brainer to an experienced Common Lisp programmer, but\n  _acquiring_ the expertise so it becomes a no-brainer is not effortless at\n  all, and probably involves struggling and lots of confusion until the\n  full ramifications of Common Lisp's attitude to case are internalized.\n\n  so instead of encouraging the convenient creation of symbols, we have an\n  elaborate scheme to discourage people from looking at symbol names and\n  only use the symbols as symbols, but this works directly against the work\n  needed to acquire the expertise in using them correctly!  since symbols\n  is very powerful abstraction mechanism, and case conversion is also a\n  very powerful mechanism in human communication (it has definite value,\n  but by informed choice, not default), we've forced ourselves out on a\n  limb every time we have to deal with them, and some are worrying that any\n  proposal to fix this is akin to cutting the limb on the dumb side.  this\n  is a case of making a smart concept cumbersome to express, and forces us\n  to consider more convenient options merely for the sake of convenience --\n  it should have been _sufficiently_ convenient to begin with not to have\n  to worry about case conversion details.\n\n  let's find a way to make Common Lisp work with readtable-case :preserve\n  and lower-case symbol names, so what-you-see-is-what-you-get-ness is also\n  preserved for experienced and novice programmer alike, and we can do\n  smart stuff without having to be too clever, too.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "newbie_lisp_question"
        },
        {
          "id": "3161562827781681@naggum.no",
          "subject": "Re: newbie Lisp question",
          "author_id": "erik_naggum",
          "date": "2000-03-09",
          "display_date": "03/09/2000",
          "content": "\nSubject: Re: newbie Lisp question\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/09\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161562827781681@naggum.no>\n\n* Pierre R. Mai\n| Backquote only works for putting together lists, it doesn't know\n| anything about symbols or other data-structures.\n\n  backquote works on sequences, which includes vectors and lists.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "newbie_lisp_question"
        },
        {
          "id": "3161707555093615@naggum.no",
          "subject": "Re: newbie Lisp question",
          "author_id": "erik_naggum",
          "date": "2000-03-10",
          "display_date": "03/10/2000",
          "content": "\nSubject: Re: newbie Lisp question\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/10\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161707555093615@naggum.no>\n\n* Tim Bradshaw <tfb@cley.com>\n| But I think that there *are* advantages to case-insensitive readers.\n| Specifically, case-sensitive languages seem to be vulnerable to the\n| drEadEd studlycaps vIrUs.  C seems to be badly infected with this despite\n| having grown up with powerful Unix antibodies, and I think C++ was born\n| with it (Java too I guess).\n\n  the studlycaps infection is a serious issue.  however, I think it grew\n  out of the stupid way symbols are constructed in some languages, with a\n  fixed set of characters available in symbol names and everything else\n  being \"parsed\" as operators and whatnot, causing people to get scared of\n  anything that looks like blank spaces.  underscores, in particular, are\n  used much like \"visible blanks\", but they look so ugly it's no wonder\n  people don't use them.  if you aren't afraid of what might look like an\n  operator, foo-bar-zot beats foo_bar_zot hands down any day, but if you\n  are afraid of operator look-alikes, you need fooBarZot to feel \"safe\".\n\n| While I appreciate that CL probably does need to talk with these infested\n| languages, and thus presumably will in due course become fully studly\n| itself, I find the prospect sad.\n\n  I don't think this will happen, but I think it's _less_ likely to happen\n  with a lower-case Lisp than an upper-case Lisp.  the reason may seem\n  counter-intuitive, but here goes: in an upper-case Lisp, getting symbols\n  right is just too difficult for mere mortals (more so when using anything\n  other than readtable-case :upcase), so to get them right, people resort\n  to various hacks, the _best_ of which is using strings to refer to the\n  foreign object and a symbol to hold onto the reference in the Lisp world,\n  but that's comparatively inconvenient, and the symbol won't be _created_\n  from the foreign name, for the obvious reasons.  in a lower-case Lisp,\n  you _may_ use the symbol directly, but now it has disadvantages that you\n  can see, because they aren't overshadowed by the _disadvantages_ of\n  case-mangling in Common Lisp, so you can see the _advantages_ of using\n  strings to name foreign objects with funny names, _plus_ you get the\n  predictable results when you try to create the symbol-name yourself.\n  thus, an upcasing Lisp will present self-defeating inconveniences that\n  completely destroy the advantages of case-insensitivity, while a case-\n  preserving lower-case Lisp will present _encouragement_ to use the much\n  richer set of available symbol names, instead of the stupid names that\n  particularly Windowsized C++ use to look like mangled symbol names even\n  before the C++ mangler gets at them.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "newbie_lisp_question"
        }
      ],
      "post_count": 3,
      "first_post_date": "2000-03-09",
      "last_post_date": "2000-03-10"
    },
    {
      "id": "inline_functions_(was:_eureka!_lexical_bindings_ca",
      "title": "Inline Functions (was: Eureka! Lexical bindings can be guaranteed!)",
      "posts": [
        {
          "id": "3161689163232394@naggum.no",
          "subject": "Re: Inline Functions (was: Eureka! Lexical bindings can be guaranteed!)",
          "author_id": "erik_naggum",
          "date": "2000-03-10",
          "display_date": "03/10/2000",
          "content": "\nSubject: Re: Inline Functions (was: Eureka! Lexical bindings can be guaranteed!)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/10\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161689163232394@naggum.no>\n\n* Robert Monfera <monfera@fisec.com>\n| As long as the inter-dependency of named functions is known, it would be\n| possible to propagate the invalidation of old definitions and recompile\n| with the new ones.  This may admittedly lead to avalanche effect, and I\n| don't know how to trigger recompilation of closures without some\n| heavyweight administration though.\n\n  the granularity that we get for free when redefining normal, non-inlined\n  functions should thus be eminently implementable, but there are no such\n  systems around.  there aren't even any systems around that automatically\n  recompile functions which use macros that have changed, and that's a much\n  more acute problem.\n\n  in some circumstances, there's a need to upgrade a bunch of functions to\n  the next generation en bloc, preserving calls within the older generation\n  to avoid version skew, but this kind of version control is unavailable.\n\n  what makes you think something like what you propose would be available?\n\n| Inlining reduces debuggability, but reporting accuracy is already\n| reduced at high speed optimization settings, and inlining built-in\n| functions is one of the several existing and valid reasons.\n\n  but users don't generally debug built-in functions.\n\n| Yes, but isn't this effect the same for compiler macros if you use them\n| for the same purpose?\n\n  no, and this is the crucial difference between compiler macros and\n  inlining.  a compiler macro can decide to punt on the expansion, which\n  causes a normal function call.  a compiler macro can also decide to\n  redirect the function call to some other function, or handle part of the\n  function call and punt on the rest.  this means that you have make an\n  informed choice about the expansion.  you don't have that choice in an\n  inlined function's expansion.q\n\n| Do you think that it's too easy to declare a function inlined, and it's a\n| good idea to make this non-trivial concept a little harder by having to\n| use compiler macros?\n\n  since it doesn't help to declare it inline in Allegro CL, I haven't\n  noticed the problem, and in any case, I agree with the decision not to\n  honor inline declarations.  languages that require such features are\n  typically unable to provide meaningful alternatives -- something Common\n  Lisp actually does.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "inline_functions_(was:_eureka!_lexical_bindings_ca"
        },
        {
          "id": "3161640508185948@naggum.no",
          "subject": "Re: Inline Functions (was: Eureka! Lexical bindings can be guaranteed!)",
          "author_id": "erik_naggum",
          "date": "2000-03-10",
          "display_date": "03/10/2000",
          "content": "\nSubject: Re: Inline Functions (was: Eureka! Lexical bindings can be guaranteed!)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/10\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161640508185948@naggum.no>\n\n* Coby Beck\n| What are the hazards of inlining functions?\n\n1 version disparity upon redefinition\n2 reduced accuracy in reporting errors in the debugger\n3 code bloat\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "inline_functions_(was:_eureka!_lexical_bindings_ca"
        }
      ],
      "post_count": 2,
      "first_post_date": "2000-03-10",
      "last_post_date": "2000-03-10"
    },
    {
      "id": "eureka!_lexical_bindings_can_be_guaranteed!",
      "title": "Eureka! Lexical bindings can be guaranteed!",
      "posts": [
        {
          "id": "3161442459191997@naggum.no",
          "subject": "Re: Eureka! Lexical bindings can be guaranteed!",
          "author_id": "erik_naggum",
          "date": "2000-03-07",
          "display_date": "03/07/2000",
          "content": "\nSubject: Re: Eureka! Lexical bindings can be guaranteed!\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/07\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161442459191997@naggum.no>\n\n* Andrew Cooke <andrew@andrewcooke.free-online.co.uk>\n| This is a serious question, and not meant to trigger a flame-fest, so\n| maybe it's best answered and asked (sorry) be email.  Here goes...\n\n  it's a contentious issue because there's no relevant research to support\n  the static-typing crowd, yet they have an \"intuitive edge\" that is very\n  hard both to defend formally and to attack informally.  it's like arguing\n  against adults needing milk.  (we don't.  really.)\n\n| While I like Lisp a lot, it strikes me that a statically typed language\n| might be preferable in extreme reliability situations (I'm thinking of\n| ML, for example).  Is that an issue in your experience, and how do you\n| defend Lisp against that criticism?\n\n  in my current setting, which is somewhat more down to earth than NASA's\n  lofty projects despite dealing with financial news distribution, handling\n  errors _gracefully_ has virtually defined the success of the project,\n  which is expanding and providing new services at increasing speed.  the\n  reason explicitly cited has been that the old system that mine replaced\n  died completely and randomly when a component died, while mine stops in a\n  state that is usually continuable right away and never fatal.  running a\n  production system under Emacs under screen may seem rather odd to the old\n  batch-oriented school, but what it means is that I can connect to the\n  Emacs process controlling Allegro CL and examine the system state, talk\n  to background debugging streams, and fix whatever goes wrong if the\n  system hiccups in any way, which it has so far done only with really\n  weird input from the outside world.\n\n  to obtain this level of gracefulness in one of the usual statically typed\n  languages would have required _massive_ amounts of code, simply because\n  you can't combine the dynamism with static typing without recompiling,\n  since _only_ the compiler is privy to the type information.\n\n  conversely, if you need all the type information hanging around at\n  run-time, anyway, why not make _full_ use of it?  sadly, the static\n  typing crowd believes this is inefficient because they never had to make\n  it perform optimally, using their static typing the proof that it is so\n  much easier to do it compile-time, but that only proves they never spent\n  the effort to make it fast at run-time.\n\n  incidentally, my main gripe with static typing is when it is explicit.\n  implicit static typing (like type inference) has a bunch of specific\n  advantages over both dynamic and explicitly typed languages, but in\n  general fall short in terms of dynamism on one hand and the programmer's\n  ability to predict what the system is doing on the other.\n  \n| (In my very limited opinion I get the impression that static checking has\n| improved a lot recently (but it may be that this is decade old work that\n| has stalled) and that a statically typed language with flexibility\n| approaching that of Lisp might be possible - that's a separate issue\n| since you are dealing with existing languages, but is teh background to\n| my question).\n\n  I think it's important to differentiate not on the basis of what the\n  compiler can do with the type information, but what something other than\n  the compiler can do with the type information.  this is largely, but not\n  fully, orthogonal to whether the language is statically or dynamically\n  typed.  debuggers for most languages maintain type information (mainly in\n  order to access the memory they use, of course), but you can't use it if\n  you aren't the debugger.  in some development environments, you get help\n  calling functions and using variables, but what's the big difference\n  between a lookup system only available in some program after compilation\n  and manual pages in external documentation?  the dynamism of _current_\n  information is missing in all of these systems.\n\n  I don't think it's possible to make a statically typed language as\n  dynamic as Common Lisp environments are simply because the work involved\n  in making a statically typed language able to handle the dynamism will\n  involve _very_ intelligent recompilation strategies, mounds of debugging\n  information that people will want to discard, and introspection will have\n  to be added to these languages in environment-specific ways.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "eureka!_lexical_bindings_can_be_guaranteed!"
        },
        {
          "id": "3161460533760438@naggum.no",
          "subject": "Re: Eureka! Lexical bindings can be guaranteed!",
          "author_id": "erik_naggum",
          "date": "2000-03-07",
          "display_date": "03/07/2000",
          "content": "\nSubject: Re: Eureka! Lexical bindings can be guaranteed!\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/07\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161460533760438@naggum.no>\n\n* Robert Monfera <monfera@fisec.com>\n| How can you tell?\n\n  huh?  through the high number of people who reinvent it in various ways,\n  and the low number of people who point out that they are reinventing\n  existing functionality whenever this happens.  isn't this quite obvious?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "eureka!_lexical_bindings_can_be_guaranteed!"
        },
        {
          "id": "3161448495156937@naggum.no",
          "subject": "Re: Eureka! Lexical bindings can be guaranteed!",
          "author_id": "erik_naggum",
          "date": "2000-03-07",
          "display_date": "03/07/2000",
          "content": "\nSubject: Re: Eureka! Lexical bindings can be guaranteed!\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/07\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161448495156937@naggum.no>\n\n* David Hanley <djh@ncgr.org>\n| It seems possible (to me) to write some lisp macros to produce a typed\n| version of the language...\n\n  before you reinvent the wheel, please investigate the THE special form\n  and how it behaves in interpreted and compiled code under various\n  optimization settings.  you might be _very_ surprised.\n\n  few Common Lisp programmers seem to know about the THE form, however.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "eureka!_lexical_bindings_can_be_guaranteed!"
        },
        {
          "id": "3161625123385591@naggum.no",
          "subject": "Re: Eureka! Lexical bindings can be guaranteed!",
          "author_id": "erik_naggum",
          "date": "2000-03-09",
          "display_date": "03/09/2000",
          "content": "\nSubject: Re: Eureka! Lexical bindings can be guaranteed!\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/09\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161625123385591@naggum.no>\n\n* Jon S Anthony <jsa@synquiry.com>\n| Third, you can always inline those functions where you think the extra\n| call overhead might actually make a difference (better to actually check\n| this with the (typically good) profilers provided first).\n\n  inlining user functions is frequently a very hazardous business, and some\n  implementations do not heed inline declarations for user functions.\n\n| Fourth, if push comes to shove, you could use macros to \"compile away\"\n| these definitions while maintaining the power of their abstraction.\n\n  compiler macros provide the best of both worlds, and can be quite the\n  tool to optimize code beyond belief without being force into macro land.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "eureka!_lexical_bindings_can_be_guaranteed!"
        }
      ],
      "post_count": 4,
      "first_post_date": "2000-03-07",
      "last_post_date": "2000-03-09"
    },
    {
      "id": "[q]_sorting_a_hash",
      "title": "[Q] Sorting a Hash",
      "posts": [
        {
          "id": "3161627464759676@naggum.no",
          "subject": "Re: [Q] Sorting a Hash",
          "author_id": "erik_naggum",
          "date": "2000-03-09",
          "display_date": "03/09/2000",
          "content": "\nSubject: Re: [Q] Sorting a Hash\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/09\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161627464759676@naggum.no>\n\n* Sandeep Koranne <koranne@natlab.research.philips.com>\n| Is it possible to sort a Hash based on a function on the values?\n\n  as others have indicated in indirect ways, this is not a well-defined\n  question, since the result of sorting a hash table would have to be\n  something other than a hash table.\n\n  so we need to know what kind of result you want in order to answer your\n  question.  e.g., yes, you can easily _print_ the (key value) pairs of a\n  hash table sorted on the key or on the value, but you would do that by\n  creating an intermediary sequence of keys or whatever, sort on that, and\n  then do the actual printing.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[q]_sorting_a_hash"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-03-09",
      "last_post_date": "2000-03-09"
    },
    {
      "id": "cwcc_in_cl_[was_re:_that_place.._]",
      "title": "cwcc in CL [was Re: That place.. ]",
      "posts": [
        {
          "id": "3161537045930526@naggum.no",
          "subject": "Re: cwcc in CL [was Re: That place.. ]",
          "author_id": "erik_naggum",
          "date": "2000-03-08",
          "display_date": "03/08/2000",
          "content": "\nSubject: Re: cwcc in CL [was Re: That place.. ]\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/08\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161537045930526@naggum.no>\n\n* \"Fernando D. Mato Mira\" <matomira@iname.com>\n| ? That's \"Fernando style\". One liners and quotes. The antithesis of EN!\n| ;)\n\n  I can't wait for the continuation.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "cwcc_in_cl_[was_re:_that_place.._]"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-03-08",
      "last_post_date": "2000-03-08"
    },
    {
      "id": "[executables]_was:_why_haskell_hasn't_replaced_cl_",
      "title": "[executables] was: why Haskell hasn't replaced CL yet?",
      "posts": [
        {
          "id": "3160523543335494@naggum.no",
          "subject": "Re: [executables] was: why Haskell hasn't replaced CL yet?",
          "author_id": "erik_naggum",
          "date": "2000-02-26",
          "display_date": "02/26/2000",
          "content": "\nSubject: Re: [executables] was: why Haskell hasn't replaced CL yet?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/26\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160523543335494@naggum.no>\n\n* Tunc Simsek <simsek@paleale.EECS.Berkeley.EDU>\n| Regarding this point, I was asked the following question:  \"how small of \n| an executable can you get from a CL program that simply prints HELLO WORLD\n| at the term\".\n\n  note that \"how small an executable\" actually means \"how much do the\n  operating system and the executable agree on\".  e.g., in the case of C\n  programs under Unix, so much that the executable can effectively be a few\n  hundred bytes, as the shared libraries that are involved and the\n  initialization code for the program are, after all, what the entire\n  operating system is optimized for.  this does not mean the memory\n  footprint of the executable when loaded into memory will be small, or\n  that it won't do a lot of work behind the scenes.\n\n| I don't know the answer, infact I don't even know how to produce an\n| executable from a Lisp program, I never had any need for it.\n\n  exactly.  therefore, the smallest \"executable Common Lisp program\" that\n  does the same meaningless task as the typical \"hello, world\" demo that\n  shows off how functions and interactive invocation work under Unix, is\n  either simply the string \"hello, world\" typed to a listener (and what's\n  the sport in that?) or (defun hello () \"hello, world\") which is almost as\n  unchallenging.\n\n  what we have to realize and counter with is that building lots of tiny\n  little programs in C is a very inefficient way to build an interactive\n  environment.  think of all the programs and scripts and whatnot as small\n  functions that can pass values around only as textual strings in pipes at\n  best.  each program is ephemeral and must use the disk for its variables\n  or state if it has any, or it must receive environment variables and\n  options each time and the state is maintained in the caller.  each\n  program is run by loading and dynamically linking a *huge* amount of\n  stuff every time.  in contrast, a Common Lisp system got all of this\n  interactive development environment stuff _right_, with very much simpler\n  and faster function invocation once you start it up, but you also have to\n  start up a shell to start you hello program.  so why focus on the size of\n  the \"executable\".  refocus on the amount of work involved and how having\n  to use an executable on disk for such a trivial behavior is really not a\n  good thing to begin with.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[executables]_was:_why_haskell_hasn't_replaced_cl_"
        },
        {
          "id": "3160693199764094@naggum.no",
          "subject": "Re: [executables] was: why Haskell hasn't replaced CL yet?",
          "author_id": "erik_naggum",
          "date": "2000-02-28",
          "display_date": "02/28/2000",
          "content": "\nSubject: Re: [executables] was: why Haskell hasn't replaced CL yet?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/28\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160693199764094@naggum.no>\n\n* not.for.email@not.for.spam\n| When you deliver an application, you have to take into account that the\n| users might not have access to your Lisp environment.\n\n  well, this is the meaningless part.  when people deliver applications,\n  they take for granted that you already have the relevant portions of the\n  environment the application needs in the shape of DLLs (or other forms of\n  shared libraries and resources) to make it run.  if you don't, you're\n  expected to download it, or in the worst case, get the application with a\n  bunch of such libraries.\n\n  therefore, the question is: what's considered the application?  the DLLs\n  and the whole shebang or _just_ the executable?  in my view, it doesn't\n  make sense to separate them (neither in the case of C nor CL), but in the\n  minds of people who compare sizes of executables, the DLLs are somehow\n  irrelevant, but if they are made aware of them for some languages, like\n  some not-so-helpful Lisp people seem to force them into, they will also\n  count the runtime system.  this is a very bad move.  don't call attention\n  to these things, and they'll never notice them the exact same way they\n  never notice the multimegabyte DLLs they install for other packages.\n\n| You also have to take into account that they might want the application\n| delivered to their email inboxes, and that they might have a limit on the\n| size of an incoming message.\n\n  sorry to say so, but this is a specious argument at best.  people need to\n  install some form of runtime system library _once_, and can thereafter\n  accept any small \"executable\" = application.  this is not a big deal.\n  what's necessary to ship for Common Lisp programs is usually much smaller\n  than you need to ship for other languages once you're past this point.\n\n| As another example, suppose I'm a naive user who uses your program from\n| my text-editor, invoking it with a filter-region command, to capture its\n| output in my edit buffer.  If I know someone else who has the same\n| program written in C++, and I've noticed that they can do the\n| filter-region thing in a tiny fraction of a second, but I always have to\n| wait almost a full second, I might start to envy them, and wish mine were\n| written in C++ instead of Lisp.\n\n  this would have been a useful piece of input if it were true.  it isn't.\n  that is, it used to be true 20 years ago, and today it's stale myth.\n\n| In the real world, we have to keep the users happy.\n\n  well, in the mythical world, the users aren't happy.  in the real world,\n  they don't care what language is used as long as they get what they want,\n  and users put up with a _lot_ of compromises.  speed is no longer an\n  issue, since the hardware new stuff is being deployed on is really fast.\n  (just trust me on this if you don't believe it.)\n\n| We have to instead say something like, \"yes, a Lisp program does take 750\n| ms to start running, but here are the ways you can mitigate that, and\n| here are the advantages you get for tolerating that.\"\n\n  do tell me just _why_ do we have to lie?  this is so blatantly stupid I\n  get _sick_.  on my system, the default Allegro CL starts up in about 20\n  ms and with one my applications which has a lot of startup-time\n  compucation, it takes about 35 ms on a bad day.\n\n| If we evade the question, the users will assume the worst.\n\n  and some will think _we're_ lying when we tell them that the startup-time\n  of a C++ program (and certainly a Java program) is longer than that of a\n  full-blown Common Lisp system.  do you know how we can deal with that,\n  considering your strong desire to perpetuate old myths?\n\n  you're welcome to the real world any time, but if you have nothing more\n  to contribute than trite old myths, you're part of the problem of the\n  mythical world Lisp _still_ has to fight, not part of any solution in the\n  real world.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[executables]_was:_why_haskell_hasn't_replaced_cl_"
        },
        {
          "id": "3160741395490719@naggum.no",
          "subject": "Re: [executables] was: why Haskell hasn't replaced CL yet?",
          "author_id": "erik_naggum",
          "date": "2000-02-28",
          "display_date": "02/28/2000",
          "content": "\nSubject: Re: [executables] was: why Haskell hasn't replaced CL yet?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/28\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160741395490719@naggum.no>\n\n* Tim Bradshaw <tfb@cley.com>\n| I tried this and it's basically the same (but my machine is a bunch\n| slower to start than Erik's for reasons I don't really know or care).\n| I'd assume (perhaps wrongly) that Erik will see a slowdown of 2 for the\n| serial one because he has a 2-processor machine so he ought to be able to\n| schedule one process on each cpu for the pll version whereas the serial\n| one can not do that.  Of course that just makes the startup time he's\n| measuring be the effective time for a ~ 1.2GHz serial machine.  So maybe\n| it's 40ms or something, who cares?\n\n  nonono, while we're making wild conjectures about the behavior of\n  completely irrelevant tasks, we must not also make serious mistakes, or\n  the data might suddenly become statistically valid.\n\n  SMP systems don't behave the way people tend to think.  like, we used up\n  <1 second of real time, and 1.5 seconds of CPU time, which is not at all\n  close to 40 ms, but more like 30 ms with all the overhead accounted for.\n  however, each process takes less than that, but I don't really know why\n  it takes more than 25 ms per process to fire it up in such a packed loop\n  when it takes close to 20 ms when run once, by itself, but it's fairly\n  consistent.  it is not a measurement error -- the real time reported is\n  in 1 ms units, while CPU time is reported in 10 ms units.  however, the\n  processor a process runs on doesn't grow any faster just because there's\n  one more of it that can run another process -- it's still a 600MHz\n  processor.  it's only during heavy multitasking that such a system can\n  approach 1.2GHz combined performance.  otherwise, the big win is only in\n  the interactive response time when one CPU is idle.  not that I complain.\n  \n#:Erik\n\n",
          "references": [],
          "thread_id": "[executables]_was:_why_haskell_hasn't_replaced_cl_"
        },
        {
          "id": "3160693945479201@naggum.no",
          "subject": "Re: [executables] was: why Haskell hasn't replaced CL yet?",
          "author_id": "erik_naggum",
          "date": "2000-02-28",
          "display_date": "02/28/2000",
          "content": "\nSubject: Re: [executables] was: why Haskell hasn't replaced CL yet?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/28\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160693945479201@naggum.no>\n\n* Tim Bradshaw <tfb@cley.com>\n| So I'd like to turn this around: why does anyone *care* about a sub-1Mb\n| standalone application any more?\n\n  that's simple, Tim: because they want to keep their myths alive and well.\n  \"Lisp is big and slow\" is not a fact, it's a religious belief.  you can't\n  turn people's religions around with facts.  if people deep down trust\n  that this is the reason Lisp doesn't win, they'll return to it every time\n  Lisp doesn't win, true or not, supported by evidence or not -- it's just\n  how they \"feel\", anyway.\n\n  most people have only one _real_ desire in their life: to feel safe in\n  the correctness of their beliefs.  the only way to make this happen is to\n  hand them something obviously better and correct to believe in while you\n  burn down whatever it was they considered safe thoroughly.\n\n  consider this a theory of the ecology of ideas, where the winning ideas\n  are like predators sneaking up on whoever feels smugly safe.  there will\n  be a lot of screaming and shouting while the stale ideas are killed and\n  their proponents act like scared monkeys, but afterwards, you won't have\n  a problem with stale ideas resurfacing.  sadly, the Lisp community has\n  not been willing to kill off the idiotic ideas with sufficient force, and\n  when I try, a whole bunch of monkeys scream so much it's time to call the\n  Discovery Channel crew and film them.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[executables]_was:_why_haskell_hasn't_replaced_cl_"
        },
        {
          "id": "3160726754880201@naggum.no",
          "subject": "Re: [executables] was: why Haskell hasn't replaced CL yet?",
          "author_id": "erik_naggum",
          "date": "2000-02-28",
          "display_date": "02/28/2000",
          "content": "\nSubject: Re: [executables] was: why Haskell hasn't replaced CL yet?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/28\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160726754880201@naggum.no>\n\n* not.for.email@not.for.spam\n| 20 ms implies you can run it 50 times per second in a script loop.\n| What computer is that on?  Have you actually tested it in a script\n| loop to verify that  you can run it 50 times per second?\n\n  not until now, but a typical run among many goes like this:\n\ntime (for x in 0 1 2 3 4; do for y in 0 1 2 3 4 5 6 7 8 9; do ./allegro -batch -kill & done; done; wait)\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\n; Exiting Lisp\n; Exiting Lisp\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\nAllegro CL Enterprise Edition 5.0.1 [Linux/X86] (2/15/0 21:48)\nCopyright (C) 1985-1999, Franz Inc., Berkeley, CA, USA.  All Rights Reserved.\n; Exiting Lisp\n\nreal\t0m0.986s\nuser\t0m1.050s\nsys\t0m0.470s\n\n  the system is a dual 600MHz Pentium III with 512M RAM at 100MHz, which\n  runs Debian Linux 2.2 (potato) with kernel 2.2.14 SMP.  no swap space,\n  but a bunch of really fast disks, which should be irrelevant since all of\n  the relevant blocks are in the disk cache, anyway.\n\n| In the past I've seen people ask how fast Allegro executables could start\n| up, and the answers I saw were \"less than one second\" and \"you shouldn't\n| do it that way.\"  I've never had an opportunity to measure it myself, and\n| did not intend to give an impression of having actual numbers.  The\n| number I mentioned was part of my example of how the answer should be\n| given.  It could have been any number and still meant the same thing.\n\n  French has an idiomatic number that means \"a lot\": 36, so you could argue\n  that startup-times are 36 ms, pardon your French, and be home safe.  :)\n  \n#:Erik\n\n",
          "references": [],
          "thread_id": "[executables]_was:_why_haskell_hasn't_replaced_cl_"
        },
        {
          "id": "3160735878041395@naggum.no",
          "subject": "Re: [executables] was: why Haskell hasn't replaced CL yet?",
          "author_id": "erik_naggum",
          "date": "2000-02-28",
          "display_date": "02/28/2000",
          "content": "\nSubject: Re: [executables] was: why Haskell hasn't replaced CL yet?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/28\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160735878041395@naggum.no>\n\n* not.for.email@not.for.spam\n| On 28 Feb 2000 11:39:14 +0000, Erik Naggum <erik@naggum.no> wrote:\n| \n| >time (for x in 0 1 2 3 4; do for y in 0 1 2 3 4 5 6 7 8 9; do ./allegro -batch -kill & done; done; wait)\n| \n| That looks like you're starting up 50 copies and waiting for them all to\n| exit.  (If I understand what the '&' does.)\n\n  you don't.  waiting for zombies doesn't take time, and processes aren't\n  started up _all_ in parallell.  as you could have seen from the output if\n  you had cared to, the processes clearly start up and terminate fairly\n  sequentially.  this is a pretty good indication that we are not starting\n  up 50 copies all in parallell, not to mention the fact that we manage to\n  squeeze 50 full instantiations within one second.  regardless of what you\n  think, the fact that this loop terminates in less than 1 second actually\n  means that all of them started up and terminated within an average of 20\n  ms of real time each.  and since this is a dual processor system, it\n  would be pretty stupid not to take advantage of it, so you got what you\n  asked for: 50 copies started and terminated in less than 1 second.  now\n  is a good time to _believe_, heathen.\n\n| What would the results be if you waited for each to exit before starting\n| the next?\n\n  a miniscule waste of time in the looping construct.  the user and system\n  time total 1.5 seconds.  the real time is < 1 s.  you do the math.\n\n| Is Allegro written in Lisp?\n\n  yes.  that is, more than 98% is written in Lisp.  (writing a Common Lisp\n  system in anything else is _really_ painful.)  the operating system\n  interface substrate is written in C because that's what the Unix\n  operating system requires for portable substrate code.  if the Unix\n  operating system had been intelligently designed and hadn't outboarded so\n  much of the kernel interface to the C libraries, it would have been\n  easier to deal with the kernel through small, well-defined system calls\n  in assembly language, but that's just too much to maintain from version\n  to version, where the only stable link to the kernel is the C library.\n\n  I'm somewhat amazed by the resilience of your prejudices.\n  \n#:Erik\n\n",
          "references": [],
          "thread_id": "[executables]_was:_why_haskell_hasn't_replaced_cl_"
        },
        {
          "id": "3160967097304876@naggum.no",
          "subject": "Re: [executables] was: why Haskell hasn't replaced CL yet?",
          "author_id": "erik_naggum",
          "date": "2000-03-02",
          "display_date": "03/02/2000",
          "content": "\nSubject: Re: [executables] was: why Haskell hasn't replaced CL yet?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/02\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160967097304876@naggum.no>\n\n* Andrew McDowell <drew@getaway.net>\n| You just don't _hear_ about Lisp being used in 'cutting-edge' or\n| 'technically sexy' projects....and I'm not quite certain that this isn't\n| by design.\n\n  it depends on whether your ears are open or shut.  it is a well-known\n  fact in the marketing industr that a very large number of people don't\n  actually hear about anything that doesn't already fit their mental models\n  of the world, even if you shout into their ears with hundreds of millions\n  of advertising money.\n\n  it amazes me somewhat that this actually needs explaining during U.S.\n  presidental nominations, but maybe you haven't heard about it.  :)\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[executables]_was:_why_haskell_hasn't_replaced_cl_"
        },
        {
          "id": "3161001459566142@naggum.no",
          "subject": "Re: [executables] was: why Haskell hasn't replaced CL yet?",
          "author_id": "erik_naggum",
          "date": "2000-03-02",
          "display_date": "03/02/2000",
          "content": "\nSubject: Re: [executables] was: why Haskell hasn't replaced CL yet?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/02\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161001459566142@naggum.no>\n\n* \"Andrew McDowell\" <drew.mcdowell@msfc.nasa.gov>\n| So just give up without trying?\n\n  no.  the only alternative to naive optimism is not depressed cynicism, OK?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[executables]_was:_why_haskell_hasn't_replaced_cl_"
        },
        {
          "id": "3160967673828621@naggum.no",
          "subject": "Re: [executables] was: why Haskell hasn't replaced CL yet?",
          "author_id": "erik_naggum",
          "date": "2000-03-02",
          "display_date": "03/02/2000",
          "content": "\nSubject: Re: [executables] was: why Haskell hasn't replaced CL yet?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/02\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160967673828621@naggum.no>\n\n* Samuel A. Falvo II\n| But doing things in this manner takes advantage of the fact that the OS\n| already has the code for the Lisp environment already in memory, which\n| causes us to measure the process instantiation time of the environment, NOT\n| the load-time of the environment.\n\n  this is amazingly misguided.  the load-time of the environment is related\n  to such tasks as mapping pages of memory, handling shared libraries\n  (which is _very_ expensive), and running a bunch of initilization code.\n  _none_ of this is magically remembered from one instantiation of the\n  system to the next.  (and doing so would be a veritable _disaster_.)\n\n| 2) The test you perform is guaranteed to be under \"light load\".  If the\n|    system is in real-world use, I can guarantee you that test would take longer\n|    than a second (potentially up to a minute depending on the tasks being\n|    performed).\n\n  this is getting _really_ silly, but it goes to show that some people will\n  do just about anything to deny the fact that Allegro Common Lisp starts\n  up real fast on modern computers.  which sort of proves my point...\n\n| Umm...C compiles to assembly language.  You can still call the C library\n| using assembly.\n\n  look, are you for _real_?  Common Lisp compiles to assembly, damnit!\n\n| You deride C as if it's the antichrist.\n\n  oh, shut up and return to your home planet.  I do no such thing.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[executables]_was:_why_haskell_hasn't_replaced_cl_"
        },
        {
          "id": "3161063857499252@naggum.no",
          "subject": "Re: [executables] was: why Haskell hasn't replaced CL yet?",
          "author_id": "erik_naggum",
          "date": "2000-03-03",
          "display_date": "03/03/2000",
          "content": "\nSubject: Re: [executables] was: why Haskell hasn't replaced CL yet?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/03\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161063857499252@naggum.no>\n\n* Samuel A. Falvo II\n| What part of this didn't you understand?\n\n  why you can't figure out that start-up time from storage media is utterly\n  and completely irrelevant when you start 50 processes within the same\n  second.\n\n  incidentally, I consider your question an instance of losing your temper.\n  control your own temper, you hypocrite, or shut up about that of others!\n\n| The only point I saw was that you can launch 2 copies of ACL 25 times a\n| second each.\n\n  this is obviously an unwarranted conclusion on your part, since it took\n  1.5 second user+system time and 1 second real time, and only user+system\n  matters.  you have no data to support your conclusion, but you do have\n  data to support that I could fire up 33 instances a second on one CPU\n  from this data.  so I just wish you could engage your brain before you\n  engage your agenda.\n\n| Are you for real?  Why are you getting so upset?  Why can't you conduct\n| yourself like an adult?  What did I do to deserve the personal attacks on\n| me by you?  Where have I attacked you?  And what did I attack you with?\n\n  you're being obnoxious, stupid, impenetrably dense, and behave like an\n  asshole with an irrelevant axe to grind.  that's what I object to.  and\n  now you can't even control your own temper.  how sickeningly _pathetic_.\n\n| All I did was point out that there were ambiguities in the measurements made\n| due to certain \"basic\" assumptions.  I'm not interested in the theoretical\n| performance of ACL.  I'm interested in the real-world, down-to-Earth,\n| in-the-trenches performance of ACL.\n\n  and that's what you got, dude.  now, will you _ever_ be satisfied?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[executables]_was:_why_haskell_hasn't_replaced_cl_"
        },
        {
          "id": "3161113129999037@naggum.no",
          "subject": "Re: [executables] was: why Haskell hasn't replaced CL yet?",
          "author_id": "erik_naggum",
          "date": "2000-03-03",
          "display_date": "03/03/2000",
          "content": "\nSubject: Re: [executables] was: why Haskell hasn't replaced CL yet?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/03\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161113129999037@naggum.no>\n\n* not.for.email@not.for.spam\n| Or even better, Franz should post some ACL-built executables on their web\n| site, for just such purposes as this.\n\n  the Franz Inc sales staff and their engineers have related to me in the\n  past, and I'm sure I'm not misrepresenting them now, that they see\n  extremely little business value in catering to people who mainly execute\n  really tiny programs like the null program or \"hello, world\" programs.\n  rather, they have told me, and I have reason to believe them, that their\n  main customers use Common Lisp in large-scale applications.  their\n  pricing model, licensing terms, and their Value Added Reseller programs\n  all work very well together to indicate to me that they regard themselves\n  somewhat like Oracle, which also provides a huge environment that people\n  mainly use to deploy Really Important Applications, not somewhat like\n  Larry Wall and the Perl team, who provide a large fuzzy toy environment\n  that people mainly use to deploy Really Unimportant Applications.\n\n  catering to the RUA people is antithetical to doing business well with\n  the RIA people.  everybody in the computer business _knows_ this, except\n  the RUA people, but they don't _actually_ count, even though they think\n  they do.  for some bizarre reason, RUA people think their RUAs grow into\n  RIAs when in fact they don't.  vast networks of half-cooperating RUAs are\n  actually reimplemented by RIA people into a much smaller and leaner RIA\n  than the RUA people could ever hope to realize when push comes to shove.\n\n  RUA people can graduate into RIA people if they first learn to dispense\n  with the notion that RUAs _matter_.  they don't.  really.  nobody is\n  interested in how many RUAs you have written when they are looking for\n  people to write RIAs.  and I _mean_ nobody.  RIA people need to show\n  their ability to deal with complexity by reducing problems by solving the\n  really big problems.  RUA people show their ability to create complexity\n  by profilerating tiny solutions.  if making something you yourself can\n  use takes 1 unit of time, making something somebody else can use takes 3\n  units of time, and making a system that somebody else can use to to build\n  something that starts the whole scale all over again, takes 9 units of\n  time.  most people are extremely unprepared to build such systems, yet\n  this is what it takes to grow an RIA programmer from an RUA programmer.\n  that's why we need RIAs so people who think they are worth something in\n  this here overheated industry can write RUAs on top of RIAs and make\n  their employers happy -- they should not _ever_ believe that because they\n  are using an RIA to write RUAs, they are somehow equipped to write RIAs.\n\n| To really meet their needs, it has to fit not only the better paradigms\n| but also the ones they already use, even if it doesn't fit them as well\n| as C++ does.\n\n  for some reason, everybody realizes that civil engineering is different\n  from building a toy city in a sandbox.  you can't become a civil engineer\n  by presenting however many pictures of beautiful sandbox cities.  it\n  takes much more than that, different skills, realizing different needs,\n  different attitudes, different time lines, different economies.  for one\n  thing, you can't tear up a real city like you can destroy your sandbox\n  city and you can't just start over if you realize that you failed.  this\n  is the really big difference between RUAs and RIAs.  an RUA can be torn\n  down and replaced on short notice.  that's what makes it an RUA.  an RIA\n  can't be torn down without jeopardizing really serious investments, such\n  as the entire existence of a company.\n\n  there is hope for RUA people who are bored of writing small things, but\n  there is no hope at all for RUA people who still think \"hello, world\" is\n  interesting in any way, shape, or form.  RIA people think differently,\n  too -- most of them enjoy discussing large-scale philosophical issues,\n  and are usually very hostile to the really petty issues that most people\n  think are inordinately important in their own lives.  RUa people are well\n  suited to deal with their own lives in all its detail.  RIA people deal\n  with thousands and millions of lives in some particular respect.\n\n| The programmers know they will be working towards something better, but\n| they need a foundation to stand on while they work, and that means being\n| able to do what they do now, and advance from there one step at a time.\n\n  this is almost entirely false.  it is true in the sense that people need\n  to make one step at a time to make any serious changes to their lives,\n  but deciding to go from RUA to RIA is like going from playing doctor with\n  the kid next door (while yourself a kid -- we're not talking about Visual\n  Basic, here) to actually putting in the planning and all the effort to\n  _become_ a doctor some fifteen years later, during which time you don't\n  play doctor all that much, I can tell you.  deciding to go from RUA to\n  RIA is a _complete_ replacement of your whole mind-set towards what\n  computers can and should do.  (e.g., an RUA person may think it's OK for\n  a computer to crash.  an RIA person thinks of a dying machine the same\n  way a doctor does about a patient, or a military leader about soldiers:\n  it should not happen without conscious effort to avoid it to the best of\n  one's ability.)\n\n| But fear of other tradeoffs, such as a 1000 to 1 ratio of the above test,\n| might be what keeps them from proceeding.\n\n  no, what keeps them at bay is fear of insufficiency in becoming an RIA\n  person.  trust me on this -- I try every single day to find RIA material\n  among the hundreds and thousands of RUA people I brush against on the Net\n  and in real life.  perhaps one in 200 people are suitable, and the best\n  way you can spot them is they are _not_ exicited about trifling news and\n  hyped-up products or stale ideas in new packaging.\n\n| Your post of your numbers was appreciated and surprising.  I had no idea\n| ACL could start that fast on any machine.  I'm a lot more interested in\n| the possibility of using it for a future project now than I was before.\n\n  I'm sort of glad you appreciate it, but to me, the whole point was to get\n  _rid_ of your false concerns, not help you validate them.  I regret very\n  much if I did the latter.  start-up time is _completely_ irrelevant.  as\n  others have pointed out, if you need to perform a certain task often, you\n  investigate scaling issues and find that optimizing for scale is a very\n  different task from optimizing for individual execution.  it's somewhat\n  like optimizing for having fun in your sandbox compared to saving a city\n  billions of dollars through excellence in civil engineering.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[executables]_was:_why_haskell_hasn't_replaced_cl_"
        },
        {
          "id": "3161062467384796@naggum.no",
          "subject": "Re: [executables] was: why Haskell hasn't replaced CL yet?",
          "author_id": "erik_naggum",
          "date": "2000-03-03",
          "display_date": "03/03/2000",
          "content": "\nSubject: Re: [executables] was: why Haskell hasn't replaced CL yet?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/03\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161062467384796@naggum.no>\n\n* Samuel A. Falvo II\n| With the computer doing absolutely nothing else in the process.  Do you\n| see the difference here?  In a real-world situation, a computer could be\n| handling network connections, performing back-ups, or otherwise running\n| other CPU-intensive tasks in the background.  That all will definately\n| influence (and lengthen) startup times.\n\n  oh, geez, when will this _end_?\n\n  I don't have this powerful a machine just to boast about it and play\n  games.  it's a work-horse for serious development, and it has a number of\n  non-trivial duties.  at the time I ran those tests, it turns out that it\n  was servicing a few thousand FTP requests from local network machines\n  that were upgrading some software automatically over the span of the few\n  minutes I ran the tests, it ran a bunch of Netscape frames with animated\n  advertising GIFs, and it provided monitoring and backup services for 6\n  other computers on its local network, which involves network traffic and\n  low CPU consistency checking.  it also received four e-mail messages, the\n  processing of which fires up an Emacs in batch mode to handle the\n  filtering and processing of the incoming messages.  the only thing not\n  strictly normal about this is the FTP load.  regardless, I have no idea\n  exactly how big this load was during each of the individual _seconds_\n  that I ran my tests.  I have reason to suspect that it had very little\n  effect on anything because the machine is in fact able to perform the\n  vast majority of its duties in zero noticeable time -- which is why it is\n  this powerful to begin with.  now, this _could_ explain the 5 ms extra\n  execution time I noticed, but that's just pure speculation on my part,\n  and I see little point in spending the time to figure it out.\n\n| I was just pointing out that the measurements performed could be\n| misleading due to the circumstances in which the measurements were made.\n\n  so let's assume the measurement errors were on the order of 20 vs 25 ms\n  per invocation.  that's the difference between 40 and 50 invocations per\n  second.  this bothers you a great deal, apparently.  it doesn't bother me.\n\n  and you were \"just pointing out\" that it could take _minutes_, which is\n  nothing more than really bad fiction on your part.  in _minutes_, this\n  machine has compiled GNU Emacs from scratch (2:30), built a new Linux\n  kernel (2:10), installed staroffice (1:20), built CD images for Debian\n  2.2 (3:10), or upgraded and installed a 100 packages (2:50).\n\n  to suggest that this machine should suddenly only manage to start 50\n  Allegro CL processes because of other work it's doing is simply insane.\n\n  as long as any goddamn fool can cast doubt on anything anybody says, I\n  suggest a much more honest starting point: \"I don't want to believe you!\"\n  instead of trying to smear whoever is trying to answer their questions.\n  I'm getting sick of the rampant stupidity that comes with benchmarks and\n  any other myth-deflating devices.  myths, apparently, are necessary for\n  the mental survival of some people.  perhaps it is not a good idea to try\n  to destroy their misguided beliefs because they turn out to be lunatics\n  if they can't keep their myths alive and well.\n  \n#:Erik\n\n",
          "references": [],
          "thread_id": "[executables]_was:_why_haskell_hasn't_replaced_cl_"
        },
        {
          "id": "3161063348163784@naggum.no",
          "subject": "Re: [executables] was: why Haskell hasn't replaced CL yet?",
          "author_id": "erik_naggum",
          "date": "2000-03-03",
          "display_date": "03/03/2000",
          "content": "\nSubject: Re: [executables] was: why Haskell hasn't replaced CL yet?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/03\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161063348163784@naggum.no>\n\n* kc5tja@garnet.armored.net (Samuel A. Falvo II)\n| >Happy now?\n|  ^^^^^^^^^^\n| \n| Yet another person who indulges in personal attacks and can't control his\n| temper.\n\n  how about you?  if you can't control your reactions to a \"happy now?\"\n  maybe the simple fact of the matter is that the problem _is_ with you,\n  and not with anything else at all.  you know, this happens a lot in real\n  life, so it's not particularly surprising that it happens on the Net.\n\n| With people like this promoting the language, is it any wonder that LISP\n| has little press these days outside of academia?\n\n  see, this is a fairly insulting personal attack, but fortunately, we know\n  from the history of just about everything that only clueless morons come\n  up with this shit, so nobody has to deal with it except to laugh at you.\n\n  in case you need spoonfeeding, too: we're responding to your \"arguments\"\n  and attitude problems, we're not promoting the language.  if you think\n  you are engaging people in a \"promote the language\" debate with your\n  silly misgivings about the measurements, you're even more arrogant than\n  anybody here probably thinks right now.\n\n| Tone your voice down, will you?\n\n  great idea!  hey, maybe you could show us with your excellent example\n  behavior?\n\n| I did nothing to warrent your wrath.\n\n  in your own eyes, obviously, but since when do people's reactions to you\n  depend (especially solely) on what _you_ think you did?  come on, now,\n  show some _insight_ into human behavior if you want to be the critic.\n  matter of fact, if you see somebody angry at you, the first thing to do\n  is consider the question: \"what did I do?\", _not_ \"I don't deserve this!\"\n  and go self-defensive.  however, if you actually react with a \"I don't\n  deserve this!\" what the hell were you thinking when you lashed out at\n  others -- they clearly didn't deserve it in their own eyes, either, and\n  they certainly did _nothing_ to warrant your idiotic comment about\n  promoters of the language.\n\n  I find it utterly fascinating that the people who make so much fuss about\n  other people's temper have no control over their own and have so much\n  less into these things than those who _can_ control their temper and\n  direct it specifically at targets that _do_ deserve it.  watch these guys\n  when they defend themselves!  it's _ridiculous_ how unfocused they become\n  and how willing they are to drift away from any topic at all.  this leads\n  me to conclude that we're looking at people who lack the ability to deal\n  with conflict in general, and who spend their life avoiding conflict in\n  any form, only to be _really_ upset when others don't share their views,\n  and then they behave as rank amateurs in any conflict they get into.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[executables]_was:_why_haskell_hasn't_replaced_cl_"
        },
        {
          "id": "3161195138352807@naggum.no",
          "subject": "Re: [executables] was: why Haskell hasn't replaced CL yet?",
          "author_id": "erik_naggum",
          "date": "2000-03-04",
          "display_date": "03/04/2000",
          "content": "\nSubject: Re: [executables] was: why Haskell hasn't replaced CL yet?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/04\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161195138352807@naggum.no>\n\n* not.for.email@not.for.spam\n| What kind of political agenda could I possibly have?  Even if my point of\n| view seems like completely irrational engineering, that doesn't make it\n| political.  I want a programming language and development environment\n| that meets several criteria, some of which may seem more rational to you\n| than others.  I'm taking a lot of factors into account and probably\n| giving most of those factors different weights than you would.  That\n| doesn't make me your political enemy.\n\n  it seems reasonable to assume that you failed to read the whole sentence\n  you just quoted a tiny little the part of.  let me try it again:\n\n  if you have problems with this extra \"layer\" of code, yet observe that\n  you get dramatically improved performance, which you would if you tried\n  it instead of just rejecting any other solutions than \"run the program\",\n  I'd say you have a political agenda and not an engineering problem,\n  anymore.\n\n  the keyword here is \"rejecting any other solutions\".  being dead set on\n  exploring only a particular solution space _is_ a political decision on\n  your part.  you can argue for its engineering _necessity_, but it is\n  still a political decision.  believing otherwise does you no good.\n\n  you seem to be extraordinarily focused on not seeing your problems other\n  than in light of how you can solve them with technology you already know.\n  this is the really exasperating part of trying to tell you something new\n  that might change your perception of the _problem_, not the solutions.\n  and as with every other political decision where people get \"stuck\" in\n  their pet problems, we find that they don't really want any solutions,\n  but will go on and on and on and on about their problem.  so there's no\n  telling when some benchmark-crazed doofus will be satisfied, because\n  there's nothing he actually wants to _know_.  such unfocusedness is\n  rampant in bad engineering circles where political agendas are much more\n  important than solving problems.  you find them here in comp.lang.lisp at\n  times, too, where someone comes up with something he _desperately_ wants\n  to do only particular way and any suggestions otherwise fall on deaf ears.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[executables]_was:_why_haskell_hasn't_replaced_cl_"
        },
        {
          "id": "3161170559722358@naggum.no",
          "subject": "Re: [executables] was: why Haskell hasn't replaced CL yet?",
          "author_id": "erik_naggum",
          "date": "2000-03-04",
          "display_date": "03/04/2000",
          "content": "\nSubject: Re: [executables] was: why Haskell hasn't replaced CL yet?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/04\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161170559722358@naggum.no>\n\n* not.for.email@not.for.spam\n| On 03 Mar 2000 22:58:49 +0000, Erik Naggum <erik@naggum.no> wrote:\n| \n| >  extremely little business value in catering to people who mainly execute\n| >  really tiny programs like the null program or \"hello, world\" programs.\n| \n| That's silly.\n\n  then why do you argue that people spend time publishing results in that\n  area?  clearly, your argument is that these things matter a great deal.\n  but I quite agree that it's silly to be concerned about such things, and\n  I'm delighted that you recognize silliness when properly framed -- you\n  might actually recognize that your core argument is indeed very silly.\n\n| It should be obvious to you that people who want to test \"hello world\"\n| programs do not have such programs as their main goal.  The main purpose\n| of such a program is to minimize the complexity of a program to explore\n| the issues of compiling, installing, etc., independently of issues of\n| program complexity.\n\n  if that _were_ the goal, I'd agree that it would be useful to help people\n  with such programs.  however, it isn't, and you know it isn't.  those who\n  argue for small executables do so on the basis of \"overhead\", which is\n  not a question of how much the language needs, but how well the operating\n  system is able to accomodate its needs.  so small executable size is a\n  tribute to the operating system and the language, while large executable\n  overhead is a blemish on the operating system.  oddly enough, people take\n  it out on the language.  this is not just silly, it's idiotic.\n\n| My interest in null programs is because I happen to presently use a lot\n| of software in the \"pipes and filters\" paradigm, and I would like to\n| replace some of that software with my own versions, which I might like to\n| write in Lisp.\n\n  if you were truly interested, you would be willing to consider many ways\n  to accomplish your needs.  \"pipes and filters\" does _not_ translate into\n  \"small executable with short startup-up time\" except to the permanently\n  braindamaged C victims.  in particular, a good way to make use of Lisp is\n  to have a very heavy process that maintains a lot of state, but which\n  tiny C programs talk to via sockets, if this is hard to do directly from\n  whatever \"scripts\" are otherwise engaged in the \"pipes and filters\"\n  thing.  (IMNSHO, the sorry fact that shells have not grown to be able to\n  make network connections instead of just pipes is _really_ pathetic.)\n\n| Note that I am not advocating using \"pipes and filters\" as a good\n| paradigm for any particular project.  The reason I want to use it is to\n| be compatible with software I already have.  I also want to use Lisp or\n| some such language for bigger projects, but would rather use the same\n| language and programming environment for both types of projects.\n\n  you can, but you have to zoom out and _think_ about your problem.  you\n  can't expect everything new to fit the same old mold.  in this case, the\n  friggin obvious solution is to write a pipe-and-filter thingy in C that\n  talks to the Lisp process.  that way, you reduce the start-up time to\n  that of C (which you seem to believe is short) plus the overhead of\n  connecting to the already running Lisp process, which is, like, _really_\n  short.  if you have problems with this extra \"layer\" of code, yet observe\n  that you get dramatically improved performance, which you would if you\n  tried it instead of just rejecting any other solutions than \"run the\n  program\", I'd say you have a political agenda and not an engineering\n  problem, anymore.\n\n  it so happens that _every_ other person who has posted to this newsgroup\n  about his misgivings about startup times has had a political agenda and a\n  need to complain rather than get any real work done.  you're not in good\n  company.  if you don't like this, you need do nothing more than show that\n  you have worthy goals with your quest -- and that is best shown by simply\n  abandoning the bad solutions that you keep complaining about.\n\n| That's not a good analogy because Lisp is a lot more like playing than\n| like doing civil engineering.\n\n  I'm glad you show me I was right in judging you to be an RUA person, but\n  really, don't you think I spent all that time with a glimmer of hope that\n  you might recognize how RIA people _differ_ from yourself in what I\n  wrote?\n\n  time for the lament of the day: it is so often such a terrible _waste_ to\n  write anything non-mundane to this newsgroup it's truly _exasperating_.\n  the only thing you fucking dolts care about is whether people use nice\n  words or bad, and then if you get nice, approved words, your brains seal\n  shut with \"oh, it's nothing dramatically new, so I'll just lull myself\n  into my cozy old stupidity and enjoy the peace and quiet from not having\n  to listen to anyone\".  I get _sick_ of such idiocy and stupidity!  many\n  of you guys seem to want it more than anything else, and some even go out\n  of their way to _encourage_ nice and cozy, non-threatening stupidity.\n\n  you, in particular, don't know much about programming, Mr. anonymous not\n  for e-mail at not for spam dude, so it would help a lot if you didn't\n  pretend you did and that you didn't tell people who have outgrown your\n  childish approach to programming _decades_ ago about how you have _not_\n  understood that this here programming thing is _not_ about playing in a\n  sandbox.  a few people have tried to share their experience with you, and\n  you just reject them because you refuse to believe that there's anything\n  beyond toy code (by our measures, not yours).\n\n#:Erik, actually irritated, for once\n\n",
          "references": [],
          "thread_id": "[executables]_was:_why_haskell_hasn't_replaced_cl_"
        },
        {
          "id": "3161205428344366@naggum.no",
          "subject": "Re: [executables] was: why Haskell hasn't replaced CL yet?",
          "author_id": "erik_naggum",
          "date": "2000-03-05",
          "display_date": "03/05/2000",
          "content": "\nSubject: Re: [executables] was: why Haskell hasn't replaced CL yet?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/05\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161205428344366@naggum.no>\n\n* not.for.email@not.for.spam\n| Lisp programming is entirely different.  You can see what you're doing,\n| and can see its effects, before you commit to doing it that way.  Lisp\n| programming involves learning how to do what you want to do while you do\n| it.  Civil engineering requires learning everything before you do\n| anything.  Civil engineering uses the waterfall paradigm.\n\n  your belief system is severely misguided, and also self-reinforcing in a\n  sense that will make it impossible for you ever to graduate into serious\n  software development of the Really Important Application kind.\n\n| That paradigm has been shown to be a failure in software development.\n| Thus programming is not at all like civil engineering.  The point I was\n| refuting was that Lisp programming is like civil engineering.  It's not.\n\n  I'm sorry to burst your bubble, Mr. not.for.email@not.for.spam, but the\n  waterfall paradigm works just fine at the coarse development level.\n  since you apparently only build Really Unimportant Applications, where\n  there _is_ no coarse development level, only the details level that you\n  keep describing with very good accuracy, you're missing the point: that\n  there is _more_ than the nitty-gritty details level.\n\n  but I give up.  people who aren't equipped to understand big pictures\n  will only get increasingly hostile and adamant that only their small\n  pictures exist when you try to force them to open their eyes.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[executables]_was:_why_haskell_hasn't_replaced_cl_"
        },
        {
          "id": "3161209024430026@naggum.no",
          "subject": "Re: [executables] was: why Haskell hasn't replaced CL yet?",
          "author_id": "erik_naggum",
          "date": "2000-03-05",
          "display_date": "03/05/2000",
          "content": "\nSubject: Re: [executables] was: why Haskell hasn't replaced CL yet?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/05\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161209024430026@naggum.no>\n\n* Bulent Murtezaoglu <bm@acm.org>\n| Actaully, this can be remedied reasonably easily using little programs like\n| netcat.  (goes by the name 'nc' usually).\n\n  ... which is the little C program that starts up in no time, right?\n\n  if the shells could do their own network connections, there wouldn't be\n  any need to start up those little programs.  after all, the shells don't\n  run small programs do to filename globbing, anymore, and numerous other\n  common tasks have been incorporated into the shells, simply because it\n  makes a lot more sense to incorporate them than to run small programs all\n  the time, partly because start-up time for even small programs begin to\n  matter when you have to do it hundreds of times because everything you\n  _do_ is made up a whole school of tiny little programs.\n\n  in case it hasn't become obvious by now: the more people get good at\n  writing small programs that run in \"barely noticeable time\" each, the\n  more silly things like start-up time matter to them.  the more they get\n  good at these silly things, the less intelligently they design their\n  software, and the less likely they are ever to produce software that\n  doesn't consist of tiny little fragments of code that never quite work\n  together.\n\n  when you reinvent serious programming languages in scripting languages,\n  which people have been doing in the Unix world for ages, what you get is\n  a lot of people who can do useful things in no time, and no people who\n  can figure out how to do stuff that obviates the need for tiny hacks or\n  at least that curbs their dramatic increase.  the result is a never-\n  ending increase in the need for more tiny little programs, which costs\n  all parties involved in the processes a lot of money, and which drives up\n  the cost of hiring and doing business.  the only people who profit from\n  this development are bad programmers.\n\n  I see no reason why Common Lisp should take part in that development.\n  instead, we should try to explain to people who think they have to hire\n  bad programmers that they don't have to -- they could hire a Common Lisp\n  programmer who knows how to change a mass of RUAs into a coherent system\n  that it takes far less effort to build and maintain than just to keep the\n  old system running.  it's somewhat like the difference between a mass of\n  disorganized files and information strewn all over the place and a real\n  database system.  and the funny thing is: some people _do_ get the idea.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[executables]_was:_why_haskell_hasn't_replaced_cl_"
        },
        {
          "id": "3161357289560302@naggum.no",
          "subject": "Re: [executables] was: why Haskell hasn't replaced CL yet?",
          "author_id": "erik_naggum",
          "date": "2000-03-06",
          "display_date": "03/06/2000",
          "content": "\nSubject: Re: [executables] was: why Haskell hasn't replaced CL yet?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/06\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161357289560302@naggum.no>\n\n* yodamanman@my-deja.com\n| what planet are you from?\n| your generalized RUA name doesn't make sense.\n| Maybe you have a chip on your shoulder? :^)\n\n| please do explain.\n\n  really?  you're a waste of space.  go away.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[executables]_was:_why_haskell_hasn't_replaced_cl_"
        }
      ],
      "post_count": 18,
      "first_post_date": "2000-02-26",
      "last_post_date": "2000-03-06"
    },
    {
      "id": "private_message_received_from_en",
      "title": "Private message received from EN",
      "posts": [
        {
          "id": "3160825893412027@naggum.no",
          "subject": "Re: Private message received from EN",
          "author_id": "erik_naggum",
          "date": "2000-02-29",
          "display_date": "02/29/2000",
          "content": "\nSubject: Re: Private message received from EN\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/29\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160825893412027@naggum.no>\n\n* \"Janos Blazi\" <jblazi@netsurf.de>\n| Today I received the following private message on my private address from\n| Erik Naggum: (I never wrote to his private address):\n\n  yes, you did, you lying moron.  your last message posted here was mailed\n  to me, too, which I *EXPRESSLY* do not want anyone to do, and I did not\n  see it as news until many hours later.  it arrived here 14:10 UTC, and my\n  response was mailed back 14:49 UTC, but not delivered to your cretinous\n  mail system until 22:02 UTC because it's a piece of shit, like you are.\n\n  I most certainly would not mail a creep like you if you had not invaded\n  my mailbox, which I certainly took to be a new low on your part, however\n  much that actually requires on your part.\n\n  it does not surprise me that you don't know what you're doing or are\n  lying through your teeth about not sending me private mail, whichever is\n  more telling about you.\n\n  but _do_ take my advice.  mother earth needs break and the nutrients you\n  block from recycling by staying alive and polluting the whole place.\n\n#:Erik\n\nFeb 28 14:10:55 arcana sendmail[14012]: AA14012: message-id=<002701bf81f5$96f013f0$bbc1b3c3@mycomputer>\nFeb 28 14:10:55 arcana sendmail[14012]: AA14012: from=<jblazi@netsurf.de>, size=7692, class=0, received from smtp-ham-1.netsurf.de\nFeb 28 14:11:02 arcana sendmail[14014]: AA14012: to=<erik@naggum.no>, delay=00:00:07, stat=Sent, drop=/home/erik/bin/acceptmail\n\n",
          "references": [],
          "thread_id": "private_message_received_from_en"
        },
        {
          "id": "3160831734652382@naggum.no",
          "subject": "Re: Private message received from EN",
          "author_id": "erik_naggum",
          "date": "2000-02-29",
          "display_date": "02/29/2000",
          "content": "\nSubject: Re: Private message received from EN\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/29\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160831734652382@naggum.no>\n\n* \"Janos Blazi\" <jblazi@netsurf.de>\n| Erik, I apologize for that.  Of course I believe you.  Please take my word of\n| honor that I did not do it intentionally.\n\n  that is by now irrelevant, since you posted my reply to you.  no apology\n  can ever be accepted from people who take revenge first and apologize\n  later, since they will repeat the act of revenge the next time, too.\n  viz, your posting it here _was_ intentional and typical of your blind and\n  phenomenally stupid destructiveness.  there is no way you can make amends\n  for this action, but you can realize that you are so stupid you must shut\n  up to avoid getting into even more trouble.  can you do that?  NOW?\n\n| Of course I did not like the content of you message.\n\n  you're a blathering idiot, Janos.  that you don't like something or feel\n  hurt is not and never can be a carte blanche for the kind of braindamaged\n  and uncontrollable destructiveness that is the core of your personality.\n\n  and your word of _honor_?  who the hell do you think you are fooling?\n  you're the least _honorable_ person I haver ever had the displeasure to\n  deal with.  a worse hypocrite than you has never posted anywhere I have\n  read anything.  a purported fan of _tolerance_ who is so mind-bogglingly\n  irrational in his destructiveness when it is precisely his tolerance that\n  is demanded can have no honor at all, because he only wants _others_ to\n  tolerate his vile actions.  you can't change this by now, Janos.  we all\n  know exactly what you're made of, now, and all you can do is put a lid on\n  it, and die with the shame of knowing that you have been fully exposed.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "private_message_received_from_en"
        },
        {
          "id": "3160863795303970@naggum.no",
          "subject": "Re: Private message received from EN",
          "author_id": "erik_naggum",
          "date": "2000-03-01",
          "display_date": "03/01/2000",
          "content": "\nSubject: Re: Private message received from EN\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/01\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160863795303970@naggum.no>\n\n* Christopher Browne\n| . o O ( Is this topical material about Lisp? )\n| \n| Nope, this has nothing to do with Lisp.\n\n  this not news to anyone but Janos Blazi.  could you help him understand?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "private_message_received_from_en"
        },
        {
          "id": "3161358055042645@naggum.no",
          "subject": "Re: Private message received from EN",
          "author_id": "erik_naggum",
          "date": "2000-03-06",
          "display_date": "03/06/2000",
          "content": "\nSubject: Re: Private message received from EN\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/06\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161358055042645@naggum.no>\n\n* Stig Hemmer <stig@verden.pvv.ntnu.no>\n| Ouch.\n\n  why are you showing us Touched by an Angel episodes in comp.lang.lisp,\n  parading like that with your cheap retail halo like they aren't a dime a\n  dozen?  don't you have any better soul to save, such as your own?\n\n  I'm so ... _intrigued_ by the evolutionary refuse that keeps crawling out\n  of the wood-work to share their putrid mind with the world.  it's amazing!\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "private_message_received_from_en"
        }
      ],
      "post_count": 4,
      "first_post_date": "2000-02-29",
      "last_post_date": "2000-03-06"
    },
    {
      "id": "that_place.._(was:_how_to_make_a_mutually_recursiv",
      "title": "That place.. (was: How to make a mutually recursive macro and  function)",
      "posts": [
        {
          "id": "3161257553467929@naggum.no",
          "subject": "Re: That place.. (was: How to make a mutually recursive macro and  function)",
          "author_id": "erik_naggum",
          "date": "2000-03-05",
          "display_date": "03/05/2000",
          "content": "\nSubject: Re: That place.. (was: How to make a mutually recursive macro and  function)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/05\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161257553467929@naggum.no>\n\n* \"Fernando D. Mato Mira\" <matomira@iname.com>\n| While we are at it, it's pretty amazing no implementor has added call/cc\n| yet.\n\n  maybe, but much less amazing than that some still believe in call/cc.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "that_place.._(was:_how_to_make_a_mutually_recursiv"
        },
        {
          "id": "3161342090902304@naggum.no",
          "subject": "Re: That place.. (was: How to make a mutually recursive macro and   function)",
          "author_id": "erik_naggum",
          "date": "2000-03-06",
          "display_date": "03/06/2000",
          "content": "\nSubject: Re: That place.. (was: How to make a mutually recursive macro and   function)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/06\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161342090902304@naggum.no>\n\n* \"Fernando D. Mato Mira\" <matomira@iname.com>\n| And even less amazing than that some believe call/cc is useless\n\n  and who would that be?  why exaggerate a technical argument into rampant\n  stupidity?\n\n  _nobody_ who understands it believes call/cc is _useless_.  that's not\n  just way too strong a word, it's missing the point _entirely_.  given a\n  particular choice of function calling model, call/cc is very definitely\n  elegant and the right implementation choice.  the question is whether\n  that model is _productive_ in a much greater context than just whatever\n  you can cram into a thin, elegant specification.\n\n  no model is _useless_, either, as Scheme's model has certainly explored\n  territory that otherwise would not be explored.  all in all, a valuable\n  contribution to computer science.  that doesn't mean we have to _do_ it\n  that way in practical implementations.  research is _supposed_ to produce\n  a lot of \"known dead ends\" so other researchers and practitioners alike\n  know where _not_ to go.  in this particular instance, Scheme's function\n  call model is where you must _not_ go.\n\n  that it's time to discard a model doesn't mean it's useless in every or\n  even many respects, but there might well be some particular respect in\n  which some jerk would find it completely useless and extrapolate from\n  that to the general case.  I find such arguments completely useless and\n  excessively disrespectful towards the research activity that led to it.\n\n  in short: being wrong is _not_ being useless.  being stupid is, however.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "that_place.._(was:_how_to_make_a_mutually_recursiv"
        },
        {
          "id": "3161299902310489@naggum.no",
          "subject": "Re: That place.. (was: How to make a mutually recursive macro and   function)",
          "author_id": "erik_naggum",
          "date": "2000-03-06",
          "display_date": "03/06/2000",
          "content": "\nSubject: Re: That place.. (was: How to make a mutually recursive macro and   function)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/06\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161299902310489@naggum.no>\n\n* Christopher Browne\n| What it *really* says is that Scheme has some significant differing\n| underlying assumptions from Common Lisp.\n\n  we all know this to be a deep and fundamental truth, already.\n\n| b) The \"call/cc thing\" parallels the \"tail recursion thing\" where\n|    Scheme requires that implementations have some common primitives.\n|    CL requires no such thing, which provides implementors greater\n|    flexibility, but which diminishes some of the expectations on how\n|    things work that can be made with Scheme.\n\n  this is also one of the differences between the Scheme and the Common\n  Lisp communities.  the Scheme community uses the specification as the\n  source for its expectations and when it can't find something in the\n  specification for Common Lisp, claims that Common Lisp cannot expect it.\n  the Common Lisp community uses the specification and the common sense of\n  vendors and the functioning of the market as its source of expectations,\n  and consequently doesn't have a problem with any of the things that\n  Scheme people have problems with in Common Lisp.  on the other hand, the\n  Common Lisp community recognizes the Scheme community's need for its very\n  thin specification, and argues that the Scheme community cannot expect to\n  have any useful functions in a Scheme environment at all, to which the\n  Scheme community always responds that every Scheme implementation has a\n  lot of goodies that you can rely on, and then there's slib and whatnot,\n  so in the end it seems rather specious of the Scheme adherents to argue\n  that the Common Lisp community cannot expect tail-call merging, which\n  every implementation offers given sufficent optimization settings.\n\n| c) The *problem* with Scheme (which the SRFI process may help remedy)\n|    that the \"call/cc\" thing shows off is that call/cc was intended to\n|    be treated as a *primitive* that would be used to implement control\n|    structures.\n\n  and Common Lisp has all those control structures that Scheme people\n  implement with call/cc.  it's like giving programmers access to a\n  primitive of creating, linking, and unlinking call frames, but no\n  function call primitive.  (Scheme doesn't have funcall, as you know. :)\n\n| In short, it's not that call/cc is particularly bad, it's that call/cc is\n| merely a primitive, and isn't widely useful until you use the primitive\n| to build specifically useful structures.\n\n  which implies that the usefulness of implementing these control\n  structures with call/cc has to be questioned, since none of the Common\n  Lisp implementations even use the primitive operation call/cc underneath,\n  and they also don't generally heap-allocate call frames, but remain with\n  the stack-allocation paradigm.  in short, call/cc is a primitive that is\n  too primitive for its own good: it demands a particular way to do things\n  that doesn't reflect how people have come to conclude they should be\n  done.  the same is true of Scheme's tail calls.  it doesn't make sense to\n  force every tail call to be a jump, as it messes with argument passing\n  conventions and stack unwinding and many forms of debuggability and a\n  host of other issues tha makes communication with other languages hard.\n\n  so in my view, Scheme's core function call model is simply a mistake, and\n  both tail calls and call/cc make the design mistakes explicitly visible\n  to the users.  learning from such mistakes is an important part of moving\n  forward in language design, and this may indeed be why no other language\n  has picked up on these ideas, despite having picked up on a number of\n  other valuable contributions from Scheme.  some of this reflects badly on\n  \"adjacent ideas\" in Scheme, too.\n\n  again in my view, there are probably mistakes in Common Lisp's design\n  that makes it hard for people to pick up on adjacent ideas, too.  for one\n  thing, I have started to believe that the use of upper-case symbol names\n  is a serious communications bottleneck with other languages that we need\n  to talk to these days.  it's not that we can't overcome it, it's that\n  it's such a hassle to overcome it.  and it's not a technical issue, just\n  like start-up time is not a technical issue, it's a matter of perception\n  and how we approach contrary views when they necessarily come up.\n  \n#:Erik\n\n",
          "references": [],
          "thread_id": "that_place.._(was:_how_to_make_a_mutually_recursiv"
        }
      ],
      "post_count": 3,
      "first_post_date": "2000-03-05",
      "last_post_date": "2000-03-06"
    },
    {
      "id": "franz_trial_version_5.0",
      "title": "Franz Trial Version 5.0",
      "posts": [
        {
          "id": "3161297474807741@naggum.no",
          "subject": "Re: Franz Trial Version 5.0",
          "author_id": "erik_naggum",
          "date": "2000-03-06",
          "display_date": "03/06/2000",
          "content": "\nSubject: Re: Franz Trial Version 5.0\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/06\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161297474807741@naggum.no>\n\n* David Ward <daveward@telusplanet.net>\n| I have just installed the Franz Allegro CL Trial version 5.0\n\n  upgrade to version 5.0.1.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "franz_trial_version_5.0"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-03-06",
      "last_post_date": "2000-03-06"
    },
    {
      "id": "types_(in_arrays)",
      "title": "Types (in arrays)",
      "posts": [
        {
          "id": "3161298360200823@naggum.no",
          "subject": "Re: Types (in arrays)",
          "author_id": "erik_naggum",
          "date": "2000-03-06",
          "display_date": "03/06/2000",
          "content": "\nSubject: Re: Types (in arrays)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/06\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161298360200823@naggum.no>\n\n* Andrew Cooke <andrew@andrewcooke.free-online.co.uk>\n| I have a program that needs to store many arrays of words (16 bits).\n\n  the available types are then (unsigned-byte 16), (signed-byte 16), (mod\n  65536), (integer 0 65535), (integer -32768 +32767), etc, which all should\n  mean the same thing: 16 bits of allocated data per element of the array.\n  if they don't behave the same, you probably have a broken Common Lisp\n  implementation.\n\n| My questions are really:\n| - How do I know which type specifiers are simple enough for a compiler\n| to understand the implications (1 clearly wasn't - although I may be\n| wrong in thinking it is a valid type specifier)?\n\n  the function upgraded-array-element-type will return the internal type it\n  has deemed most optimal for the array element type you have requested.\n\n| - Why does case (3) fail silently?\n\n  probably because the implementation only checks for types it knows, and\n  consider it risky to comment on stuff it doesn't know about.\n\n| - How are types used?  There seem to be several different things going\n| on at once - memory size allocation, testing when new values are stored,\n| initial value allocation (I get zeroes rather than nill if the type is\n| numeric, for example).\n\n  this is a very big question.  the simple answer is that the vendor has\n  made a number of decisions that are believed to give optimal performance,\n  both in time and space, given the type information you have provided.\n  now, this is not quite the useless answer it looks like, because it means\n  that each vendor will make \"personal\" decisions about what constitutes\n  \"optimal performance\" -- and these decisions will naturally differ quite\n  a bit from person to person.  one rule of thumb prevails, however: useful\n  optimizations always reflect the capabilities of the aunderlying hardware,\n  so you have to have a fairly good grasp of how the implementation uses\n  machine resources to make the decisions.  I'll leave it at that for now,\n  since this is issue that very quickly becomes suiteable for comp.arch.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "types_(in_arrays)"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-03-06",
      "last_post_date": "2000-03-06"
    },
    {
      "id": "time_in_lisp",
      "title": "Time in Lisp",
      "posts": [
        {
          "id": "3161318001993721@naggum.no",
          "subject": "Re: Time in Lisp",
          "author_id": "erik_naggum",
          "date": "2000-03-06",
          "display_date": "03/06/2000",
          "content": "\nSubject: Re: Time in Lisp\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/06\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161318001993721@naggum.no>\n\n* \"Frederick C. Gibson, Architect\" <Frederick@gibson-design.com>\n| I'm working on a CLOS classification system and I'd like to add a time stamp\n| to objects as I create them.  Does anyone know of any public domain time\n| functions that can read the internal clock and output with date and time?\n\n  I'm still working on the code to accompany the paper I gave at LUGM, but\n  it is in production use with a client: http://www.naggum.no/lugm-time.html.\n\n  I expect it to be ready for publication in the not too distant future.\n  let me know if you're a willing test subject.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "time_in_lisp"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-03-06",
      "last_post_date": "2000-03-06"
    },
    {
      "id": "erik_(was_re:_allegro_cl_5.0_win32)",
      "title": "Erik (Was Re: Allegro CL 5.0 Win32)",
      "posts": [
        {
          "id": "3161258797199263@naggum.no",
          "subject": "Re: Erik (Was Re: Allegro CL 5.0 Win32)",
          "author_id": "erik_naggum",
          "date": "2000-03-05",
          "display_date": "03/05/2000",
          "content": "\nSubject: Re: Erik (Was Re: Allegro CL 5.0 Win32)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/05\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161258797199263@naggum.no>\n\n* Kenneth P. Turvey\n| He brings it on himself.\n\n  and in what way didn't you bring what you got on yourself?\n\n  it's _so_ amusing to watch people who can't think in principles, but let\n  their stupid likes and dislikes of other _people_ judge their reactions\n  to what they _do_.  some day, you'll figure out what this means, Kenneth.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "erik_(was_re:_allegro_cl_5.0_win32)"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-03-05",
      "last_post_date": "2000-03-05"
    },
    {
      "id": "a_modest_proposal_(long)",
      "title": "A modest proposal (long)",
      "posts": [
        {
          "id": "3160943130779380@naggum.no",
          "subject": "Re: A modest proposal (long)",
          "author_id": "erik_naggum",
          "date": "2000-03-01",
          "display_date": "03/01/2000",
          "content": "\nSubject: Re: A modest proposal (long)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/01\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160943130779380@naggum.no>\n\n* Bill Newman\n| It's not just a beginner problem. The program\n|   (DEFUN FOO (X) (BAR X))\n|   (DEFVAR X)\n| means something different from\n|   (DEFVAR X)\n|   (DEFUN FOO (X) (BAR X))\n| And if the DEFVAR is in one file, and the DEFUN is in another, then the\n| semantics change silently depending on what order you compile them in.\n\n  I maintain that this is a beginner problem, only.  real Lisp programmers\n  don't call their global variables \"X\".  real Lisp programmers use\n  packages if they want their symbols to stay of other people's face.  real\n  Lisp programmers know about unintern, too.\n\n| I'd say this is a design flaw that makes them not particularly safe.\n\n  it's a design flaw to you because your notion of safe is wrong.\n\n| (By the way, I've considered making SBCL issue STYLE-WARNINGs for any\n| SPECIAL use of non-*FOO*-style symbols, and any non-SPECIAL use of\n| *FOO*-style symbols, to detect problems like this. But I'm a little\n| uncomfortable embedding informal naming conventions in the compiler, so\n| I've avoided doing this so far. Does anyone have any opinions on whether\n| such STYLE-WARNINGs would be The Right Thing?)\n\n  I have already said what I think is the right thing here: demand that\n  there be lexically apparent declarations that reiterate the special\n  status of symbols so declared globally.  lacking such a declaration, you\n  might issue a style-warning for free variables even if you know they are\n  globally declared special.  it will lead to slightly more verbose code,\n  but the excuse to be making invisible, pervasive changes would go away.\n\n| Yes, I also really wish there was a standard way to query \"is symbol FOO\n| special?\" And \"what's the value of the optimization property BAR?\" too..\n\n  precisely, and this is the _only_ problem worth solving as I see it.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "a_modest_proposal_(long)"
        },
        {
          "id": "3160886469599216@naggum.no",
          "subject": "Re: A modest proposal (long)",
          "author_id": "erik_naggum",
          "date": "2000-03-01",
          "display_date": "03/01/2000",
          "content": "\nSubject: Re: A modest proposal (long)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/01\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160886469599216@naggum.no>\n\n* Keke Abe\n| Is there anything particularly dangerous when a beginner equates\n| CL's special variables to global vars in other languages?\n\n  I can't answer for Erann, but my take on this is that beginners who get\n  confused about this will remain confused for a few days, and then get it\n  or get over it, as in: not worrying about it even if they don't get it.\n\n  if we change the semantics of the language from what said confused people\n  will find described in textbooks and other reference materials and when\n  searching the net, the number of days of confusion can only increase, not\n  the least because half the vendors will think this is a lame idea and not\n  implement it, and the other half will do it better than the lame code and\n  so the only thing we will succeed in is in destroying a very powerful\n  mechanism in Common Lisp that every other language is sadly lacking:\n  transparent, safe, and convenient global, dynamic variables.  all for the\n  purported, but obviously unrealizable benefit of reducing the number of\n  confused people and their posting frequency to comp.lang.lisp.\n\n  still, it would be nice if we had some simple programmatic access to the\n  specialness of a symbol.  this would have been covered by the environment\n  access functions that were not included in the standard.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "a_modest_proposal_(long)"
        },
        {
          "id": "3160942638240195@naggum.no",
          "subject": "Re: A modest proposal (long)",
          "author_id": "erik_naggum",
          "date": "2000-03-01",
          "display_date": "03/01/2000",
          "content": "\nSubject: Re: A modest proposal (long)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/01\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160942638240195@naggum.no>\n\n* Erann Gat\n| I see I have not made myself clear.\n\n  I see no evidence of that.  I think we have a fairly good understanding\n  of your issue.  all the silly syntax detracted from its delivery, but\n  you've been clear enough.\n\n| We are already using a typographical convention to distinguish lexical\n| and special variables.  We already know that we get into trouble when we\n| don't adhere to that convention.  Why not move the burden of applying\n| that convention from the programmer to the compiler?\n\n  because we would want to make our own conventions in code where it is\n  safe to make them.  and people don't _actually_ get into trouble in the\n  first place, except the first few days they are confused about this.\n\n| I also wonder how many of you BIND haters are also LOOP haters.  I am\n| really beginning to worry that people have lost sight of the fact that\n| an S-expression with just one level of parens is still an S-expression.\n\n  no need to worry about that.  I like loop, I don't if*, and I don't like\n  your bind or any of the numerous other _gratuitous_ syntax-heavy ideas\n  people seem to get with an alarming regularity whenever they see a need\n  for some miniscule improvement to the language.  it's as if they don't\n  like simple syntax to begin with, and rush to solve any semantic issue\n  with syntax.  I find this disturbing, but nonetheless indicative of\n  something much more important: the language changers don't really grok\n  Common Lisp.\n\n| But symbol macros can only be established with lexical scope, so if\n| there is a symbol macro it must be lexically manifested.  Global symbol\n| macros would be truly problematic.\n\n  take a look at define-symbol-macro some day and weep, then.  I love the\n  fact that we have global symbol macros!  I also love the fact that we\n  have constants, which also causes pervasive differences in behavior, and\n  there's no truly established convention for them.  I happen to think that\n  special variables is one of Common Lisp's truly great idea.  what I want,\n  in response to your \"it's EVIL!\" is a programmatic means to query the\n  system for the status of a symbol.  `describe' and friends help me as a\n  user who gawks at the screen, but that is clearly insufficient.\n\n  again, there is a need to change the language to make it more amenable to\n  beginners and experienced users alike: unlike all other languages now in\n  current and widespread use, Common Lisp violates the notion that what you\n  see is what you get with respect to the _names_ of the symbols.  if\n  symbol-value is such a problem for beginners that it needs language-smith\n  attention, wouldn't you be interested in solving a _real_ problem that\n  would have far-reaching consequences for our interoperability with other\n  languages, other textbooks, other people?  it's not a question of case,\n  it's a matter of making (setf (readtable-case *readtable*) :preserve)\n  work the way people _actually_ expect it to.  think about it.  please.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "a_modest_proposal_(long)"
        },
        {
          "id": "3160870773012596@naggum.no",
          "subject": "Re: A modest proposal (long)",
          "author_id": "erik_naggum",
          "date": "2000-03-01",
          "display_date": "03/01/2000",
          "content": "\nSubject: Re: A modest proposal (long)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/01\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160870773012596@naggum.no>\n\n* Erann Gat\n| *You* might not have DEFVARed X, but how do you know that Joe didn't?\n\n  it seems to me that this the fundamental question.  the answer lies in\n  the implementation's excellence in implementing the function `describe'\n  and any other environment-querying functions.\n\n  however, there _is_ something we can and should do: add explicit support\n  for retrieving this important piece of information about a symbol, apart\n  from the rather obvious user interface issues like querying the system\n  when at a symbol name in Emacs.  the compiler and the interpreter could\n  also be asked to produce warnings about special variables for those who\n  need them.  (I'd favor declaring variables special locally as a nice way\n  to document the known special effects and also silence such warnings.)\n\n  removing special variables because they confuse a few people is a typical\n  \"modern\" reaction to the lack of diligence and effort that \"modern\" users\n  are no longer expected to expend in learning anything.  this is simply a\n  beginner's issue.  Common Lisp used to cater to experienced programmers\n  at the cost of having to learn it, like a _skill_, something people of\n  reasonable competence levels would _value_.  such is of course terribly\n  politically incorrect in this day and age, where blathering idiots get to\n  vote as many times as they can by virtue of forgetting the question and\n  anyone with any experience at all is considered prejudiced by virtue of\n  not answering all questions up for vote with a blank stare.\n\n  I vote that Common Lisp remain a language that needs to be learned and\n  studied, and instead focus our attention on stuff that actually affects\n  users of all categories much more than this trifling issue, like being\n  compatible with the notion in languages with which we would like to\n  communicate of what constitutes a symbol name: the actual, literal\n  sequence of characters (dollar signs included), not some case-mangled\n  version of same.\n\n  I also vote that somebody write \"the complete idiot's guide to special\n  variables\" instead of proposing silly language changes.\n\n| $x == (symbol-value 'x)\n\n  I think \"Common Perl\" would be a good name for your modified language,\n  with syntax in macros and equal signs and all.  yuck.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "a_modest_proposal_(long)"
        },
        {
          "id": "3160966858202840@naggum.no",
          "subject": "Re: A modest proposal (long)",
          "author_id": "erik_naggum",
          "date": "2000-03-02",
          "display_date": "03/02/2000",
          "content": "\nSubject: Re: A modest proposal (long)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/02\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160966858202840@naggum.no>\n\n* Erann Gat\n| The problem is not special variables.  The problem is the way you tell\n| Lisp which variables you want to make special and which you don't.\n\n  so let me disagree vociferously with that, too.  if we make necessary\n  things inconvenient to express, it is not their expression that will\n  suffer the most, but common recognition of their necessity.  the fact\n  that special variables solve a problem that exist in _every_ programming\n  language so conveniently, namely how to ascertain proper restoration of\n  global variables, means that people aren't going to reinvent tricks with\n  unwind-protect and the like (if they know about unwind-protect -- Kent\n  Pitman has made the cogent argument that languages can be judged on the\n  existence of such a language feature -- I'll argue that the same applies\n  to programmers and whether they know about it).\n\n  as soon as you start to make these special variables stand out as the\n  wart on the language that you appear to believe they are, people will\n  naturally avoid them (and the more so the more weirdo syntax soup you\n  introduce, the threat of which I now realize is part of my objection to\n  your syntax-heavy proposal), and choose the next best thing that looks\n  like it could be sufficiently convenient.  then they start to make buggy\n  or needlessly verbose code, which they'll loathe.  you're rocking the\n  boat and making life miserable for those who _need_ special variables and\n  need them _not_ to look _too_ special, because that destroys their very\n  significant convenience factor.  I say: don't do that.  solve the actual\n  problems, don't just push your special brand of cosmetics.\n\n| The issue is not just one of querying.  It's also one of control.  There's\n| no way to undo the effects of a defvar short of uninterning the symbol.\n\n  so let's find a way to do that, instead, then.  (how hard can this be?)\n\n  I think a Common Lisp environment needs universal functionality to \"undo\"\n  or \"kill\" all definition forms.  Allegro CL has a nifty feature to kill\n  various definitions from the Emacs interface, and I use it seldom enough\n  to appreciate it very highly every time, but it does not accept defvar.\n  (I'll file a request for enhancement for that.)  this might be considered\n  annoying, but in the meantime, here's a couple tiny functions to muck\n  with the gory internals of symbols in a way that is guaranteed to make a\n  whole slew people want to puke violently, but if they get over it and\n  realize that Common Lisp is all about _exporting_ an elegant interface to\n  lots of really hairy stuff to begin with, they might actually rejoice and\n  use these functions.\n\n(in-package :excl)\n\n#+allegro-v5.0.1\n(defun symbol-special-p (symbol)\n  (declare (optimize (speed 3) (safety 0)) (symbol symbol))\n  (check-type symbol symbol)\n  (if (and (not (eq nil symbol))\n\t   (zerop (ldb (byte 1 #.(system::mdparam 'compiler::md-symbol-flag-constant-bit))\n\t\t       (excl::sy_flags symbol))))\n    (not (zerop (ldb (byte 1 #.(system::mdparam 'compiler::md-symbol-flag-globally-special-bit))\n\t\t     (excl::sy_flags symbol))))\n    nil))\n\n#+allegro-v5.0.1\n(defun (setf symbol-special-p) (special symbol)\n  (declare (optimize (speed 3) (safety 0)) (symbol symbol))\n  (check-type symbol symbol)\n  (if (and (not (eq nil symbol))\n\t   (zerop (ldb (byte 1 #.(system::mdparam 'compiler::md-symbol-flag-constant-bit))\n\t\t       (excl::sy_flags symbol))))\n    (setf (excl::sy_flags symbol)\n      (dpb (if special 1 0)\n\t   (byte 1 #.(system::mdparam 'compiler::md-symbol-flag-globally-special-bit))\n\t   (excl::sy_flags symbol)))\n    (error \"Cannot change special status of constant symbol ~S.\" symbol)))\n\n  perhaps needless to say, you can hurt your Allegro CL system with the\n  latter function, even though I have tried to restrict a few particular\n  damages that users are likely to try (and I know how to restrict).\n\n  if you don't have Allegro CL 5.0.1, this won't necessarily fail, but _you_\n  had to remove the read-time conditionals so _you_ take the responsibility.\n\n| >   again, there is a need to change the language to make it more amenable to\n| >   beginners and experienced users alike: unlike all other languages now in\n| >   current and widespread use, Common Lisp violates the notion that what you\n| >   see is what you get with respect to the _names_ of the symbols.\n| \n| Maybe it would help to review the distinction between a variable and a\n| symbol (and the name of a symbol) just to make sure we are all on\n| the same page.\n\n  find, but sometimes, it isn't everybody else who need to be on your page.\n\n| The point is that none of this has anything to do with symbol names.\n\n  duh.  I'm trying to redirect your attention to a worth-while problem,\n  entirely _away_ from messing with stuff you shouldn't be messing with.\n\n| I thought that's what I was doing, but it seems I still have not made\n| myself clear.   You seem to think that I am saying that the problem is\n| the existence of dynamic variables and symbol-value.   I'm not saying\n| that at all.   What I am saying is that the way things currently stand,\n| when you write 'X' you can't in general know whether what you've written\n| is a reference to a stack frame or a slot in an object on the heap.\n| And, in fact, as you yourself pointed out the meaning of X can change\n| over time if you are running interpreted.  IMO that's bad.\n\n  and IMNSHO, it isn't bad at all.  I have pointed out that we need a few\n  accessors into the environment to solve your uncertainty problem, and\n  perhaps we need a `notspecial' or `lexical' declaration to be able to\n  undo the pervasive effects of the `special' declaration.  however, I care\n  so much about the language that I'm unwilling to consider your proposal\n  when I understand the issues so much better than you do and I consider\n  your proposal to be a major disturbance over a petty issue that mainly\n  has to do with a disportional sense of uncertainty.  now, I fully\n  recognize that uncertainty is one of those things that make people go\n  nuts and that it is vitally important in a community to avoid swarms of\n  neurotics who run around with proposals that are mainly intended to\n  affect their mental state in some vaguely positive way, so I instead\n  propose something that will make the uncertainty go away by adding a very\n  low-level certainty instead of making any changes to superficial features\n  that will take yet more forms as the swarm of neurotics has only been\n  decimated for now, not actually cured of their unhealthy uncertainty.\n\n| >  it's not a question of case,\n| >   it's a matter of making (setf (readtable-case *readtable*) :preserve)\n| >   work the way people _actually_ expect it to.  think about it.  please.\n| \n| It would help if you would stop talking in riddles.\n\n  geez.  there are no riddles.  I'm talking about something other than you\n  do, because I think what you're talking about is counter-productive.  you\n  missed that point entirely when you thought I was still talking about\n  your concerns over specialness when I talked about symbol names.  I'm a\n  little concerned with the breakdown of communication that occurs when\n  people don't notice that others aren't talking about the same thing they\n  are, anymore, but just keep on and on about whatever they had in mind.\n\n| Works the way I'd expect it to.\n\n  so try typing in (setf (readtable-case *readtable*) :upcase) and tell me\n  what you expect to happen and/or that this is not a useful thing to do.\n  (note again that this is no longer a question of special variables.)\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "a_modest_proposal_(long)"
        },
        {
          "id": "3161015458973462@naggum.no",
          "subject": "Re: A modest proposal (long)",
          "author_id": "erik_naggum",
          "date": "2000-03-02",
          "display_date": "03/02/2000",
          "content": "\nSubject: Re: A modest proposal (long)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/02\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161015458973462@naggum.no>\n\n* Erann Gat\n| Pretty hard, apparently.  My first choice would have been to add (declare\n| (lexical ...))  But that was tried and rejected be people who understand\n| the problem much better than I do.\n\n  proposals are rejected or adopted in context.  if a good idea is served\n  alone or in a context that is not conducive to furthering principles that\n  are valued higher by others than some small improvement, it will, as it\n  should, be rejected.  how can _anyone_ have a problem understanding this?\n  have you never proposed something, had it rejected, then seen it picked\n  up by others only to be adopted?  this is clearly not because people hate\n  you, but because you didn't do your homework, and somebody else did.\n\n| Thank God we have Erik to guide us to worthwhile problems!\n\n  huh?  were you _consciously_ trying to guide us to a _worthless_ problem,\n  or is it wrong for _me_ to guide to worthwhile problems, while _you_ can\n  pick worthwhile problems at will?  no wonder your proposals don't get\n  accepted if this is how you deal with contributions.  sheesh!\n\n| >   and IMNSHO, it isn't bad at all.  I have pointed out that we need a few\n| >   accessors into the environment to solve your uncertainty problem, and\n| >   perhaps we need a `notspecial' or `lexical' declaration to be able to\n| >   undo the pervasive effects of the `special' declaration\n| \n| Like I said, this was proposed and rejected.  Why beat a dead horse?\n\n  I feel like I'm spoonfeeding a child.  it's because it's a question of\n  getting agreement among people who have already made up their mind about\n  a number of issues you may not know about, and this means you must not\n  piss people off with pure _drivel_.  as I have strongly indicated, your\n  inclusion of silly new syntax is a _good_ reason to reject all of your\n  proposal.  like the old saying goes, with all this shit, there must be a\n  pony somewhere, take away the crud, and what's left may not be a dead\n  horse.  but feel free to blame somebody for your failure to get agreement.\n\n| And I care so much about the language that I'm unwilling to drop the\n| matter just because some arrogant self-appointed guru says I should.\n\n  oh, geez, get _over_ yourself.  what's this, the emperor's new argument?\n  who do you think you're fooling?\n\n  isn't it just _too_ odd how often some doofus \"self-appoints\" someone\n  _else_ to some status to which they themselves would never actually\n  _self_-appoint themselves?  what's the point with such dishonesty and\n  such incredible silly behavior as to pretend that others _self_-appoint\n  themselves when in fact there's a lunatic at large who does both the\n  appointing and the accusation of such appointing all by himself?\n  whatever is _wrong_ with you?  you've come up with a bunch of really bad\n  thinking and it must be shot down fast before you revamp the whole\n  language, but still, there are a few good things in there and there's\n  some work that can be turned into productive ideas and proposals, but\n  what do you do?  you're only being silly and negative and concentrate on\n  dead horses and rejection.  and now you're out picking a silly fight?\n  what's the _point_ with this?  pull yourself _together_, damnit!\n\n| BTW, why would adding a LEXICAL declaration be any less disruptive than\n| allowing variable names of the form (special X)?  The vendors would still\n| have to change their implementations to support it.  Unlike other\n| declarations, you can't ignore SPECIAL/LEXICAL declarations and still\n| preserve correct semantics.  This fact alone indicates that declarations\n| are the wrong place for this information.\n\n  well, I don't generally and didn't now make just one big proposal and\n  feel personally defeated when it was rejected as a silly idea.  believe\n  it or not, but I have tried to figure out what would completely supersede\n  your silly idea such that even you would be happier with the solution.\n  this, however, is doomed to fail miserably as long as you only take the\n  negative views on everything, completely ignore the good stuff (notice\n  that I don't) I say, and huff and puff a lot instead of trying to solve\n  the _problem_ you have, the _adopted_ solution to which is very unlikely\n  to be whatever you dreamt up to begin with, anyway.  you're not being\n  constructive about this at all.  that annoys me to no end, because you\n  raise issues that need to be resolved, and the way you go about it, it's\n  unlikely that we will very find the consensus to resolve them.  again,\n  pull yourself together, damnit!\n\n| > | Works the way I'd expect it to.\n| > \n| >   so try typing in (setf (readtable-case *readtable*) :upcase) and tell me\n| >   what you expect to happen and/or that this is not a useful thing to do.\n| >   (note again that this is no longer a question of special variables.)\n| \n| I would expect to have to hold down the shift-lock key before I could\n| set the readtable case back to upcase.  Honestly, I don't see the problem\n| here.\n\n  OK, could you explain why it is unreasonable to think that holding down\n  the shift key while typing that line in is a _misfeature_?  can you\n  explain why it is unreasonable to give a conforming Common Lisp system\n  the ability to deal with :preserve _and_ lower-case, like beginners and\n  experts alike see in all the textbooks and examples on the Net and which\n  they have come to expect from _other_ languages they use?\n\n  I'm doing this also as an experiment to see if you can at all relate to\n  what other people tell you about their problems, since I have evidence\n  that you have a very hard time dealing with stuff you don't dream up on\n  your own, and if you can at least show that you can wrap your head around\n  another problematic issue, there might be grounds for figuring out what\n  would _really_ solve your other problems, without _having_ to accept your\n  proposals verbatim.  as I said, you have raised certain relevant issues\n  that I think are quite important, but only to be met with childish\n  bickering and an _incredibly_ stupid \"self-appointed guru\", instead of a\n  desire to help resolve the parts of your concerns that others respond\n  _well_ to.  I could do without the rampant stupidity, so what _is_ your\n  problem?  exercise some mental _focus_, dude!\n\n  sheesh!\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "a_modest_proposal_(long)"
        },
        {
          "id": "3160951975373812@naggum.no",
          "subject": "Re: A modest proposal (long)",
          "author_id": "erik_naggum",
          "date": "2000-03-02",
          "display_date": "03/02/2000",
          "content": "\nSubject: Re: A modest proposal (long)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/02\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160951975373812@naggum.no>\n\n* wnewman@my-deja.com\n| All I'm trying to claim is that this example shows that the problem is\n| not confined to beginners.\n\n  but your example doesn't show any such thing!  that people are not\n  following the asterisk convention is _not_ the problem.  the problem as\n  stated is that there's a lambda list or let binding somewhere with a\n  symbol in it that has special binding which comes as a _surprise_ to\n  people who are moderately (but not overly) intimate with the code.  do\n  you have evidence of that, or is this only more unfounded fear that there\n  _might_ be a problem?  incidentally, I recognize that there _might_ be a\n  problem, the solution to which is to make the system easier to query for\n  such information.  I don't see any other problems that need solving.\n\n  my philosophy, in case you need to have it stated to avoid speculating\n  about it, is that in order to serve the needs of any community, one must\n  never, _ever_ to cater to the needs of ignorants and novices except in\n  carefully controlled settings where the express purpose is to make them\n  non-ignorants and non-novices, such as school or training courses.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "a_modest_proposal_(long)"
        },
        {
          "id": "3161103283096688@naggum.no",
          "subject": "Re: A modest proposal (long)",
          "author_id": "erik_naggum",
          "date": "2000-03-03",
          "display_date": "03/03/2000",
          "content": "\nSubject: Re: A modest proposal (long)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/03\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161103283096688@naggum.no>\n\n* Erann Gat\n| Common Lisp is case-sensitive like people expect.\n\n  we might as well conclude at this time that special variables work just\n  the way people expect, because we make a semi-conscious decision to\n  ignore those values of \"people\" where \"expect\" returns false.  _some_\n  people, however, do not expect the same as you do, and they might even\n  react the same way you do to some aspect of special variables (\"it's\n  EVIL!\") to some aspects of upper-case symbol names.  it's _so_ amusing\n  that you don't get this.\n\n  the point being, put like a nice little riddle: those who have problems\n  with symbol-value are also likely have problems with symbol-name.\n\n| I don't know whether this last item is part of the standard or simply a\n| consequence of the default read table case being :upcase.\n\n  the symbols are all upper-case and Lisp has case conversion because the\n  languages that Lisp talked to had upper-case names and case conversion,\n  FORTRAN in particular.  since symbols are first-class citizens in Lisp,\n  and not in most other languages, we have been stuck with them in a way\n  that other languages haven't.  other languages have moved on to a much\n  richer character set (the upper-case thing was merely an artifact of the\n  terminal equipment and punched cards on which the code was written) and\n  have dispensed with case conversion because it loses information that is\n  now more readily available.\n\n| In any case, to make CL act like every other language out there we'd have\n| to 1) change the default readtable-case to :preserve and 2) change the\n| names of all the standard symbols.\n\n  that's the straightforward answer, but now you're going into this\n  \"there's only one solution to this problem, and that's the one I just\n  dreamt up, but since I didn't like the problem, I dreamt up a bad\n  solution, so therefore the problem is also bad\" mode which seems to have\n  an incredible attraction to you.  I'm explicitly trying to get you _off_\n  of that path.  can you work with me on this, please?\n\n  Allegro CL has the ability to do just what you're describing, and has had\n  it forever because of the Franz Lisp legacy -- it was lower-case and case\n  sensitive.  today, excl:set-case-mode actually converts symbol names from\n  upper-case to lower-case.  Allegro CL is actually built with lower-case\n  symbol names, upper-cased as a step in building the distributed version\n  to customers.  this is not a problem for Franz Inc, and not a problem for\n  their customers.  many customers also revert to lower-case mode simply\n  because it makes a lot more sense than upper-case mode does at this time.\n  that they don't talk about it has to do with the fact that some people\n  get _really_ upset whenever case is brought up, but it finally dawned on\n  me that we're _not_ talking about case, we're talking about which other\n  languages we want to communicate with, and case issues _follow_ from\n  that.  it's not as if case is the primary factor of choice and we just\n  happen to like FORTRAN better than C.  it's that to talk to FORTRAN, you\n  had to use the same case FORTRAN did, which were upper-case, but to talk\n  to C, you have to use the same case C does, which is in both cases.  it's\n  a question of communication.  of course, we can demand that other people\n  talk to us, and refuse to listen to their arguments.  people who do that\n  on an habitual basis in real life, too, probably stick with upper-case in\n  Common Lisp, as well.\n\n  yet, however you wish to regard this, case-swapping is not something you\n  do without vendor support.  Allegro CL already has all the support it\n  needs.  in the case of CLISP or CMUCL, you're free to fix it yourself in\n  any way you want that doesn't have to be \"portable\" at all.  that leaves\n  us with what Harlequin and Digitool would do if they were asked.\n\n| Straightforward implementation-specific hacks won't work because the\n| symbol name is stored in many places, not just in the symbol.\n\n  so let's do non-straightforward implementation-specific hacks, then.\n  (again, how hard can it possibly be to realize that when you have found\n  an obvious flaw in a given _solution_, you keep looking for solutions,\n  you don't just give up and shout the _inverse_ of \"eureka!\" and declare\n  the _problem_ dead and buried.)\n\n| You could make duplicate symbols with lower-case names and copy their\n| value, function, and plist slots, but this would probably break\n| most compilers, which probably have code like (case (car form) (if ...\n\n  again, I would prefer to engage the creative part of the brain, not the\n  propaganda machine, when we encounter engineering problems.  obviously,\n  this idea is really stupid, and so it's an indirect insult to would-be\n  proposers to assume that they haven't even thought about it.  but, hey,\n  this is also something I'm trying to get you away from resorting to.\n\n  Common Lisp is often hailed as suitable for writing mini-languages.  now,\n  instead of writing a _new_ mini-language, I think it's important that we\n  find a way for a fully conforming ANSI Common Lisp implementation to be\n  able to handle source code in :preserve mode, written in lower-case.\n  this is _obviously_ not a problem, since Common Lisp is good at writing\n  mini-languages.  right?  right!  let's see if it is possible to turn code\n  written with :preserve and lower-case expectations into code that can be\n  compiled without changing much anything.  this should be eminently doable\n  for the vast majority of cases.  (if there be residiual problems, I hope\n  we can avoid more propaganda machine output and instead focus on solving\n  them or theorizing about the problems, not just sit down and wimper.)\n\n| Or you could just tell beginners not to mess with readtable-case at all\n| since the :upcase default generally does the Right Thing.\n\n  and that's what I've been telling you to do with your \"special\" hacks.\n  I'm relieved that you think this is an OK response to a silly proposal,\n  but in this case, I'm trying to show you that my proposal, which I sort\n  of expected you to dislike, is actually quite similar to your problem:\n  how to get people's expectations to fit the language they use, and vice\n  versa.  you can't dismiss this _problem_, and I certainly did not dismiss\n  it in your proposals, but you can still dismiss proposed solutions.\n  that's why I wanted you to see the difference between bundling a problem\n  with a solution and having it rejected and looking a problem square in\n  the eye and determine to solve it by submitting a whole bunch of ideas\n  for other people's rejection and perhaps that one winner.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "a_modest_proposal_(long)"
        },
        {
          "id": "3161053303848931@naggum.no",
          "subject": "Re: A modest proposal (long)",
          "author_id": "erik_naggum",
          "date": "2000-03-03",
          "display_date": "03/03/2000",
          "content": "\nSubject: Re: A modest proposal (long)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/03\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161053303848931@naggum.no>\n\n* \"Frank A. Adrian\" <fadrian@uswest.net>\n| In, other words, the inverse operation for defvar IS unintern.\n\n  unintern nukes the property list, the home package, and the functional\n  value of the symbol, as well as the identity of the symbol should there\n  be any hold-over pointers to it after re-interning.  defvar affects none\n  of these.  defvar also does not intern the symbol to begin with.  ergo,\n  unintern is in no way the inverse of defvar.  case dismissesd.\n\n  makunbound causes a subsequent defvar to initialize the value of the\n  variable, so clearly there is an inverse relationship right there.  since\n  there is no need or desire to nuke the _symbol_ (especially not with all\n  its other properties), we only need an inverse operation for the special\n  property of the symbol.  I have provided that as code for Allegro CL, as\n  a stepping stone to a supported language mechanism.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "a_modest_proposal_(long)"
        },
        {
          "id": "3161052909493352@naggum.no",
          "subject": "Re: A modest proposal (long)",
          "author_id": "erik_naggum",
          "date": "2000-03-03",
          "display_date": "03/03/2000",
          "content": "\nSubject: Re: A modest proposal (long)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/03\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161052909493352@naggum.no>\n\n* Russell Wallace <manorsof@iol.ie>\n| Can you give a reference to this, or summarize the argument in question?\n\n  Pierre R. Mai relieved me (thanks!) of searching for the articles where\n  Kent has made this point, but my understanding of this issue is that any\n  language that has the ability to do non-local transfers of control needs\n  a mechanism to ensure that invariants and pre- and post-conditions are\n  maintained even across them.  that is, _if_ you care about maintaining\n  invariants and pre- and post-conditions (which could collectively be\n  thought of the very sanity of your code), and that's where I extend this\n  argument to apply to programmers.  most modern languages now have several\n  sometimes _very_ powerful means of non-local transfers of control, such\n  as exception handling.  outside of Common Lisp, none of them make sanity\n  maintenance convenient, what with all the declarations and \"try\" blocks\n  and everything.  a programmer who doesn't care about the sanity of his\n  code and doesn't even pause to consider the consequences of modifying the\n  state of a global variable (and they do exist, regardless of what people\n  think or do to avoid them -- consider data on disk the ultimate in global\n  variables) should just not be programming anything that has side effects.\n  and the more we think about this, the more we want heavy-duty transaction\n  processing and committing blocks of changes at a time, with roll-back and\n  journaling and all that nifty stuff that the database people have figured\n  out and automatized for their programmers.  unwind-protect is a similar\n  concern for the sanity of code and data.  and binding special variables\n  without needing unwind-protect to set and restore the values of otherwise\n  mere global variables is on par with automatized transaction processing\n  in terms of programmer convenience.  now somebody wants to take that\n  convenience away from us with more verbose syntax and added hairiness to\n  the language.  consider what database programmers would think about a\n  proposal to have to be _explicit_ about every transaction processing step\n  _all_ the time.  that's how good programmers should react to any measure\n  to abridge the usefulness and convenience of special variables.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "a_modest_proposal_(long)"
        }
      ],
      "post_count": 10,
      "first_post_date": "2000-03-01",
      "last_post_date": "2000-03-03"
    },
    {
      "id": "dynamic_bindings_and_lightweight_processes",
      "title": "Dynamic bindings and lightweight processes",
      "posts": [
        {
          "id": "3161072346725257@naggum.no",
          "subject": "Re: Dynamic bindings and lightweight processes",
          "author_id": "erik_naggum",
          "date": "2000-03-03",
          "display_date": "03/03/2000",
          "content": "\nSubject: Re: Dynamic bindings and lightweight processes\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/03\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161072346725257@naggum.no>\n\n* \"Simon Katz\" <skatz@nomistech.com>\n| What's really going on here?\n\n  the special bindings of a process are re-bound during the context switch.\n\n  (however, if you don't _bind_ special variables in such a multiprocessing\n  environment, only set it, this mechanism is defeated.)\n\n| How do other Lisps that support lightweight processes compare?\n\n  they seem to do the same thing all over the place.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "dynamic_bindings_and_lightweight_processes"
        },
        {
          "id": "3161081138993119@naggum.no",
          "subject": "Re: Dynamic bindings and lightweight processes",
          "author_id": "erik_naggum",
          "date": "2000-03-03",
          "display_date": "03/03/2000",
          "content": "\nSubject: Re: Dynamic bindings and lightweight processes\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/03\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161081138993119@naggum.no>\n\n* Tim Bradshaw <tfb@cley.com>\n| I think the wrongness is to assume that SYMBOL-VALUE gets at the `slot in\n| the symbol', which is something I used to think.  In fact it gets at the\n| current dynamic binding -- there is no portable way to get at the slot in\n| the symbol -- and indeed there may *be* no distinct symbol slot, but just\n| a top-level binding.\n\n  if the current dynamic value of a special variable and symbol-value of\n  the symbol _differ_ (modify one, don't see the difference in the other),\n  you have a seriously non-conforming implementation, so _the_ portable way\n  to get at the slot in the symbol cannot be any different than the current\n  dynamic value.  please don't confuse this issue beyond necessity.\n\n  there are two ways to do this dynamic binding thing: shallow and deep\n  binding.  shallow binding stuffs the old value away, typically on the\n  same stack that unwind-protect uses, and stores the new value in the\n  symbol-value slot.  deep binding basically pushes symbols on an alist (or\n  something very similar) and traverses it to get the current value.  in a\n  multiprocessing setting, there are multiple stacks, and at least one of\n  them is used to store the process-local value of symbol-value slots of\n  process-bound special variables.\n\n  this is actuall fairly well documented in each of the Common Lisp systems\n  that support multiprocessing.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "dynamic_bindings_and_lightweight_processes"
        }
      ],
      "post_count": 2,
      "first_post_date": "2000-03-03",
      "last_post_date": "2000-03-03"
    },
    {
      "id": "best_cl_type_for_fixed_decimal_values",
      "title": "best CL type for fixed decimal values",
      "posts": [
        {
          "id": "3161105359590485@naggum.no",
          "subject": "Re: best CL type for fixed decimal values",
          "author_id": "erik_naggum",
          "date": "2000-03-03",
          "display_date": "03/03/2000",
          "content": "\nSubject: Re: best CL type for fixed decimal values\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/03\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161105359590485@naggum.no>\n\n* Robert Monfera <monfera@fisec.com>\n| OTOH, a lot of real-life, \"mainstream\" problems cannot be solved with\n| fixnums of some implementations or even worse, the ANSI lower limit of 16\n| bits.\n\n  the important part about fixnums is not how big they are, but how they\n  interact with other implementation limits in the language.  e.g., array\n  indices are all fixnums.  allowing bignums for array indices is a bad\n  idea.  it is therefore valuable to have a type which is already necessary\n  in the language explicitly available for similarly constrained operations.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "best_cl_type_for_fixed_decimal_values"
        },
        {
          "id": "3161081269457609@naggum.no",
          "subject": "Re: best CL type for fixed decimal values",
          "author_id": "erik_naggum",
          "date": "2000-03-03",
          "display_date": "03/03/2000",
          "content": "\nSubject: Re: best CL type for fixed decimal values\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/03\nNewsgroups: comp.lang.lisp\nMessage-ID: <3161081269457609@naggum.no>\n\n* Marc Battyani\n| What CL types are best suited for computing with fixed decimal values with\n| exactly n places after the decimal point?\n| \n| I can use\n|     floats with a special rounding after each operation\n\n* Johan Kullstam <kullstam@ne.mediaone.net>\n| floats are out since finite length decimal point numbers often have\n| non-finite binary expansions.  0.1 for example cannot be represented\n| exactly by floating point.\n\n  but if he knows he has N places after the decimal point, that translates\n  directly to a factor (expt 10 N), which means he could do well with the\n  extra precision and speed of a double-float value relative to bignums.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "best_cl_type_for_fixed_decimal_values"
        }
      ],
      "post_count": 2,
      "first_post_date": "2000-03-03",
      "last_post_date": "2000-03-03"
    },
    {
      "id": "setq_question.",
      "title": "setq Question.",
      "posts": [
        {
          "id": "3160842339136874@naggum.no",
          "subject": "Re: setq Question.",
          "author_id": "erik_naggum",
          "date": "2000-02-29",
          "display_date": "02/29/2000",
          "content": "\nSubject: Re: setq Question.\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/29\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160842339136874@naggum.no>\n\n* npak@kazbek.ispras.ru (Nick V. Pakoulin)\n| Will the binding created by setq become dynamic or lexical?\n\n  setq doesn't create bindings, it modifies bindings.  the binding modified\n  by a top-level setq is the symbol-value slot of the symbol.  if this\n  symbol was previously unbound (i.e., it had no value), you might be\n  confused about the resulting behavior into believing that something\n  happened other than merely setting the symbols-value slot of the symbol,\n  but nothing else actually happened.\n\n| I've looked about `setq' in the standard but there is nothing about it.\n| I tried CLISP and it looks like it makes variables in this case to be\n| dynamic.\n\n  no, you're confusing an unbound variable with the creation of a binding.\n\n  we've recently been through this, as well as several times in the past.\n  some will tell you that this is a major big deal with Common Lisp --\n  don't listen to them.  just note that the semantics of a top-level setq\n  is well-defined, but confusing to people who don't realize that setting a\n  free variable, whether the symbol is declared special or not, is\n  operationally identical to setting the symbol-value slot of the symbol,\n  and setting a lexical variable is not affecting the symbol-value slot of\n  any symbol.\n\n  the ultimate advice, however: it is not a good idea to use free variables\n  without declaring them special or knowing _exactly_ what's going on.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "setq_question."
        },
        {
          "id": "3160995245965471@naggum.no",
          "subject": "Re: setq Question.",
          "author_id": "erik_naggum",
          "date": "2000-03-02",
          "display_date": "03/02/2000",
          "content": "\nSubject: Re: setq Question.\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/03/02\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160995245965471@naggum.no>\n\n* npak@kazbek.ispras.ru (Nick V. Pakoulin)\n| May be I don't understand something fundamentally simple, but what about this\n| piece of code (CLISP):\n\n  yeah, what about it?\n\n  the reason I *hate* examples is that they communicate exactly _nothing_\n  in the vast majority of cases.  the set of possible questions you are\n  asking is virtually unbounded.\n\n  I assume you are confused about what the function boundp returns, but at\n  what point your understanding is solid is inherently uknowable with just\n  your example to go on, and any good answer would have to start off from\n  where you last had a reasonably solid understanding of the issues.  don't\n  assume that people have time to figure out what you're trying to ask them\n  about.\n\n  please try to rephrase your questions, and don't use a single line of\n  code as an example -- nothing good ever comes from stuffing things into a\n  Lisp system and looking confused at the answer, anyway.  either you know\n  what you're doing, or you set out to learn.  chances are then very good\n  you will have answered your own question in the process of asking it well.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "setq_question."
        }
      ],
      "post_count": 2,
      "first_post_date": "2000-02-29",
      "last_post_date": "2000-03-02"
    },
    {
      "id": "(loop_for_?_in_?_finally_?)",
      "title": "(loop for ? in ? finally ?)",
      "posts": [
        {
          "id": "3160491992791375@naggum.no",
          "subject": "Re: (loop for ? in ? finally ?)",
          "author_id": "erik_naggum",
          "date": "2000-02-25",
          "display_date": "02/25/2000",
          "content": "\nSubject: Re: (loop for ? in ? finally ?)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/25\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160491992791375@naggum.no>\n\n* \"Fernando D. Mato Mira\" <matomira@iname.com>\n| I've never seen redundancy as the primary reason ...\n\n  I was referring to an inherent characteristic of human languages, and as\n  such, redundancy is indeed a primary.  indeed, some redundancy is a\n  _good_ thing in human communication.  that is, what might be considered\n  \"redundant\" from a purist point of view is actually necessary to maintain\n  proper communication conduits between people who can't pay 100% attention\n  100% of the time and who most certainly can't cope with 100% of the\n  ramification of every statement 100% of the time.  so we yield to the\n  nature of the human mind instead of removing all forms of redundancy.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "(loop_for_?_in_?_finally_?)"
        },
        {
          "id": "3160481213819408@naggum.no",
          "subject": "Re: (loop for ? in ? finally ?)",
          "author_id": "erik_naggum",
          "date": "2000-02-25",
          "display_date": "02/25/2000",
          "content": "\nSubject: Re: (loop for ? in ? finally ?)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/25\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160481213819408@naggum.no>\n\n* \"Fernando D. Mato Mira\" <matomira@iname.com>\n| Then why not just erasing every sentence saying \"is undefined\" or \"is\n| unspecified\"?\n\n  primarily because we're human readers in dire need of redundancy.\n\n  secondarily because sometimes a requirement may seem to or actually imply\n  a too broad claim and may therefore need to be abridged or partially\n  retracted.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "(loop_for_?_in_?_finally_?)"
        },
        {
          "id": "3160826886234158@naggum.no",
          "subject": "Re: (loop for ? in ? finally ?)",
          "author_id": "erik_naggum",
          "date": "2000-02-29",
          "display_date": "02/29/2000",
          "content": "\nSubject: Re: (loop for ? in ? finally ?)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/29\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160826886234158@naggum.no>\n\n* Bary Margolin\n| But if he can't find a place in the spec where it says what he must do,\n| he can do whatever he wants.\n\n* Fernando D. Mato Mira\n| Besides the fact that such an approach shows the true value of an spec w/o\n| a formal definition, or at least verbosely written in natural language to\n| accomplish the same effect that would mean:\n\n  standards are legal documents.  they follow the same principle as every\n  other legal document: that which it does not say is not covered.  laws\n  are defined similarly: if it isn't forbidden, you can do it.  (but in the\n  case of government agencies: if it isn't prescribed, you can't do it.)\n\n| 1. Implementors are free not to play by the same rules as everybody else.\n\n  so what would you need to stop them from doing this in your ideal world?\n  (I assume permissions and grants from gilds or government agencies.)\n\n  in this world, users and customers make informed choices and the market\n  has the role of the control mechanism.  not to be snotty or anything, but\n  it tends to come as a surprise to Europeans that the market can work\n  without serious government intervention and licenses to produce goods.\n  which is why the new EU standard for condoms specifies one size for the\n  entire continent, ignoring well-known physiological differences between\n  regions, and why we have an EU standard for the \"curvature\" of bananas.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "(loop_for_?_in_?_finally_?)"
        }
      ],
      "post_count": 3,
      "first_post_date": "2000-02-25",
      "last_post_date": "2000-02-29"
    },
    {
      "id": "allegro_cl_5.0_win32",
      "title": "Allegro CL 5.0 Win32",
      "posts": [
        {
          "id": "3159728504708010@naggum.no",
          "subject": "Re: Allegro CL 5.0 Win32",
          "author_id": "erik_naggum",
          "date": "2000-02-16",
          "display_date": "02/16/2000",
          "content": "\nSubject: Re: Allegro CL 5.0 Win32\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/16\nNewsgroups: comp.lang.lisp,comp.lang.lisp.franz\nMessage-ID: <3159728504708010@naggum.no>\n\n* \"Zachary Turner\" <zturner@bindview.com>\n| Because I'm a measly home user and don't want to pay Franz price for one.\n\n  but you're willing to break laws and contracts and licenses, instead?\n\n| I think it's something like $800.\n\n  why don't you ask them, instead?  are you afraid to talk to honest people\n  when you aren't afraid to stand up in a crowd and say you have a criminal\n  mind?\n\n  you actually don't have to pay for the Lite Edition of Allegro CL 5.0.1\n  for Windows 95/98/NT at all.  you would easily have found that out if you\n  didn't first conclude that you had to cheat and steal.\n  \n#:Erik\n\n",
          "references": [],
          "thread_id": "allegro_cl_5.0_win32"
        },
        {
          "id": "3159819164039342@naggum.no",
          "subject": "Re: Allegro CL 5.0 Win32",
          "author_id": "erik_naggum",
          "date": "2000-02-17",
          "display_date": "02/17/2000",
          "content": "\nSubject: Re: Allegro CL 5.0 Win32\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/17\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159819164039342@naggum.no>\n\n* \"Larry Elmore\" <ljelmore@montana.campuscw.net>\n| I simply stated that I think that something where the contract in\n| question is merely implied rather than explicit, as in a shrinkwrap\n| license, being able to legally forbid you from transferring the product\n| to someone else under any conditions at all is in my view unreasonable\n| and over the top.\n\n  it's the willingness to break any licenses with which one does not agree\n  that defines the criminal mind.  moreover, such criminal attitudes is\n  what makes it necessary in the first place to tighten up the licenses.\n  in the absence of the criminal mind, licenses are much shorter and much\n  simpler.  if you conclude from this that Franz Inc in particular or the\n  software industry in general has had a lot of contact with criminal\n  minds, consider the attitude towards the \"best\" criminal mind around:\n  Bill Gates.  large fractions of the population consider him a hero, yet\n  he has zero respect for law, contract, or license, and breaks anything he\n  thinks he can get away with.  this has led concerned people everywhere to\n  become even more cautious about giving other criminal minds any leeway.\n\n  the real target for your anger is Microsoft's business practices.  don't\n  take it out on any single company that tries to live in a world where\n  Microsoft would steal everything they did if they had the skills to know\n  how good it is.  so if you retarget your complaints, maybe they'll have\n  merit.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "allegro_cl_5.0_win32"
        },
        {
          "id": "3160236800937421@naggum.no",
          "subject": "Re: Allegro CL 5.0 Win32",
          "author_id": "erik_naggum",
          "date": "2000-02-22",
          "display_date": "02/22/2000",
          "content": "\nSubject: Re: Allegro CL 5.0 Win32\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/22\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160236800937421@naggum.no>\n\n* \"Larry Elmore\" <ljelmore@montana.campuscw.net>\n| If Erik had ...\n| If Erik was ...\n\n  then pigs would fly and Larry Elmore would have figured out that making\n  yet more projections and conjectures based on his own experiences would\n  not communicate anything but his own ability to deal with traumatic input.\n\n  just coincidentally, if I were a police officer, my take on this is that\n  Larry would accuse me of police brutality if I looked at him, and would\n  sue the entire police department if I did my job well and had to give him\n  a citation for something he actually did.  there are a lot of people who\n  have personal issues with the concept \"authority\" and work very hard to\n  make sure they are never mistaken for one while fighting against all that\n  looks like authorities, even if it is _really_ stupid to do so.  I won't\n  conjecture on anyone's upbringing, even though it's very tempting, now.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "allegro_cl_5.0_win32"
        },
        {
          "id": "3160297317728478@naggum.no",
          "subject": "Re: Allegro CL 5.0 Win32",
          "author_id": "erik_naggum",
          "date": "2000-02-23",
          "display_date": "02/23/2000",
          "content": "\nSubject: Re: Allegro CL 5.0 Win32\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/23\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160297317728478@naggum.no>\n\n* \"Larry Elmore\" <ljelmore@montana.campuscw.net>\n| Tell me, Erik, if you had lived in the northern United States in the\n| 1850's, would you have obeyed the Fugitive Slave Act and turned in a\n| runaway Southern slave and those who helped him? ...\n;\n| I'm pleased.  It appears you're learning.  Thank you.\n\n  I'm always learning -- consider the alternative: repeating mistakes like\n  asking hypothetical-rhetorical questions and posting hypothetical insults.\n\n#:Erik, just sighing\n\n",
          "references": [],
          "thread_id": "allegro_cl_5.0_win32"
        },
        {
          "id": "3160337334524020@naggum.no",
          "subject": "Re: Allegro CL 5.0 Win32",
          "author_id": "erik_naggum",
          "date": "2000-02-23",
          "display_date": "02/23/2000",
          "content": "\nSubject: Re: Allegro CL 5.0 Win32\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/23\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160337334524020@naggum.no>\n\n* David Thornley\n| Third, if somebody is ignorant of Franz' policy, why would any\n| intelligent person assume criminal intent?\n\n  the fact that he said explicitly that he did not want to pay Franz Inc's\n  prices and the fact that he had already established that he was looking\n  for a _copy_ from someone other than Franz Inc.  plus, he's trying to\n  deny what he actually said and attempt to rewrite it.  you've been had.\n\n| Assuming, of course, that this is against Franz licenses, which nobody\n| has said is the case.\n\n  if you wish to be taken seriously, you need to stop denying replies to\n  your questions.  otherwise, it becomes necessary to believe that you have\n  an agenda whose personal value to you far exceeds the truth.\n\n| I will point out that accusing somebody of criminal intent in a\n| public forum can be grounds for a lawsuit in the US.\n\n  in other words, what you're doing now is grounds for a lawsuit in the U.S.\n  now quote the _accusations_ you see, or apologize for even hinting at it!\n\n| It is considered a serious thing, and not to be taken lightly, by many\n| people.  It might be well to acquire the habit of not making such\n| accusations lightly.\n\n  so why do you do it so lightly?  are _you_ above the law?  one has to\n  wonder with all the \"what me?  I'm not one of _them!_\"-style rhetorics\n  you serve up, where everything that applies to others could not in your\n  most lively imagination apply to yourself.  in case you wonder, such lack\n  of empathy and principle in judgment is one of the root causes of\n  interminable conflicts, and you're well on your wan to keep this going\n  for nearly four years, just like the other loser does.  stop now.  reel\n  yourself in and start _thinking_.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "allegro_cl_5.0_win32"
        },
        {
          "id": "3160483397132118@naggum.no",
          "subject": "Re: Allegro CL 5.0 Win32",
          "author_id": "erik_naggum",
          "date": "2000-02-25",
          "display_date": "02/25/2000",
          "content": "\nSubject: Re: Allegro CL 5.0 Win32\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/25\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160483397132118@naggum.no>\n\n* \"Janos Blazi\" <jblazi@netsurf.de>\n| I admit that my recent postings were malicious. But this is even good for\n| you as those who do not know what you have done to me, believe that I am\n| an idiot (I hope they are not right).\n\n  precisely, being malicious on purpose is actually seen as constructive to\n  your personal needs and goals.  I'm impressed.  yes, you _are_ an idiot,\n  and your insistence on proving it is your own personal problem, not mine.\n  you could just quit, you know.  it is better to keep quiet and be thought\n  a fool than to open one's mouth and remove all doubt.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "allegro_cl_5.0_win32"
        },
        {
          "id": "3160483279486734@naggum.no",
          "subject": "Re: Allegro CL 5.0 Win32",
          "author_id": "erik_naggum",
          "date": "2000-02-25",
          "display_date": "02/25/2000",
          "content": "\nSubject: Re: Allegro CL 5.0 Win32\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/25\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160483279486734@naggum.no>\n\n* Ole Myren Rohne <ole.rohne@cern.ch>\n| In the article I criticized <3160337334524020@naggum.no>, Erik Naggum had\n| to omit \"licensed\" in order to make Zachary *sound* dishonest - that was\n| my point.\n\n  geez, talk about attributing malice to people!  get a grip on yourself.\n\n  when a person with criminal intent asks a person who has a licensed copy\n  of a program for a copy of it, does this necessarily imply that the copy\n  he is asking for is licensed and legitimate or could it also imply that\n  the copy will be a pirated copy, and that the only reasons to ask for the\n  holder of a licensed copy are to obscure the intent and make sure he is\n  himself not screwed?\n\n  I'm inclined to believe that the best reason to explain why you think\n  other people \"have to\" omit words and meaning is that you're so goddamn\n  good at it yourself, but it reflects on yourself, not on your targets.\n  you could stop doing it, you know, and actually try to make a _point_,\n  instead of proving that it is legitimate for others to do what you do.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "allegro_cl_5.0_win32"
        },
        {
          "id": "3160459740154619@naggum.no",
          "subject": "Re: Allegro CL 5.0 Win32",
          "author_id": "erik_naggum",
          "date": "2000-02-25",
          "display_date": "02/25/2000",
          "content": "\nSubject: Re: Allegro CL 5.0 Win32\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/25\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160459740154619@naggum.no>\n\n* \"Janos Blazi\" <jblazi@netsurf.de>\n| But probably if somebody can prove beyond any doubt that he is mentally\n| insane then he is not responsible for his actions or only responseble for\n| them to some limited extend and will not be persecuted.\n\n  I'm somewhat disappointed that you have the mental wherewithal to know\n  that this would be the only defense for your incredibly malicous postings\n  against me for as long as you have been using this newsgroup.  however, I\n  keep wondering what you gain from it, if .anything  very few people have\n  such a fucked-up psyche that malice _alone_ is considered constructive to\n  their goals and personal needs, but you seem to have nothing else to\n  contribute.  however, since you know you can't be punished for your\n  actions, it would still be nice to know what would satisfy the personal\n  needs that drives your malice.  do you have the mental wherewithal to\n  explain that to us, too?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "allegro_cl_5.0_win32"
        },
        {
          "id": "3160483839314182@naggum.no",
          "subject": "Re: Allegro CL 5.0 Win32",
          "author_id": "erik_naggum",
          "date": "2000-02-25",
          "display_date": "02/25/2000",
          "content": "\nSubject: Re: Allegro CL 5.0 Win32\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/25\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160483839314182@naggum.no>\n\n* \"Janos Blazi\" <jblazi@netsurf.de>\n| But that was o.k. as I learnt later, it was your way of communicating. I\n| knew immediately that I was defenseless against you as I am still sticking\n| to my 19th century ideals of tolerance and freedom of thought and decency\n| above all.\n\n  ... which apparently includes being purely malicious as the sole purpose.\n  it doesn't to me, and I never am.  it does not cease to amaze me that\n  some people suddenly relinquish all concepts of ethics once they have\n  found an excuse -- but that's the evidence I need of their being evil.\n\n  if you haven't even figured out that I respond to something people _do_\n  and quit when they no longer do it, not to who they _are_ (and don't quit\n  after they don't bug me anymore, quite fundamentally unlike you, which I\n  don't respond to unless you openly attack me), you're even more of a\n  drooling idiot than I had feared you _could_ be -- I thought so low IQs\n  were flushed out as spontanous abortions.\n\n  next time you wish to pretend to be upholding \"decency\", please let it\n  include \"not lying through your teeth\".  you are the most _indecent_ punk\n  who has been on this newsgroup in all its history, far exceeding anything\n  I could ever imagine doing.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "allegro_cl_5.0_win32"
        },
        {
          "id": "3160458120843676@naggum.no",
          "subject": "Re: Allegro CL 5.0 Win32",
          "author_id": "erik_naggum",
          "date": "2000-02-25",
          "display_date": "02/25/2000",
          "content": "\nSubject: Re: Allegro CL 5.0 Win32\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/25\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160458120843676@naggum.no>\n\n* Ole Myren Rohne <ole.rohne@cern.ch>\n| In any case, calling Erik Naggum's rewrite \"paraphrase\" is an\n| understatement.  He is indeed twisting the thruth at the border of\n| malice.  I don't see why referring to _all_ of Zachary's posts were\n| necessary to establish this.\n\n  since you're clearly engaging in the same practices you criticize, what's\n  your problem?  did I merely fail to ask _you_ permission to do what you\n  consider OK when you do it yourself?\n\n  I sincerely wish people who want to criticize others wouldn't be so\n  interminably stupid as to do exactly the same thing themselves.  it\n  doesn't invalidate any criticism per se, but it makes me wonder whether\n  the real issue they have is that _I_ do whatever, not whatever it was I\n  did, in which case I will summarily dismiss them as raving lunatics with\n  a personal axe to grind.\n\n  just don't do what you don't want others to do.  how hard can the merit\n  of this principle be for people to grasp?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "allegro_cl_5.0_win32"
        },
        {
          "id": "3160457752126919@naggum.no",
          "subject": "Re: Allegro CL 5.0 Win32",
          "author_id": "erik_naggum",
          "date": "2000-02-25",
          "display_date": "02/25/2000",
          "content": "\nSubject: Re: Allegro CL 5.0 Win32\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/25\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160457752126919@naggum.no>\n\n* Ole Myren Rohne <ole.rohne@cern.ch>\n| At this point, why does Erik Naggum paraphrase the original message\n| instead of quoting from it:\n\n  you're quoting the wrong article, dude, and I wasn't responding to the\n  original article in the first place.  get it straight or shut up.  try\n  <4C7AF620DF436092.095BE5DCC793D4D1.593A48AFDF2C5EAB@lp.airnews.net>\n  instead, with my response in <3159728504708010@naggum.no>.\n\n  if you need evidence that quoting doesn't really help in understanding\n  what's going on in a debate, consider your own reactions to what you have\n  read.  you, too, make assumptions about what people mean that go far\n  beyond any actually quotable text.  so, too, with everybody else.  the\n  sooner you understand this, the less you will fall prey to assigning\n  malicous intent to people, which it _seems_ you don't want others (i.e.,\n  me) to do, but keep doing yourself, towards me.  I don't particularly\n  respect such hypocricy, if that has been unclear up until now.  oK?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "allegro_cl_5.0_win32"
        },
        {
          "id": "3160534112856214@naggum.no",
          "subject": "Re: Allegro CL 5.0 Win32",
          "author_id": "erik_naggum",
          "date": "2000-02-26",
          "display_date": "02/26/2000",
          "content": "\nSubject: Re: Allegro CL 5.0 Win32\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/26\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160534112856214@naggum.no>\n\n* \"Janos Blazi\" <jblazi@netsurf.de>\n| I am trying to imagine your day.\n\n  yes, that's the problem.  stop doing that, and concentrate on your own\n  life.  it seems to require a lot more attention from you than you are\n  currently giving it.  I keep saying that most people are more than smart\n  enough to run their own lives, but few people are smart enough to run the\n  lives of others, even though they are increasingly asked to in this here\n  information society, and on the Net, some people seem to want that more\n  than anything else, especially those who fail to run their own lives.\n\n  I'd have to conclude that you're not even smart enough to be _able_ to\n  run your own life, Janos, and that's why you're trying to imagine mine,\n  but the imagination of a drooling idiot is no match for reality, and\n  you're so ridiculous in your attempt to tell me what your life is like\n  that you're even surpassing Larry Elwood.\n\n  please remember that your imagination is a product of your experiences.\n  it is not always a good idea to broadcast the limits of your imagination.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "allegro_cl_5.0_win32"
        },
        {
          "id": "3160533716637942@naggum.no",
          "subject": "Re: Allegro CL 5.0 Win32",
          "author_id": "erik_naggum",
          "date": "2000-02-26",
          "display_date": "02/26/2000",
          "content": "\nSubject: Re: Allegro CL 5.0 Win32\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/26\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160533716637942@naggum.no>\n\n* Gareth McCaughan <Gareth.McCaughan@pobox.com>\n| I think they indicate that Erik interpreted \"copy\" in a way that I\n| wouldn't have dreamed of doing and that I bet is very different from what\n| Zachary actually meant.\n\n  I never interpreted it that way.  please don't assume that just because\n  someone who is not fluent in American English speculates about what\n  someone else whom he assumes is not fluent in American English because\n  he's not an American would have meant or misunderstood, said someone else\n  actually misunderstood it that way.  I actually find such arguments very\n  insulting.  if you make this kind of argument with, say, black Americans,\n  whom you assume don't understand a word because they're black, you're a\n  racist.  it makes no difference to me if you make it about foreigners or\n  other groups about which you know very little that applies to individuals.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "allegro_cl_5.0_win32"
        },
        {
          "id": "3160534181946389@naggum.no",
          "subject": "Re: Allegro CL 5.0 Win32",
          "author_id": "erik_naggum",
          "date": "2000-02-26",
          "display_date": "02/26/2000",
          "content": "\nSubject: Re: Allegro CL 5.0 Win32\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/26\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160534181946389@naggum.no>\n\n* David Thornley\n| I am aware of certain books which cost more, new, than I really want to\n| pay.  I intend to buy used copies.  Are you now going to accuse me of\n| criminal intent?\n\n  yes, but only because this is getting criminally stupid.\n\n#:Erik, who didn't read the rest of the noise\n\n",
          "references": [],
          "thread_id": "allegro_cl_5.0_win32"
        },
        {
          "id": "3160533150935433@naggum.no",
          "subject": "Re: Allegro CL 5.0 Win32",
          "author_id": "erik_naggum",
          "date": "2000-02-26",
          "display_date": "02/26/2000",
          "content": "\nSubject: Re: Allegro CL 5.0 Win32\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/26\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160533150935433@naggum.no>\n\n* \"Janos Blazi\" <jblazi@netsurf.de>\n| I think that the tone is getting harsher in this newsgroup due to EN's\n| fierce attacks and this is a very bad thing.\n\n  then do your own piece and cut your own tone.  you can't cut mine, but\n  you might be very surprised, especially considering your personality,\n  that some people don't go around with thoughts of revenge all the time\n  and that hatred and malice have no part of _their_ personality, even\n  though _you_ are filled to the brim with both.  if you don't annoy and\n  harrass people, they don't react to you, either.  instead you, and Xah\n  Lee, and this Larry dude recently, behave as if your thinking is you have\n  a _right_ to annoy me in particular and think that the more you annoy me,\n  the more right you get in doing whatever it was you were once critized\n  for, that if you can somehow _prove_ I'm \"bad\" to people, as opposed to\n  what I really am: really harsh on stupidity, you don't have to listen to\n  the arguments I present that you have made some very serious mistakes\n  that reflect badly on you.  that is not how things work, because such is\n  the actual ad hominem argument, and you're the stupid jerks making it.\n  you can _never_ invalidate the argument by going for the person, but you\n  can make the _person_ change his ways if the person makes particular\n  mistakes through sloppiness or carelessness which produces bad arguments,\n  which means the argument may get improved if the person gets the point of\n  the message \"pull yourself together\", but you guys are so confused about\n  this and refuse to think, instead defending your intellectual sloppiness\n  and going on a rampage with hostilities towards those who show you that\n  you don't use your brain, and thereby you only prove you don't have any.\n\n  stupidity is the result of not being required to think, or believing one\n  can get away with not thinking.  I don't tolerate stupidity at all, but I\n  actually believe that stupidity is worse, and reflects worse on people's\n  personality, than malice, but the two combined, as in Janos Blazi, is too\n  much.  note that stupidity has nothing to do with intelligence or lack\n  thereof, it has to do with insufficient expenditure of mental effort as\n  required by the task at hand.  intellectual laziness is the only sin.  I\n  punish such sinners, and like any sinner who knows he is one and has no\n  intention of changing his ways, Janos Blazi and his like-minded ilk need\n  to defend themselves rather than stop sinning, which means they will use\n  any evil means and unlimited malice to try to stop the criticism, apart\n  from using their brains and realize that they _could_ just start to think\n  and not post idiotic drivel that wastes everybody's time.  apparently, it\n  is just too much to demand of Janos Blazi that he do that, and he has all\n  the time in the world to attack me and vilify me and shower me with his\n  idiotic malice, instead.  what more proof do I need of who Janos Blazi is?\n\n  and now he complains about the tone.  he can fix his own.  it would help\n  a lot, and I certainly wouldn't dream of speaking badly of someone who\n  has stopped attacking me, but someone who keeps attacking me with a tone\n  so malicious as Janos Blazi's and who is so demented as to complain about\n  the tone of _others_, should have been taken care of by the mental health\n  services and just be locked up.  the only way you could possibly have any\n  credibility when you criticize something is to stay above it, and the\n  more you stay above it, the more you show it possible to do without it.\n  if you have to engage in the same thing you want others to stop in the\n  belief that this will stop them, you're just an idiot who doesn't like\n  _who_ uses a particular means.  so why prove you're an idiot when that is\n  what the criticism was all about?  don't you morons realize that when I\n  think you're idiots, you do nothing but prove my case with your behavior?\n  what do you _think_ you could possibly accomplish with that?\n\n  Janos Blazi, it is obvious by now that you are beyond reach, and you seem\n  to be retarded or at least psychotic if not, which means there's no point\n  in trying to reach you, either, but if you wish for a better tone in this\n  newsgroup, you could do your part and stop attacking _me_ all the time.\n  get an argument about _something_ for once -- don't obsess about people.\n  it's your obsession with people that causes your problems with the fact\n  that others are concerned about actions, principles, and ideas, because\n  you can't see beyond people, but people are uninteresting except to their\n  close ones.  and you're not close to me, if that needs stressing, so it's\n  what you do and what you argue through your actions is true and good that\n  is of my concern.  what you seem to argue is true and good is stupidity,\n  the right to be intellectually lazy, the right to make false accusations\n  and claims, the right to distort arguments and be ridiculously stupid in\n  not understanding them, etc.  you're the champion of any idiot around who\n  doesn't want to be told it's not OK to be an idiot.  we're going to have\n  to disagree on that, to put it mildly, but you're not going to convince\n  me it's OK to be an idiot the way you go about it.\n\n  sigh, I don't seem to learn, either, talking sense to Janos Blazi.\n  \n#:Erik\n\n",
          "references": [],
          "thread_id": "allegro_cl_5.0_win32"
        },
        {
          "id": "3160677433568405@naggum.no",
          "subject": "Re: Allegro CL 5.0 Win32",
          "author_id": "erik_naggum",
          "date": "2000-02-27",
          "display_date": "02/27/2000",
          "content": "\nSubject: Re: Allegro CL 5.0 Win32\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/27\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160677433568405@naggum.no>\n\n* \"Janos Blazi\" <jblazi@netsurf.de>\n| But he does not behave and this must be told him.\n\n  so what would it take for _you_ to realize that _you_ do not behave and\n  need to be told?  since you can't imagine being wrong in _your_ idiotic\n  insults and malicious behavior towards me, what makes you think you could\n  _possibly_ have any effect on me?  just _how_ stupid can a net.idiot get?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "allegro_cl_5.0_win32"
        },
        {
          "id": "3160677171534026@naggum.no",
          "subject": "Re: Allegro CL 5.0 Win32",
          "author_id": "erik_naggum",
          "date": "2000-02-27",
          "display_date": "02/27/2000",
          "content": "\nSubject: Re: Allegro CL 5.0 Win32\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/27\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160677171534026@naggum.no>\n\n* Stig Hemmer <stig@epoksy.pvv.ntnu.no>\n| I assume that it is the absence of body language, tone of voice\n| etc. that causes him to \"see idiots\" on the Net.\n\n  I must assume that you lack the ability to read tone in written text and\n  assume that all others suffer from the same problem, and that this causes\n  you to get ideas about how other people behave and think.  which is\n  pretty darn sad for you if you realize the long-term consequences.\n\n  instead of being intelligent about this and try to figure out if you're\n  right or at least onto something, you don your halo and present your\n  platitudes as relevant information.  the problem with you do-gooders who\n  think like this is you have _no_ clue.  it's like those lamb-and-lion\n  notions of paradise: people who have so little understanding of how\n  people work and what reality is like that they substitute some _really_\n  silly notion of \"wouldn't it be nice if\" for reality and go on to believe\n  in it and wish for it and hope for it.  it's actually sickening to watch.\n\n  reality doesn't fit the mental imaging power of fools and do-gooders.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "allegro_cl_5.0_win32"
        },
        {
          "id": "3160678127233294@naggum.no",
          "subject": "Re: Allegro CL 5.0 Win32",
          "author_id": "erik_naggum",
          "date": "2000-02-27",
          "display_date": "02/27/2000",
          "content": "\nSubject: Re: Allegro CL 5.0 Win32\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/27\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160678127233294@naggum.no>\n\n* David Thornley\n| What was unfortunate about it was that some people don't speak American,\n| misunderstood, and attacked.  What was even more unfortunate about it is\n| that some people kept insisting, in their extreme arrogance, that they\n| knew what was meant by an unfamiliar turn of phrase, and kept attacking.\n\n  what's even more unfortunate is that some people think they know what\n  went on and make no bones about expanding on their personal take on it,\n  even though the core problem they attribute to others is the _mistake_ of\n  thinking they know what went on and not backing down in the presence of\n  counter-evidence.  the extreme arrogance of such fools to pretend they\n  have The Answer is indeed the cause of these conflicts.  if the arrogant\n  fools had been willing to listen and understand, the number of idoitic\n  assumptions would perhaps have been managably small.  instead we have\n  people who are so incredibly thick-headed as to post their imagination of\n  what my days are like, and now David Thornley exceeds this idiotic drivel\n  by some other drivel about somebody misunderstanding \"copy\".  geez.\n\n  when people of so little introspective ability make grand projections\n  about the behavior of others, the only result is that we learn how they\n  think, and learn _nothing_ about anything else.  it's _really_ pathetic.\n\n| Erik assumed the worst, and (as of the last I've seen his postings)\n| continues to do so.\n\n  and just what would it take to provide you with counter-evidence, David?\n  your willingness to make and post your assumptions from _zero_ evidence\n  goes way beyond what I _questioned_ Zachary about.  I don't think you\n  even have the right to complain as long as your assumption-generator is\n  going at full speed.\n\n  what actually _amuses_ me in these discussions is just how idiotic the\n  people who complain about my behavior are.  it is clearly impossible for\n  these clowns to behave reasonably and intelligently themselves, and so\n  they make all these completely bizarre assumptions and projections and\n  tell me about their personal life (which I have _zero_ interest in!) and\n  how they imagine something they couldn't possibly be correct about.  is\n  there any wonder I keep up the flaming of these disgusting _retards_?\n  every time one of these blathering losers proves that he deserves it, I'm\n  proven right: one more true idiot marked out.\n\n  what's unfortunate is that the morons think their way of thinking is the\n  only possible way to think, but that's typically what _defines_ a moron.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "allegro_cl_5.0_win32"
        },
        {
          "id": "3160739578905356@naggum.no",
          "subject": "Re: Allegro CL 5.0 Win32",
          "author_id": "erik_naggum",
          "date": "2000-02-28",
          "display_date": "02/28/2000",
          "content": "\nSubject: Re: Allegro CL 5.0 Win32\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/28\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160739578905356@naggum.no>\n\n* \"Janos Blazi\" <jblazi@netsurf.de>\n| That *did* hurt my feelings.\n\n  so having your feelings hurt is actually sufficient for your psychology\n  to break and for you to become psychotic in your revengeful hatred where\n  doling out meaningless, irrational malice is OK to you?  for a person who\n  espouses _tolerance_ and has so little of it where it matters, there is\n  really no excuse for anything you have done.  be good and die instantly.\n\n| A question: what does \"net.idiot\" mean?  Is it a compliment stating that\n| I may be an idiot on the internet but otherwise I may be a kind and\n| gentle person?\n\n  yes.  to you, _any_ insult is a compliment relative to what you deserve.\n  are you happy now?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "allegro_cl_5.0_win32"
        },
        {
          "id": "3160753977447348@naggum.no",
          "subject": "Re: Allegro CL 5.0 Win32",
          "author_id": "erik_naggum",
          "date": "2000-02-28",
          "display_date": "02/28/2000",
          "content": "\nSubject: Re: Allegro CL 5.0 Win32\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/28\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160753977447348@naggum.no>\n\n* \"Janos Blazi\" <jblazi@netsurf.de>\n\n  didn't you just say you were going to stop blathering on and on and on\n  about this interminable, insufferable stream of inanity of yours?  *sigh*\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "allegro_cl_5.0_win32"
        },
        {
          "id": "3160715304400380@naggum.no",
          "subject": "Re: Allegro CL 5.0 Win32",
          "author_id": "erik_naggum",
          "date": "2000-02-28",
          "display_date": "02/28/2000",
          "content": "\nSubject: Re: Allegro CL 5.0 Win32\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/28\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160715304400380@naggum.no>\n\n* Marcus G. Daniels\n| Anyway, #:Erik, now that you mention it, I notice *your* posts are oddly\n| similar, especially of late.\n\n  I apologize for the predictability, but there's so little variation in\n  the basic theme to which I respond.  as you may have noticed, the core\n  argument is that I'm not allowed to do X to anyone, but every other\n  person is allowed to do X to me a 100 times over.  it gets old quick.\n\n| the Lisp community depends on you for leadership in these uncertain times.\n\n  why, thank you.  I'm delighted that you, too, join the fan club.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "allegro_cl_5.0_win32"
        }
      ],
      "post_count": 21,
      "first_post_date": "2000-02-16",
      "last_post_date": "2000-02-28"
    },
    {
      "id": "lisp_(and_other_language)_teaching_again",
      "title": "Lisp (and other language) teaching again",
      "posts": [
        {
          "id": "3160524415391428@naggum.no",
          "subject": "Re: Lisp (and other language) teaching again",
          "author_id": "erik_naggum",
          "date": "2000-02-26",
          "display_date": "02/26/2000",
          "content": "\nSubject: Re: Lisp (and other language) teaching again\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/26\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160524415391428@naggum.no>\n\n* not.for.email@not.for.spam\n| Allegro costs thousands of dollars.  People don't pay thousands of\n| dollars to \"graduate\" into something whose value seems dubious to them.\n\n  *sigh*  that is precisely why free versions of Allegro CL are given away\n  to those who want to try things out on their own.  you knew this, so why\n  even make this wholly irrelevant argument?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "lisp_(and_other_language)_teaching_again"
        },
        {
          "id": "3160694568944671@naggum.no",
          "subject": "Re: Lisp (and other language) teaching again",
          "author_id": "erik_naggum",
          "date": "2000-02-28",
          "display_date": "02/28/2000",
          "content": "\nSubject: Re: Lisp (and other language) teaching again\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/28\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160694568944671@naggum.no>\n\n* not.for.email@not.for.spam\n| First he has to get past his own scepticism about Lisp, that it can't\n| deliver reasonable programs and is therefore not worth learning.\n\n  such skepticism has to come from somewhere.  in this case, it's you.\n\n| For that reason, if the value of Lisp seems dubious to a particular\n| programmer, he's not likely to \"graduate\" into it by using Allegro.\n| That was my point.\n\n  I hear you, but you _could_ put my attitude this way: first I have to get\n  past my skepticism about the value of addressing you or helping you learn\n  Lisp, that you can't learn to write reasonably complex programs even if\n  you got the best programming environment on the planet, and is therefore\n  not worth teaching or helping.  since you ask the Lisp community to help\n  you overcome such skepticism towards Lisp, what do you propose to do to\n  overcome my skepticism towards you and people who think like you?  I\n  think you _ought_ to have a very good answer fully formed and ready.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "lisp_(and_other_language)_teaching_again"
        }
      ],
      "post_count": 2,
      "first_post_date": "2000-02-26",
      "last_post_date": "2000-02-28"
    },
    {
      "id": "freeware_common_lisp_compiler?",
      "title": "Freeware Common lisp compiler?",
      "posts": [
        {
          "id": "3160705543379547@naggum.no",
          "subject": "Re: Freeware Common lisp compiler?",
          "author_id": "erik_naggum",
          "date": "2000-02-28",
          "display_date": "02/28/2000",
          "content": "\nSubject: Re: Freeware Common lisp compiler?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/28\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160705543379547@naggum.no>\n\n* Marek Mikulec <mm98au@badger.ac.brocku.ca>\n| I'm looking for a freeware common lisp compiler (preferably Windows\n| based). Is there such a thing anyware? I just need it to do a couple of\n| assignments for uni, nothing spectacular.\n\n  start at www.lisp.org and look around.\n\n  I'd recommend getting Franz Inc's free version of Allegro CL for\n  Windows.  start at www.franz.com and look for \"free stuff\".\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "freeware_common_lisp_compiler?"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-02-28",
      "last_post_date": "2000-02-28"
    },
    {
      "id": "question_on_sort",
      "title": "question on sort",
      "posts": [
        {
          "id": "3160705423828335@naggum.no",
          "subject": "Re: question on sort",
          "author_id": "erik_naggum",
          "date": "2000-02-28",
          "display_date": "02/28/2000",
          "content": "\nSubject: Re: question on sort\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/28\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160705423828335@naggum.no>\n\n* Philip Nikolayev <nikolay@is02.fas.harvard.edu>\n| Is there a way to sort (with sort) a list of pairs of numbers by the\n| value of the first element of each pair?\n\n  yes.  (sort <sequence> <predicate> :key #'first) will use first to\n  extract the value from each element of the sequence before comparing.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "question_on_sort"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-02-28",
      "last_post_date": "2000-02-28"
    },
    {
      "id": "another_weird_question",
      "title": "another weird question",
      "posts": [
        {
          "id": "3160714423567167@naggum.no",
          "subject": "Re: another weird question",
          "author_id": "erik_naggum",
          "date": "2000-02-28",
          "display_date": "02/28/2000",
          "content": "\nSubject: Re: another weird question\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/28\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160714423567167@naggum.no>\n\n* Philip Nikolayev <nikolay@is02.fas.harvard.edu>\n| If I wanted to replace all the whole reals, such as 3.0, in a list with\n| their integer equivalents, while leaving all the other reals intact, is\n| there an easy way to do this?\n\n  consider a function f that accepts a number and returns the corresponding\n  integer if the number satisfies a predicate whole-real-p, or the number\n  unchanged if not.  apply this function to every element of the list with\n  a suitable mapping function.  you don't want this operation to destroy\n  the original list of values.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "another_weird_question"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-02-28",
      "last_post_date": "2000-02-28"
    },
    {
      "id": "common_lisp_online_resource?",
      "title": "common lisp online resource?",
      "posts": [
        {
          "id": "3160680228243461@naggum.no",
          "subject": "Re: common lisp online resource?",
          "author_id": "erik_naggum",
          "date": "2000-02-27",
          "display_date": "02/27/2000",
          "content": "\nSubject: Re: common lisp online resource?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/27\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160680228243461@naggum.no>\n\n* Julian M Underwood <jmu200@is5.nyu.edu>\n| Instead of buying a book on Common Lisp, can someone kindly reccomend a\n| good site to learn Lisp?  Thanks a lot,\n\n  www.lisp.org  ==  www.alu.org\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "common_lisp_online_resource?"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-02-27",
      "last_post_date": "2000-02-27"
    },
    {
      "id": "more_scope...",
      "title": "More Scope...",
      "posts": [
        {
          "id": "3160252167384001@naggum.no",
          "subject": "Re: More Scope...",
          "author_id": "erik_naggum",
          "date": "2000-02-22",
          "display_date": "02/22/2000",
          "content": "\nSubject: Re: More Scope...\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/22\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160252167384001@naggum.no>\n\n* Robert Munyer <munyer@mcs.com>\n| P.S.  A couple of years ago I had an exasperating flame war with Erik\n| over a question very similar to this one.  I eventually won the war, by\n| finding an excerpt from the HyperSpec that demonstrated the exact\n| opposite of Erik's main technical argument.\n\n  August 1996.  I think comp.lang.lisp readers deserve the opportunity to\n  read the discussion for themselves, not the least to understand why\n  Robert's self-serving summary is _still_ his position, and why it is\n  still important that he be shot down, because he's _still_ wrong, nearly\n  four years later.\n\n  the following \"power search\" line lists them from www.deja.com:\n\n~g comp.lang.lisp ~dc {1996/08/01 1996/09/30} ~s {EVAL implementations}\n\n  the original question was why (let ((x 10)) (eval 'x)) produces different\n  results before and after a special declaration of x.  this stumps newbies\n  at times, but it can be explained easily and well unless you get it wrong.\n\n  so the problem with that debate was that Robert insisted on bringing up a\n  *huge* number of *tiny* arguments.  Robert _did_ field a war over quibbly\n  little details, while everybody else were either trying to unconfuse him,\n  calm him down, or putting in their earplugs.  naturally, winning this war\n  meant nobody made the effort to respond to more of the same old rants.\n\n  my _main_ argument was that Common Lisp doesn't have a concept of \"global\n  variables\", but lexical and dynamic _bindings_, and lexical and global\n  symbol _references_ (explained in various bits and pieces -- the whole\n  discussion helped clarify the issues for me).  Robert's main point was\n  that you could have a lexical and a dynamic variable with the same name.\n  he's right (and I _never_ disagreed with him on it, because it is wholly\n  irrelevant): the latter is called the symbol-value of a symbol that has\n  _not_ been declared special, because a reference to a variable that is\n  not lexical is identical to symbol-value of the symbol naming it.  as\n  most confused people who are right, Robert was right for wrong reasons:\n  he didn't understand the distinction between binding and references to\n  variables.  apparently, he learned nothing from the whole exercise.\n\n  here's an excerpt I think highlights exactly why Robert is _still_ upset:\n\n> (part of) Robert's answer was wrong, relied on implementation specifics\n> at best, and is no better off after his attempted rescue missions.  end\n> of story.\n\nWait a minute.  STOP DOING THAT!  It is rude and offensive.  You keep\nsaying that part of my answer was wrong somehow, without specifying how.\nEvery time I challenge you to be specific you just post another article\nsaying (or implying) that I made some vague, unspecified error.  That is\nnot a reasonable way to debate.  In Usenet you are not supposed to simply\nstate that someone is wrong; you are supposed to explain WHY he or she is\nwrong so that everyone can benefit.\n\n  I clearly fell short of his expectations.  of course that's _my_ fault.\n\n  incidentally, Robert's parting words to us were as follows:\n\nThe standard example code above makes it absolutely clear that SETQ does\nnot, and must not, proclaim a symbol to be special.\n\n  no wonder it didn't really feel good to part on this winning note: it's\n  not a winning note.  it's an admission of not remembering from early\n  warnings in the same discussion that examples are not even considered\n  part of the standard, for the very simple reason that the requirements\n  have to be _uniquely_ authoritative.\n\n  so the \"excerpt from the HyperSpec that demonstrates the exact opposite\n  of Erik's main technical point\" is simply a lie -- but it's the kind you\n  win wars with, because people normally let you think you won when you say\n  something sufficiently stupid and gloat and brag about it to boot.\n  \n#:Erik\n\n",
          "references": [],
          "thread_id": "more_scope..."
        },
        {
          "id": "3160300841191334@naggum.no",
          "subject": "Re: More Scope...",
          "author_id": "erik_naggum",
          "date": "2000-02-23",
          "display_date": "02/23/2000",
          "content": "\nSubject: Re: More Scope...\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/23\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160300841191334@naggum.no>\n\n* Andrew Cooke <andrew@andrewcooke.free-online.co.uk>\n| I have a proposal to put to the group.\n\n  me, too: if you have a problem with personal attacks, then stop doing it\n  _first_.  continue _only_ if you actually _condone_ personal attacks.\n  \n#:Erik\n\n",
          "references": [],
          "thread_id": "more_scope..."
        },
        {
          "id": "3160482077049507@naggum.no",
          "subject": "Re: More Scope...",
          "author_id": "erik_naggum",
          "date": "2000-02-25",
          "display_date": "02/25/2000",
          "content": "\nSubject: Re: More Scope...\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/25\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160482077049507@naggum.no>\n\n* Keke Abe\n| Could you explain the distinction?  I've read the 1996 thread but could\n| not figure that out.\n\n  a binding of a lexical variable is an entirely new variable, one that may\n  be captured independently of any other variable, and which is not visible\n  anywhere else.  a binding of a special variable is a dynamic association\n  between variable and value which is seen everywhere else the same\n  variable is referenced.  the reference to a lexical variable is under the\n  supreme control of the compiler, which may allocate it to a register or\n  to a stack frame, and which will typically discard the symbol association.\n  the reference to a special variable is like a call to symbol-value on\n  that symbol.\n\n  this means that the statement \"there may be a lexical and dynamic\n  variable with the same name\" is terribly confused.  yes, it is possible\n  to \"forget\" to declare a symbol special, which means any binding will be\n  lexical, but so, then, will any normal reference.  in order to access the\n  symbol, you can no longer just name it, you need to call symbol-value or\n  set when you want to read or change its value.  but at this time, we're\n  clearly doing something very different than what we did with variables --\n  we're actually tinkering with the underlying implementation of special\n  variables.\n\n  a fully true statement would be that the symbol-value slot of a symbol is\n  accessible and may be accessed also when the symbol has not been declared\n  special.  however, using a variable means _not_ having to do anything\n  special like that at every access, so it's clear that we access a\n  symbol's internal information in code like this:\n\n(1) common-lisp-user\n;; In Lisp Listener #2\n(2) common-lisp-user\n(defun foobar (x)\n  (values x (symbol-value 'x)))\n=> foobar\n(3) common-lisp-user\n(setq x 666)\n=> 666\n(4) common-lisp-user\n(foobar 4711)\n=> 4711\n=> 666\n(5) common-lisp-user\n(defvar x 69)\n=> x\n(6) common-lisp-user\n(foobar 4711)\n=> 4711\n=> 4711\n(7) common-lisp-user\n\n  hope this helps.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "more_scope..."
        },
        {
          "id": "3160523659993482@naggum.no",
          "subject": "Re: More Scope...",
          "author_id": "erik_naggum",
          "date": "2000-02-26",
          "display_date": "02/26/2000",
          "content": "\nSubject: Re: More Scope...\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/26\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160523659993482@naggum.no>\n\n* gat@jpl.nasa.gov (Erann Gat)\n| It takes a pretty smart implementation of Common Lisp to actually\n| produce this result as presented.  In most systems you'll have to\n| recompile FOOBAR after DEFVARing X to see the result:\n\n  foo was never compiled.  there are downsides to compile-only systems.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "more_scope..."
        }
      ],
      "post_count": 4,
      "first_post_date": "2000-02-22",
      "last_post_date": "2000-02-26"
    },
    {
      "id": "good_data-structure_for_characters_in_editor_buffe",
      "title": "Good data-structure for characters in editor buffer?",
      "posts": [
        {
          "id": "3160459010404972@naggum.no",
          "subject": "Re: Good data-structure for characters in editor buffer?",
          "author_id": "erik_naggum",
          "date": "2000-02-25",
          "display_date": "02/25/2000",
          "content": "\nSubject: Re: Good data-structure for characters in editor buffer?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/25\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160459010404972@naggum.no>\n\n* cbarry@2xtreme.net (Christopher R. Barry)\n| What's an ideal data-structure for storing the characters of an editor\n| buffer?\n\n  a string or, more probably, a region of foreign-allocated memory.  you\n  will have to engage in your own memory management stuff with such editor\n  buffers no matter what you do, as the operations you want to perform on\n  one are highly specialized and you would waste a lot of memory and CPU\n  time on more general data structures.\n\n  however, that said, you would want to think hard about how to store the\n  results of the operations on the buffer efficiently.  it is not the text\n  that is the problem.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "good_data-structure_for_characters_in_editor_buffe"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-02-25",
      "last_post_date": "2000-02-25"
    },
    {
      "id": "[constants]_from_a_reader_macro",
      "title": "[constants] from a reader macro",
      "posts": [
        {
          "id": "3160367893782736@naggum.no",
          "subject": "Re: [constants] from a reader macro",
          "author_id": "erik_naggum",
          "date": "2000-02-24",
          "display_date": "02/24/2000",
          "content": "\nSubject: Re: [constants] from a reader macro\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/24\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160367893782736@naggum.no>\n\n* Tunc Simsek <simsek@tudor.EECS.Berkeley.EDU>\n| Suppose I define a reader macro:\n| \n| (defun foo (stream char)\n|     `(make-array 10000 :element-type 'double-float))\n| \n| (set-macro-character #\\@ #'foo)\n\n  I assume this is either a serious confusion or an instructive example\n  whose purpose I don't understand, but to which you can apply answers.\n\n| In this silly example each time lisp sees a @ it will return a big array.\n\n  answering the confusion part: it is important to keep in mind exactly\n  which part of \"lisp\" sees it under which conditions, and what it returns,\n  not to forget to what it returns it.  the Lisp reader will see the @ and\n  return the _list_ it received from foo.  if supplied at the top-level,\n  this list is now a form the _evaluation_ of which returns an array, but\n  the Lisp reader is by now long gone, having completed its job.  if read\n  as part of some source code, it will only be folded into the source and\n  later processed with that source code.\n\n| The question is whether I can make it return the same array each time it\n| sees it:\n| \n| (dotimes (i 10000)\n|   @)\n\n  as indicated above, this is exactly identical to\n\n(dotims (i 10000)\n  (make-array 10000 :element-type 'double-float))\n\n  and what happens from then on is not related to the Lisp reader at all,\n  but to the normal behavior of the evaluator and compiler.\n\n| should only create one array, i.e. in my opinion, a CONSTANT.\n\n  however, if you remove the backquote in your misguided reader macro, foo\n  will return a new array that will be treated as a constant by whatever\n  called the Lisp reader each time, but again, the Lisp reader is long gone\n  when this decision is made.\n\n  it seems by your use of the backquote that your core confusion is to\n  believe that \"macro\" in \"reader macro\" is the same kind of \"macro\" as in\n  \"macro function\".  it isn't.  reader macros is a very powerful mechanism\n  to change the syntax of the language, move certain operations into\n  read-time (essentially pre-compile-time), and to abbreviate common forms.\n  reader macros actually make up all the syntax of the language, such that\n  the reader macro for #\\( builds lists.\n\n  I think the reader macro system is absolutely fantastic, but it takes a\n  lot of skill to use it productively, and a lot of serious concern to see\n  when not to use it, just as it takes a lot of intellectual effort to keep\n  syntax simple and clean in general, much more than people generally think\n  -- as witness C++ and Perl, but I'll avoid the digression.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[constants]_from_a_reader_macro"
        },
        {
          "id": "3160397620998575@naggum.no",
          "subject": "Re: [constants] from a reader macro",
          "author_id": "erik_naggum",
          "date": "2000-02-24",
          "display_date": "02/24/2000",
          "content": "\nSubject: Re: [constants] from a reader macro\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/24\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160397620998575@naggum.no>\n\n* Tunc Simsek <simsek@tudor.EECS.Berkeley.EDU>\n| Here is an excerpt from my Allegro CL 3.0.1 (win) on-line doc:\n\n  geez, that's _ancient_.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[constants]_from_a_reader_macro"
        },
        {
          "id": "3160379902079136@naggum.no",
          "subject": "Re: [constants] from a reader macro",
          "author_id": "erik_naggum",
          "date": "2000-02-24",
          "display_date": "02/24/2000",
          "content": "\nSubject: Re: [constants] from a reader macro\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/24\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160379902079136@naggum.no>\n\n* Michael Kappert <kap@iitb.fhg.de>\n| If you want the reader to return the same array every time it sees a @,\n| shouldn't FOO be defined something like\n| \n| (let ((my-array ()))\n|   (defun foo (stream char)\n|     (or my-array (setf my-array (make-array ... )))))\n\n  presuming that it will be called at least once, you could initialize the\n  binding with the value, or use what I prefer these days, load-time-value.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[constants]_from_a_reader_macro"
        },
        {
          "id": "3160383123856271@naggum.no",
          "subject": "Re: [constants] from a reader macro",
          "author_id": "erik_naggum",
          "date": "2000-02-24",
          "display_date": "02/24/2000",
          "content": "\nSubject: Re: [constants] from a reader macro\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/24\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160383123856271@naggum.no>\n\n* Erik Naggum\n| it seems by your use of the backquote that your core confusion is to\n| believe that \"macro\" in \"reader macro\" is the same kind of \"macro\" as in\n| \"macro function\".  it isn't.\n\n* Tunc Simsek\n| I must confess that I don't understand this remark, they behave in the\n| same way, their ranges are lisp code.\n\n  no.  that's the issue.  the \"range\" of macros is Lisp code which will be\n  processed by the caller, usually the compiler on code it processes.  the\n  \"range\" of reader macros is Lisp objects the Lisp reader was asked to\n  pick up from some textual input source, such as by the compiler when it\n  compiles files.  viz, a macro to build a matrix would return the code to\n  be evaluated or compiled instead of the macro form, while a reader macro\n  to build a matrix would return the matrix as a constant object.\n\n  moreover, they do not behave in the same way.  a macro function is called\n  with Lisp code it can transform at will, while a reader macro is expected\n  to build Lisp objects from parsing input.  the \"domain\" of the former is\n  Lisp objects and code, while the \"domain\" of the latter is characters and\n  streams.  this must be understood in depth before you can make use of\n  reader macros productively.  most Lisp programmers don't know how the\n  Lisp reader and printer work to begin with, or how to add new objects to\n  the read-write-consistency paradigm.  indeed, not understanding how Lisp\n  has solved this very difficult problem is why most designers of protocols\n  and syntaxes get them so incredibly wrong.\n\n| My intent is to get a simple way of expressing constant matrices which I\n| use a lot and don't like to type in (make-matrix ... all the time.\n\n  this is good.  however, you should regard your reader macro as a\n  short-cut for #.(make-matrix ...), not for (make-matrix ...) if you want\n  to build the matrix in the reader macro (and nothing else makes sense).\n\n| I actually know of one problem with using #\\[ as a macro character:\n| allegro uses it as a super paranthesi.\n\n  which \"allegro\" is that?  Allegro CL does not violate the standard by\n  interpreting [ and ] as anything but ordinary symbol name constituents.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[constants]_from_a_reader_macro"
        }
      ],
      "post_count": 4,
      "first_post_date": "2000-02-24",
      "last_post_date": "2000-02-24"
    },
    {
      "id": "the_inverse_of_optional_arguments.",
      "title": "The inverse of optional arguments.",
      "posts": [
        {
          "id": "3160236064663586@naggum.no",
          "subject": "Re: The inverse of optional arguments.",
          "author_id": "erik_naggum",
          "date": "2000-02-22",
          "display_date": "02/22/2000",
          "content": "\nSubject: Re: The inverse of optional arguments.\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/22\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160236064663586@naggum.no>\n\n* Jon Haugsand <Jon.Haugsand@nr.no>\n| Maybe I am blind, but I cannot find out a way to do the following.  I\n| have a function that has a function parameter where the latter is called\n| with some arguments.  However I would like to call it with more arguments\n| if the function would accept them.  An example:\n| \n| (defun mydo (proc)\n|   (apply proc (list :extra 5)))\n| \n| (mydo #'(lambda (&key (extra 0)) (+ 4 extra)))\n| (mydo #'(lambda () 4))\n| \n| The first call to MYDO works, however I would like something like the\n| second too, where APPLY simply should ignore extra parameters when not\n| required.\n\n  first, you need to make sure that the function you're calling has &key in\n  its argument list.  then, you call it with :allow-other-keys t in its\n  argument list.  this will silence the default action for unknown keyword\n  arguments.\n\n  the function function-lambda-expression should return the lambda\n  expression for the function in question, but it is allowed to return nil\n  for any function, so you're a little out of luck without special support\n  for this thing.  in Allegro CL, however, the function excl:arglist\n  returns the argument list of the function, as it was known when the\n  function was compiled (which may not be the verbatim argument list due to\n  macro \"preprocessing\").  this is usually sufficient to see whether you\n  have a keyword-argument-accepting function.\n\n  however, the general problem you're tring to solve is more interesting:\n  figuring out how to express a \"protocol\" for functions that accept\n  functions as arguments and call them with something other than a trivial\n  transformation of its own argument list.  I believe this is partly what\n  makes up the concept of \"interface\" in Java and it would be kind of nice\n  if it were solved neatly for Common Lisp, too.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "the_inverse_of_optional_arguments."
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-02-22",
      "last_post_date": "2000-02-22"
    },
    {
      "id": "character_comparison",
      "title": "character Comparison",
      "posts": [
        {
          "id": "3160029562363276@naggum.no",
          "subject": "Re: character Comparison",
          "author_id": "erik_naggum",
          "date": "2000-02-20",
          "display_date": "02/20/2000",
          "content": "\nSubject: Re: character Comparison\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/20\nNewsgroups: comp.lang.lisp\nMessage-ID: <3160029562363276@naggum.no>\n\n* \"Chris H\" <newsgroupNOJUNK@NOJUNKhome.com>\n| how do I check if  character 'a' is in word 'banada'\n| \n| is any thing like substring() function ?\n\n  yes.  FIND, POSITION, SEARCH, CHAR, SUBSEQ, etc.\n\n  note that most operations on characters and strings in Common Lisp are\n  simply special cases of operations on elements and sequences.  many\n  C-based programmers are frustrated because they think that Common Lisp\n  has few string-handling functions.  Common Lisp has few string-only\n  functions, so remember to look for sequence and array functions, too.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "character_comparison"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-02-20",
      "last_post_date": "2000-02-20"
    },
    {
      "id": "are_there_any_lisp_development_systems_that_are_vc",
      "title": "Are there any LISP development systems that are VC, or other GUI IDE  like?",
      "posts": [
        {
          "id": "3159124272806425@naggum.no",
          "subject": "Re: Are there any LISP development systems that are VC, or other GUI IDE  like?",
          "author_id": "erik_naggum",
          "date": "2000-02-09",
          "display_date": "02/09/2000",
          "content": "\nSubject: Re: Are there any LISP development systems that are VC, or other GUI IDE  like?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/09\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159124272806425@naggum.no>\n\n* Robert Posey <muddy@raytheon.com>\n| While the interpreted, or incremental compiled nature of LISP is growing on \n| me I still find all the systems I have used to be a pain.\n\n  Common Lisp systems provide more powerful hammers.  if you are used to\n  C/C++, you are numbed to the pain of hitting your thumb with a puny\n  hammer (at least conceptually), but now that you hit your thumb that much\n  harder, it hurts again, that much more.  the solution is to quit hitting\n  your thumb, not to pad your thumb or stifle the hammer's power.\n\n  at some point in time, you learned the C/C++ way, without reference to\n  much anything, right?  at this point in time, you should endeavor to\n  learn the Common Lisp way, without reference to much anything.  study how\n  people experience in the Common Lisp way do it.  do not attempt to use\n  your C++ expertise in Common Lisp.  what works for C/C++ has evolved over\n  time to be the least painful and/or most efficient.  what governs\n  qualities such as \"least painful\" and \"most efficient\", however, are\n  vastly different for Common Lisp.  it's that simple, really.  _after_ you\n  have established rapport with your environment, you should compare them\n  in terms of what you can accomplish in each with how much work, not in\n  terms of how well a later experience emulates some environment that just\n  happened to be a prior experience.\n\n  most people, when they have learned something, tend to think in extremely\n  concrete terms about what they are doing.  they think they click on menu\n  bars, drag an object, double-click on icons, etc.  they _don't_ think in\n  terms of the operation that said physical activity causes to take place,\n  even though that is why they perform these physical actions.  so when\n  they want to perform that operation in a new environment, they completely\n  _ignore_ the fact that they once had to associate the operation with\n  these actions, and now request the actions, as if the action and the\n  operation were the same.  well, they very obviously aren't, and if they\n  think that way, they failed to learn what they were doing in a productive\n  and efficient way -- they instead learned to parrot actions.  the sooner\n  human beings get out of this modus operandi and become _thinking_ beings,\n  the better, and if it hurts a little to get out of parrot mode, so be it.\n  most everything worth doing is associated with effort and some pain.\n\n  so, to answer your real question: no, we don't debug functions the same\n  way in Common Lisp as in static languages.\n\n  inserting code to get the equivalent of (conditional) breakpoints isn't a\n  problem, btw, since you can edit and recompile a function in seconds, and\n  if you have to do it with a mouse click, teach Emacs to insert \"(break)\"\n  and recompile the function upon a mouse click.  I fail to see the value\n  of such a user interface function, but, hey, it's been years since I set\n  a breakpoint in any C code, too, precisely because I'm much more used to\n  the Common Lisp way, and even the best C debuggers _suck_, so I spend a\n  little more time thinking about the code I write and experimenting in --\n  you guessed it, Common Lisp -- before I commit the design to C, almost as\n  if by hand-compiling code in a real language into machine instructions\n  burned into an EEPROM or something equivalently hardware-like and way\n  cumbersome to deal with.  odd as it may seem, writing bug-free C code is\n  really a breeze once you have come to appreciate and think in Common Lisp.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "are_there_any_lisp_development_systems_that_are_vc"
        },
        {
          "id": "3159558414867232@naggum.no",
          "subject": "Re: Are there any LISP development systems that are VC, or other GUI  IDE  like?",
          "author_id": "erik_naggum",
          "date": "2000-02-14",
          "display_date": "02/14/2000",
          "content": "\nSubject: Re: Are there any LISP development systems that are VC, or other GUI  IDE  like?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/14\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159558414867232@naggum.no>\n\n* Robert Posey <muddy@raytheon.com>\n| You are now my new Newsgroups Closed Mind of Year.\n\n  I just knew you were the authority on Closed Minds.\n\n| I guess you must feel really threaten that more people can use computers\n| without the high initial price.\n\n  at least your guesses are improving in quality -- now you make them about\n  issues on which you at least have relevant personal experience.\n\n| Technology is not a social club, it should always be made as easy to use\n| as possible.\n\n  sure.  but not easier, as the genius once said.\n\n| If you really think anyone would doesn't want to waste time learning\n| painfully complex tools for every new task is a loser, you need to\n| reconsider the task.\n\n  only someone who confuses a particular implementation of an idea with the\n  idea itself could say something so utterly devoid of intelligence.\n\n| If this crazed rant is a result of some deep emotion attachment to EMACS,\n| GET A LIFE.\n\n  and just what made you think in terms of deep emotional attachment, Robert?\n\n| Any learning curve time that involves the tool is wasted time, and should\n| be minimized.\n\n  _very_ good advice.  and it has evidently worked wonders for you.\n\n| After this incredible childish response, you would dare to tell me what\n| to do.\n\n  children are supposed to be told what to do, but the stubbornness that\n  causes children to do the opposite of what they are told, no matter how\n  foolish or stupid, is the very definition of a childish reaction to being\n  told what to do.  so why don't you do something to convince me that _I_\n  would benefit from talking to like you were an adult?  so far, you have\n  respond _solely_ on what _you_ see as childish, and nothing else.  if you\n  don't want to be treated as a stupid child, well, do something else.  how\n  hard can it be?  (and if it _is_ too hard for you, perhaps that's a clue?)\n\n| The very idea I can't comment about the faults that must exist in any\n| software is a joke.\n\n  sure is, but you're the first to make that joke.  I must assume it made\n  you laugh to yourself because it's tragically unfunny to anyone else.\n\n| Your response is paranoid in the extreme, LISP and EMACS aren't a\n| religion so chill out.\n\n  so just what _are_ you so mortally afraid of, Robert, that this is what\n  you consider most helpful to your cause?\n\n| All editors, languages and people have flaws and to pretend different\n| makes you look foolish.\n\n  definitiely, but what about you, who actually _think_ people pretend\n  something so foolish?\n  \n| This is another example of one of the problems in EMACS, LINUX and I\n| guess LISP community, the desire to demonize the other side.\n\n  and here I was under the impression that we learned this from you, but I\n  guess you know the Emacs, Linux and Common Lisp communities better than\n  anyone who is actually a member of any of them, and you certainly know\n  them far better than you know the community you came from, such that you\n  don't for a minute hesitate to extrapolate your expectations from your\n  home community to _all_ others without checking or waiting to see that\n  what you believe holds for the new and different communities you meet.\n\n| Either you like doing it MY WAY or you are stupid and part of the Grand\n| Microsoft plot to take over the world.\n\n  see?  I _knew_ you had \"demonize\" written all over you.  nobody thinks\n  like this, Robert, except morons who actually believe that accusations\n  such as that one reflects on anyone but themselves.  but yes, I do think\n  you're terribly stupid.  it has nothing to do with doing anything my way\n  or not, but rather the insistence that _you_ want things your way or not\n  at all.  objects reflected in your PC screen are closer than they appear.\n\n| I would also challenge you to write a few programs with VC or Visual\n| Basic and see if you don't find some advantages.\n\n  trust me, I'm so smart I can find _some_ advantages with absolutely\n  anything, including killing people, using Perl, starting wars, installing\n  Windows on a would-be computer, or even help funding George W. Bush's\n  presidential campaign (he's _almost_ as clueless and negative about stuff\n  he doesn't grasp as you are), but that also means I'm so smart I can find\n  fundamental disadvantages that I don't want to pay for by the few, and by\n  now comparatively _irrelevant_ advantages I find.  you see, unlike you,\n  smart people weigh costs and benefits, they don't just go for whatever\n  has _some_ advantages.\n\n| I will admit if you spend a lot of time customizing EMACS it maybe better\n| than VS or any other product.\n\n  now, why would you \"admit\" that?  how would you know?  what else that you\n  know nothing about do you \"admit\"?  don't flatter yourself by pretending\n  to flatter me with superficial agreement to statements the ramifications\n  of the contents of which you cannot realize at your level of competence.\n  and I'm your Newsgroups Closed Mind of the Year, remember?  as such, I'm\n  certainly not open to your admissions of ignorance disguised as groveling.\n\n| I will admit you pissed me off, for which I beg forgiveness for lack of\n| emotional control.\n\n  nah, I don't forgive people.  I wait until they stop doing what they beg\n  forgiveness for, and shoot them down again if they repeat it, especially\n  after they have begged forgiveness for it, because that means they have\n  not learned, and not learning when you have the opportunity is the only\n  unforgivable sin.  and, _actually_, begging forgiveness is the hallmark\n  of someone who is going to repeat the same sin over and over again.\n\n| However, either you are having a bad day, or you have some deep hurts you\n| need to deal with.\n\n  sure.  I'll happily yield to your profound expertise in this area, too.\n\n  next time, try to speak _explicitly_ for yourself on psychological\n  matters, Robert, since that is what you are _implicitly_ doing, anyway.\n\n  good luck, \"Muddy\".\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "are_there_any_lisp_development_systems_that_are_vc"
        },
        {
          "id": "3159496965766379@naggum.no",
          "subject": "Re: Are there any LISP development systems that are VC, or other GUI IDE  like?",
          "author_id": "erik_naggum",
          "date": "2000-02-14",
          "display_date": "02/14/2000",
          "content": "\nSubject: Re: Are there any LISP development systems that are VC, or other GUI IDE  like?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/14\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159496965766379@naggum.no>\n\n* Robert Posey\n| Actual EMACS is the worst, since it not delivered with a lot of the\n| packages you are going to need.\n\n  nonono, _you_ are the worst, since you have been delivered with a lot of\n  opinions instead of appreciation for the facts you would have needed to\n  form them.\n\n| EMACS would be improved 200% if someone would just modify the interface\n| packages so that they would install using a point and click installer\n| program.\n\n  most users would be improved 200% if someone just replaced their concepts\n  of what \"simplicity\" is all about with something approaching intelligence\n  in design.\n\n  also, I think children should come with little infrared receptors that\n  obeyed the \"mute\" button on my remote control, so now I'm going to\n  complain vociferously to everybody who make children that they should\n  improve their children 200% by changing them so the remote control I use\n  to shut up TV commercials will work on annoying children, too.\n\n  try M-x customize RET the next time you feel like pointing and clicking.\n  if that doesn't help, do something entirely new and different, and RTFM.\n\n  incidentally, there _are_ good IDEs for Common Lisp, too, but I surmise\n  that your penchant for complaining out of ignorance will apply yet again,\n  so I won't harm the vendors of such IDEs by naming them so you can post\n  yet more negative drivel about stuff you don't understand.  figure it out\n  for yourself -- you need to get used to figuring things out for yourself.\n\n  and while I'm speaking my mind, the reason intelligent, competent people\n  hate Microsoft is that that company alone has produced millions of people\n  just like you who have zero clue and an overpowering desire to prove it\n  to the entire world.  \"make a tool a fool can use, and only a fool will\n  use it\" has never been truer than of the anti-educational, anti-skill-\n  building cruftware that Microsoft has made billions peddling to unwitting\n  losers who now think they have a clue about using computers productively\n  (which is very different from fooling around with them all day).  they\n  don't, and thanks to Microsoft, they never will, unless they let go of\n  the myth that Microsoft has made using computers easy to use.  in fact,\n  the only thing that Microsoft has made _real_ easy for their users is\n  handing over lots and lots of money to Microsoft in exchange for more\n  hype to believe in, more vaporware to wait for, and most of all, more\n  vehicles for viruses to get scared into bying more software to avoid.\n\n  don't follow up to this article until you have found and tried at least\n  three different IDE-based Common Lisp environments and have decided to\n  fail to complain about them.  thank you for your cooperation.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "are_there_any_lisp_development_systems_that_are_vc"
        },
        {
          "id": "3159635894939621@naggum.no",
          "subject": "Re: Are there any LISP development systems that are VC, or other GUI  IDE  like?",
          "author_id": "erik_naggum",
          "date": "2000-02-15",
          "display_date": "02/15/2000",
          "content": "\nSubject: Re: Are there any LISP development systems that are VC, or other GUI  IDE  like?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/15\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159635894939621@naggum.no>\n\n* Robert Posey <muddy@raytheon.com>\n| Sure you hear claims that it is capable of great things, but often very hard\n| to believe when you can't even exit the program.\n\n  you know, it is getting harder and harder to believe anything you say\n  when you make such silly complaints.  if you took the time to read the\n  stuff that is thrown in your face when you start up a default Emacs, if\n  not the first time you start it, at least the second time, when you have\n  sworn and gritted your teeth over not being able to exit the program the\n  first time, most of your silly complaints would simply vanish.\n\n  if I were you, I would be extremely hesitant to expose so much of my way\n  of dealing with things in general as you do on this Emacs topic, or,\n  worse, so much of your ability to learn from your experience.  it seems\n  that if you already know how to do something in some context, any other\n  way is so broken that you don't even want to figure out what it would be.\n  now, who would want a _programmer_ who thinks like that?\n\n| Another problem is the documentation is written from an Unix prospective,\n| this means you are constantly translating to windows terms.\n\n  this could be why I don't understand your basic problems -- they are\n  expressed in Windows terms that lose so much precision in their\n  translation into tech-speak that they come out as baseless whining.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "are_there_any_lisp_development_systems_that_are_vc"
        },
        {
          "id": "3159728087248949@naggum.no",
          "subject": "Re: Are there any LISP development systems that are VC, or other GUI    IDE  like?",
          "author_id": "erik_naggum",
          "date": "2000-02-16",
          "display_date": "02/16/2000",
          "content": "\nSubject: Re: Are there any LISP development systems that are VC, or other GUI    IDE  like?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/16\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159728087248949@naggum.no>\n\n* Robert Posey <muddy@raytheon.com>\n| I agree with you about what should be done, unfortunately I work for very\n| large company where I am totally unable to affect hiring policies.\n\n  what part do you agree with?  I'm talking about _educating_ people that\n  have already been hired, because whatever was hired was raw material, and\n  education is what shapes them into something the company can use.\n\n| Being passionate is not excuse for lack of ability to make rational\n| arguments,\n\n  you extrapolate from unwillingness to treat a bozo like you as an adult\n  with _ability_ to make rational arguments.  this is a _fantastically_\n  unintelligent extrapolation.\n\n| when people let their emotions control them,\n\n  emotions always control people.  that's their fundamental function.  the\n  question is _which_ emotions.  some day you will understand this.\n\n| I never mean to say that they shouldn't feel strongly, but that shouldn't\n| blind them to both sides of an issue.\n\n  what does it _take_ to make you understand that you're the one dreaming\n  up this utter crap about other people?  I have told you that I can see\n  _some_ advantages with _everything_.  _why_ is this something you have to\n  keep denying all the time?  nobody here is blinded, except you, perhaps.\n\n| To become so emotionally attached to a EDITOR is a problem.\n\n  you don't understand how emotions work in technically apt people, so now\n  it's a \"problem\".  grrrrreat!  tell you wat, bozo, _nobody_ is _attached_\n  to an editor, emotionally or otherwise.  you don't have to be _attached_\n  to feel something, you see.  well, perhaps you do, but you're not the\n  prototype of all people on earth, now, are you?\n\n| If any complain about EMACS drives them to attack the  the commentator,\n| they have lost touch with reality.  EMACS is a fine program, BUT many\n| people hate EMACS with equal passion.  When you allow your emotion to so\n| blind to other points of view, your engineering ability has been\n| severely compromised.\n\n  *sigh*.  if only you could listen to yourself instead of expecting that\n  others will listen to you.  _nobody_ suffers from what you would dearly\n  hope they suffer from so _you_ could ignore them.  and I mean _nobody_.\n  you don't understand jack shit about software and how it affects people\n  with a working intelligence _and_ working emotions.  as soon as you\n  realize this, you could be worth talking to.  so far, there is no sign\n  that your brain is able to accept anything you don't already agree to.\n\n| If you think the widely \n| recognized relatively steep initial learning curve of EMACS doesn't exist you\n| have lost all touch with reality.\n\n  are you in really touch with Reality, \"Muddy\"?  whoever _actually_ thinks\n  these things you dream up?  I keep telling you: nobody.  your enemies are\n  figments of your not very well developed imagination.\n\n| However, to assert that none of my arguments are valid...\n\n  nobody has asserted any such thing.\n\n| However, the paranoid of the EMACS Zealots has made them see things that\n| aren't there.\n\n  _really_?  how about the many demonstrations that you are arguing against\n  some really stupid stuff that _nobody_ has actually ever said?\n\n| Read my posting again, and see if I ever said anything to justify the\n| reactions people made.\n\n  just _how_ stupid are you, \"Muddy\"?  do you really think nobody did that\n  _before_ they reacted to your incredibly retarded and unfounded opinions?\n\n| >   by the way, wishful thinking like \"there's something wrong with those who\n| >   hate me\" is a very useful psychological defense mechanism for those who\n| >   are mentally unprepared to accept that other people aren't hateful to\n| >   begin with and don't react without reason or observable cause.  it is\n| >   fairly interesting to watch people respond to criticism as if criticism\n| >   of _them_ has to come from psychopaths, while they are eminently able to\n| >   criticize just about anything, usually without justifiable reasons.\n| \n| If any of you hate me for my comments you need serious help.\n\n  I'm _amazed_ by your reading comprehension, \"Muddy\".  I said \"[you] are\n  mentally unprepared to accept that other people aren't hateful to begin\n  with\", and now your response proves just that.\n\n  you're an idiot, Robert Posey.  shut your trap and leave us alone.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "are_there_any_lisp_development_systems_that_are_vc"
        },
        {
          "id": "3159732982259519@naggum.no",
          "subject": "Re: Are there any LISP development systems that are VC, or other GUI    IDE  like?",
          "author_id": "erik_naggum",
          "date": "2000-02-16",
          "display_date": "02/16/2000",
          "content": "\nSubject: Re: Are there any LISP development systems that are VC, or other GUI    IDE  like?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/16\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159732982259519@naggum.no>\n\n* Robert Posey <muddy@raytheon.com>\n| However, at my company you can be sure that they will be gone soon.\n\n  so this really boils down to your still working at a place that is deeply\n  dissatisfying to you, but it serves your personal needs better to blame\n  Emacs (and/or Common Lisp) than to get out of your miserable situation.\n\n  over the years, we have had a lot of people like you in comp.lang.lisp\n  and the Emacs newsgroups.  I guess this is so because people think it's\n  OK to blame these tools, but not OK to blame some other tools (such as\n  Microsoft's cruftware), for the simple reason that being miserable in the\n  majority makes people feel a lot _safer_ than being in a small minority\n  (whether one would be miserable there or not).  I do my very best to make\n  people feel unsafe and a lot more miserable in the majority, so it shall\n  appear, if not be, safer and better to be in the minority, instead.\n\n  your apologia for remaining at a miserable place are unconvincing at best.\n\n  go fix your _real_ problem, OK?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "are_there_any_lisp_development_systems_that_are_vc"
        },
        {
          "id": "3159810718604997@naggum.no",
          "subject": "Re: Are there any LISP development systems that are VC, or other GUI    IDE  like?",
          "author_id": "erik_naggum",
          "date": "2000-02-17",
          "display_date": "02/17/2000",
          "content": "\nSubject: Re: Are there any LISP development systems that are VC, or other GUI    IDE  like?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/17\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159810718604997@naggum.no>\n\n* Kenneth P. Turvey\n| Erik regularly treats people this way.  I wonder how many people have\n| really stopped using this group because of his rants...  \n\n  well, since you appear to wonder, the answer is simple: my influence on\n  such is much less than the rate of readers who succumb to accidents.\n\n  however, it is a well-known fact that idiots on the Net drive out people\n  who have something to contribute, in very large numbers.  I'm but a very\n  mild counter-force to that overpowering drive in society to dumb down\n  everything by telling people they have \"rights\" to post their drooling\n  idiocy everywhere, and in particular that only those who criticize the\n  idiots should have no right to do so.\n\n  I do wonder, however, why it is better to be preoccupied with _people_\n  than to be preoccupied with principles and ideas and actions, and why it\n  is OK to post inane drivel about people in articles with zero technical\n  merit or even contents, but not OK to flame morons _in_ technical areas.\n  I wish sometimes that those who have such a dramatic need to discuss _me_\n  would at least be \"kind\" enough to form a fan club or something equally\n  disgusting instead of pretending they are caring about anything more\n  intelligent than the personal nonsense we see in the National Enquirer.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "are_there_any_lisp_development_systems_that_are_vc"
        }
      ],
      "post_count": 7,
      "first_post_date": "2000-02-09",
      "last_post_date": "2000-02-17"
    },
    {
      "id": "floor",
      "title": "floor",
      "posts": [
        {
          "id": "3159729676010387@naggum.no",
          "subject": "Re: floor",
          "author_id": "erik_naggum",
          "date": "2000-02-16",
          "display_date": "02/16/2000",
          "content": "\nSubject: Re: floor\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/16\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159729676010387@naggum.no>\n\n* \"Slapstiq\" <slapstiq@rochester.rr.com>\n| I need to use the floor function but it returns two numbers.\n\n  if you are talking about Common Lisp, the two numbers are returned as\n  multiple values, which means that the primary value is the only value you\n  will see if you don't do something special to capture the others.\n\n  if you are talking about Emacs Lisp, the two numbers are returned as a\n  list of two values if you use the Common Lisp-like FLOOR* function\n  because Emacs Lisp can only return one value from any function.\n\n| Is there any for me to break a list in two halves?\n\n  consider VALUES-LIST.  <grin>\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "floor"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-02-16",
      "last_post_date": "2000-02-16"
    },
    {
      "id": "why_no_standard_foreign_language_interface?",
      "title": "Why no standard foreign language interface?",
      "posts": [
        {
          "id": "3159120499145849@naggum.no",
          "subject": "Re: Why no standard foreign language interface?",
          "author_id": "erik_naggum",
          "date": "2000-02-09",
          "display_date": "02/09/2000",
          "content": "\nSubject: Re: Why no standard foreign language interface?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/09\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159120499145849@naggum.no>\n\n* Robert Posey <muddy@raytheon.com>\n| Why doesn't LISP have a standard foreign language interface?\n\n  because the standards committees failed to reach consensus on the many\n  differing proposals and techniques before them.  and that's a good thing,\n  considering that since the standard was approved, none of the then\n  current foreign function interfaces have survived, C has become the de\n  facto least common denominator, meaning that C's calling conventions and\n  types are now regarded as fundamental (they aren't and never have been),\n  and any standard would have had to be abandoned, anyway.\n\n  but why this clamoring for the _standard_ to solve everything for you?\n  do you know any other language where the language standard has it all?\n  (even Java and C++ fail this test on a huge number of counts.)\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "why_no_standard_foreign_language_interface?"
        },
        {
          "id": "3159133748798780@naggum.no",
          "subject": "Re: Why no standard foreign language interface?",
          "author_id": "erik_naggum",
          "date": "2000-02-10",
          "display_date": "02/10/2000",
          "content": "\nSubject: Re: Why no standard foreign language interface?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/10\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159133748798780@naggum.no>\n\n* Robert Posey <muddy@raytheon.com>\n| Because if the standard has a standard interface, I could move the LISP\n| code to a new machine without change.\n\n  no, you couldn't.  think again.  whether you can move your code without\n  change depends vastly more on the code to which you interface than the\n  code that describes the interface.\n\n| In addition, commonly needed low level language routines could be reused\n| as well.\n\n  pardon me, but this is wishful thinking bordering on nonsense.  have you\n  ever tried to port _any_ code between disparate machines and operating\n  systems?  have you seen how much work it takes to make C code export a\n  portable interface?\n\n\n  what you need is a tool that can take C (or whatever) source code and\n  automatically produce the foreign function interface glue code that your\n  Common Lisp implementation needs.  why even _think_ about such a silly\n  thing as writing all the foreign function interface definitions by hand?\n\n  this cry for a standard foreign function interface stuff is just plain\n  stupid.  it detracts from the real answer in a really big way, because\n  people can be sooo content to sit on their fat asses and whimper about\n  the standard being mean and cheap and not giving them what they sorely\n  \"need\", while the real solution is waiting very patiently for somebody to\n  just stop staring at the stupid non-solutions and whining and whimpering,\n  and just freaking _do_ it.\n\n  believe me, once you can figure out the braindamaged syntax of all these\n  stupid infix languages with a plethora of static types and other junk\n  enough to do the necessary steps of (1) writing wrapper code in that same\n  language or in C that is more friendly to a Common Lisp interface, and\n  (2) knowing enough to write foreign function interface code in Common\n  Lisp, producing output that fits one of umpteen different foreign\n  function interface definition \"languages\" for various Common Lisp\n  implementations is _really_ trivial.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "why_no_standard_foreign_language_interface?"
        },
        {
          "id": "3159296652595081@naggum.no",
          "subject": "Re: Why no standard foreign language interface?",
          "author_id": "erik_naggum",
          "date": "2000-02-11",
          "display_date": "02/11/2000",
          "content": "\nSubject: Re: Why no standard foreign language interface?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/11\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159296652595081@naggum.no>\n\n* \"Fernando D. Mato Mira\" <matomira@iname.com>\n| Automatic FFI generation from C++ header files is far from trivial.\n\n  it may help to read what I write if you want to pose counter-arguments to\n  it instead of counter-arguments to something I didn't say.\n\n  C++ sucks.  to interface to C++, you need wrapper code in C++ that makes\n  it possible to interface Common Lisp to the wrapper code.  this code may\n  well be strictly C-compatible, as in `extern \"C\"'.\n\n| For C, you can easily write a FFIGEN `backend' adapted to your CL\n| implementation.  That's true.\n\n  so what prohibits you from being smart and utilizing this fact when\n  dealing with the utter braindamage of C++?  my answer: nothing.  it's\n  better to waste time in wrapper code than on stupid programmer tricks.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "why_no_standard_foreign_language_interface?"
        },
        {
          "id": "3159472938302521@naggum.no",
          "subject": "Re: Why no standard foreign language interface?",
          "author_id": "erik_naggum",
          "date": "2000-02-13",
          "display_date": "02/13/2000",
          "content": "\nSubject: Re: Why no standard foreign language interface?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/13\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159472938302521@naggum.no>\n\n* \"Fernando D. Mato Mira\" <matomira@iname.com>\n| Erik said:\n| \"believe me, once you can figure out the braindamaged syntax of all these\n|   stupid infix languages with a plethora of static types and other junk\n|   enough to do the necessary steps of (1) writing wrapper code in that same\n|   language or in C that is more friendly to a Common Lisp interface, and\n|   (2) knowing enough to write foreign function interface code in Common\n|   Lisp, producing output that fits one of umpteen different foreign\n|   function interface definition \"languages\" for various Common Lisp\n|   implementations is _really_ trivial.\"\n\n  but Fernando read:\n\n| \"Once you figure out how to do (1) and (2) it's trivial\"\n\n  no wonder we don't communicate!\n\n| If you want to trivially write a C++ parser in CL that would be even better!\n\n  try a remedial reading comprehension class instead of this idiocy, will you?\n\n| Well, C++ sucks, but the CL add-on product could know enough about the\n| calling conventions of the particular C++ compiler, and about C++ syntax\n| to do a lot of stuff directly, for example by leveraging your dead Lucid\n| code [But don't throw loads of money at this!\n\n  that's why I stated, and quite explicitly at that, that you need to write\n  WRAPPER CODE IN THAT SAME LANGUAGE OR IN C THAT IS MORE FRIENDLY TO A\n  COMMON LISP INTERFACE.  will you _please_ get it?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "why_no_standard_foreign_language_interface?"
        },
        {
          "id": "3159561340687049@naggum.no",
          "subject": "Re: Why no standard foreign language interface?",
          "author_id": "erik_naggum",
          "date": "2000-02-14",
          "display_date": "02/14/2000",
          "content": "\nSubject: Re: Why no standard foreign language interface?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/14\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159561340687049@naggum.no>\n\n* William Deakin <willd@pindar.com>\n| Ouch.  For two reasons really.  First the inherent evil in c++ library\n| naming.  It needs 'putting to the sword.'\n\n  I'm operating under the assumption that the name mangling thing is known\n  to the compiler, and that `extern \"C\"' means the functions can refer to\n  internal functions with mangled names, but export un-mangled names, that\n  mere mortals can predict.  the wrapper functions around \"native\" C++\n  functions can also do away with the braindamaged passing of pointers to\n  structuresd classes, and use real argument lists.  at least half of the\n  problem with interfacing to C++ is having to deal with the incredible\n  propensity of C++ programmers to make function calls \"efficient\" by using\n  pointers and references and whatnot in a very chaotic way.  such is what\n  happens to people when they don't have lambda lists and multiple return\n  values, but there's no reason to try to map such pain into the Common\n  Lisp world.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "why_no_standard_foreign_language_interface?"
        },
        {
          "id": "3159635132109700@naggum.no",
          "subject": "Re: Why no standard foreign language interface?",
          "author_id": "erik_naggum",
          "date": "2000-02-15",
          "display_date": "02/15/2000",
          "content": "\nSubject: Re: Why no standard foreign language interface?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/15\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159635132109700@naggum.no>\n\n* \"Harley Davis\" <nospam_hdavis@nospam.museprime.com>\n| Erik, could you say a few more words about when you've seen C++ programmer\n| inappropriately pass pointers to structs and classes?  I can't recall having\n| seen much of this to disapprove of, so I'm curious what your experience has\n| been.\n\n  it is not \"inappropriate\" for C++ programmers to pass pointers around --\n  they have no other mechanisms to use for non-trivial argument passing of\n  any kind.  what I consider inappropriate is trying to map such C++-style\n  pointer-passing directly into Common Lisp at the FFI level when we have\n  powerful lamba lists and multiple values, and therefore I favor writing\n  wrapper code in C/C++ that makes use of far simpler argument-passing\n  techniques that can be called with far more ease from Common Lisp.  and\n  since this is drudgery at best, it should be handled by automated tools.\n\n  (and before we have another stupid confusion, I'm _not_ saying (and never\n  have said) that writing such tools is trivial -- I'm saying that the\n  output of such automated tools will of necessity be trivial to make fit\n  _any_ form of FFI glue code that people invent in solitude, and that we\n  should re-focus on the tools, not on standardizing FFIs, which will be a\n  lot of meaningless work to tie vendors and developers into using an FFI\n  with a standard form that won't be able to handle all that interfacing to\n  C++ requires, anyway, simply because of the magnitude of the braindamage\n  in that language and what people do to survive it.)\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "why_no_standard_foreign_language_interface?"
        },
        {
          "id": "3159561770042084@naggum.no",
          "subject": "Re: Why no standard foreign language interface?",
          "author_id": "erik_naggum",
          "date": "2000-02-15",
          "display_date": "02/15/2000",
          "content": "\nSubject: Re: Why no standard foreign language interface?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/15\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159561770042084@naggum.no>\n\n* \"Fernando D. Mato Mira\" <matomira@iname.com>\n| I was going to write:\n| \"Once you figure X in order to see how to do (1) and (2) it's trivial\"\n\n  once again, you have missed what \"it\" refers to.  I'm tiring of this.\n\n| Obviously, you have to \"figure out X\" if you're going to\n| \"figure out how to do (1) and (2)\"\n| \n| Anyway, Erik says:\n| \n| \"Figuring out the C++ syntax takes infinite time so, relatively speaking,\n| implementing a mapping is trivial\"\n\n  what I did in fact say, you George W. Bush you, was that once you got the\n  information, _which_ particular form the FFI glue code should take is\n  trivial.  the argument, since you missed it completely, was against\n  having a _standard_ FFI form, since that is such a trivial piece of the\n  whole equation.  do you get it _now_?\n\n  I realize that some people are so devoid of ethics as to pretend that\n  other people said things they never did simply by putting those funny \"\"\n  characters around any damn lie they want, but I take exception to that,\n  and I take exception to the whole personality of people who are so\n  mind-bogglingly unware of their own actions as not to realize that they\n  are doing this kind of shit.\n\n  go away, Fernando D. Mato Mira.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "why_no_standard_foreign_language_interface?"
        }
      ],
      "post_count": 7,
      "first_post_date": "2000-02-09",
      "last_post_date": "2000-02-15"
    },
    {
      "id": "emacs_lisp_help",
      "title": "emacs lisp help",
      "posts": [
        {
          "id": "3159475193376825@naggum.no",
          "subject": "Re: emacs lisp help",
          "author_id": "erik_naggum",
          "date": "2000-02-13",
          "display_date": "02/13/2000",
          "content": "\nSubject: Re: emacs lisp help\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/13\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159475193376825@naggum.no>\n\n* Robert Monfera <monfera@fisec.com>\n| Would it be possible to solve it by introducing packages into Emacs?\n\n  I wrote the basics of package support in Emacs Lisp.  what we have right\n  now, however, is only proper support for uninterned symbols.  anything\n  more would require rather massive changes that were deemed inappropriate\n  at the time.  [sorry for the response time.]\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "emacs_lisp_help"
        },
        {
          "id": "3159573708053500@naggum.no",
          "subject": "Re: emacs lisp help",
          "author_id": "erik_naggum",
          "date": "2000-02-15",
          "display_date": "02/15/2000",
          "content": "\nSubject: Re: emacs lisp help\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/15\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159573708053500@naggum.no>\n\n* Marco Antoniotti <marcoxa@parades.rm.cnr.it>\n| I suppose at the reader level, isn't it?\n\n  well, since the package system is basically a reader-level thing to begin\n  with, naturally, that's where the problems begin, but they don't end\n  there.  Emacs is currently so hard-wired on the \"one namespace\" idea that\n  it is intractable to make FOO:BAR and BAR be _perceived_ to be the same\n  symbol by any code _other_ than the reader, meaning that code that makes\n  its own symbols needs to be made ware of packages, and code that tries to\n  write and read back data needs to be very carefully reviewed.  I didn't\n  feel like doing that work.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "emacs_lisp_help"
        }
      ],
      "post_count": 2,
      "first_post_date": "2000-02-13",
      "last_post_date": "2000-02-15"
    },
    {
      "id": "benefits_of_tail_recursion_(was:_cost_of_recursion",
      "title": "Benefits of tail recursion (was: Cost of Recursion)",
      "posts": [
        {
          "id": "3159573115430567@naggum.no",
          "subject": "Re: Benefits of tail recursion (was: Cost of Recursion)",
          "author_id": "erik_naggum",
          "date": "2000-02-15",
          "display_date": "02/15/2000",
          "content": "\nSubject: Re: Benefits of tail recursion (was: Cost of Recursion)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/15\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159573115430567@naggum.no>\n\n* Robert Munyer <munyer@mcs.com>\n| For me, a loop written with ITERATE is easier to read than the same loop\n| written with DO.  With ITERATE, the process of computation has a more\n| linear \"flow\" through the text of the function.  With DO, the step forms\n| are interleaved with the initialization forms, which makes the flow of\n| computation feel like it's been \"scattered\" all over the text of the\n| function.\n\n  what's keeping you from writing an ITERATE macro that expands into DO\n  (or, rather, TAGBODY and GO forms)?  it should be eminently doable in the\n  majority of cases where it is indeed only (tail-recursive) iteration.\n\n| In summary: the next time you're programming a loop, and the code doesn't\n| seem to \"fit,\" try using recursion.  You might be surprised how well it\n| works.\n\n  there is no semantic difference between (PSETQ FOO X BAR Z) (GO TAG) and\n  (ITERATOR :FOO X :BAR Z) as long as both \"resolve\" to tail recursion.\n  (I'm using keyword arguments only to be explicit.)\n\n| In fact, I think the whole concept of \"iteration vs. recursion\" is a\n| wrong way to think, a left-over distinction from the days before we\n| understood tail recursion.  I think it makes sense to think of a\n| tail-recursive program as being both iterative AND recursive.\n\n  I agree with you on this.\n\n| Now, on to the example I promised earlier.  Below is a function I wrote a\n| couple of years ago.  As I recall, I tried several times to write it with\n| DO, and every time the code came out UGLY.  So I tried doing it with\n| recursion, and it \"just worked.\"  It was easier to write, and easier to\n| read, and just as efficient as the version I wrote with DO.\n| \n| ; Returns INV such that (= (MOD (* NUMBER INV) MODULUS) (GCD NUMBER MODULUS)).\n| ; Note that if NUMBER and MODULUS are relatively prime, the GCD is 1, and INV\n| ; is the multiplicative inverse of NUMBER over the Galois field of MODULUS.\n| \n| (defun mod-inverse (number modulus)\n|   (check-type number  (integer 1))\n|   (check-type modulus (integer 1))\n|   (iterate iter ((a modulus) (b number) (c 0) (d 1))\n|     (multiple-value-bind (q r) (floor a b)\n|       (cond ((plusp r) (iter b r d (- c (* q d)))) ; thanks Euclid!\n|             ((minusp d) (+ d modulus))\n|             (t d)))))\n\n(do ((a modulus) (b number) (c 0) (d 1))\n    ((multiple-value-bind (q r) (floor a b)\n       (if (plusp r) (psetq a b b r c d d (- c (* q d))) t))\n     (if (minusp d) (+ d modulus) d)))\n\n  it _is_ unfortunate that DO et al were invented so long before multiple\n  values that we sometimes have to expand out the forms manually.\n\n  hope this helps.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "benefits_of_tail_recursion_(was:_cost_of_recursion"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-02-15",
      "last_post_date": "2000-02-15"
    },
    {
      "id": "about_the_usage_of_throw/catch",
      "title": "About the usage of throw/catch",
      "posts": [
        {
          "id": "3156362974458283@naggum.no",
          "subject": "Re: About the usage of throw/catch",
          "author_id": "erik_naggum",
          "date": "2000-01-08",
          "display_date": "01/08/2000",
          "content": "\nSubject: Re: About the usage of throw/catch\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/08\nNewsgroups: comp.lang.lisp\nMessage-ID: <3156362974458283@naggum.no>\n\n* Alexis ARNAUD <a-arna99@bat710.univ-lyon1.fr>\n| at my university, a computer scientist says the usage of throw/catch in\n| Lisp constitutes \"dirty programming\".\n\n  it continues to puzzle me that people who are willing to accept that in\n  any field worth studying, there will always be a limit to how much _one_\n  person can know, for simple logistical reasons: it takes too much time to\n  learn it all, like much longer than a human lifetime.  yet in computer\n  science, that which one person, typically less than 30 years of age,\n  doesn't know is somehow bad, unworthy, dirty, etc.  I'm inclined to\n  believe that such people are inherently unable to deal with complexity\n  beyond their own immediate grasp, and as such should not be dealing with\n  computer science in the first place, since the whole field is all about\n  managing complexity far beyond direct human capabilities, despite the\n  evidence we see from dummies who want to learn \"programming\" in 21 days.\n\n  ask your \"computer scientist\" whether the use of exceptions is also bad.\n  while you're at it, ask her if the RETURN statement in C is dirty, too.\n  and if the problem is that GOTO's are bad, what about WHILE?  WHILE is no\n  more than dressed-up version of GOTO.  THROW and CATCH are similarly a\n  form of GOTO that are not only dressed up, they have university degrees.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "about_the_usage_of_throw/catch"
        },
        {
          "id": "3156499535828192@naggum.no",
          "subject": "Re: About the usage of throw/catch",
          "author_id": "erik_naggum",
          "date": "2000-01-10",
          "display_date": "01/10/2000",
          "content": "\nSubject: Re: About the usage of throw/catch\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/10\nNewsgroups: comp.lang.lisp\nMessage-ID: <3156499535828192@naggum.no>\n\n* arolambler@aol.com (ArolAmbler)\n| I also weigh in on the presumably more controversial side of even\n| return-from as being \"dirty\", not to mention a go outside of the\n| originating tagbody.\n\n  I'd like an example of a GO outside of the \"originating TAGBODY\" that you\n  consider dirty.  (hint: maybe you don't know the language very well...)\n\n| The \"dirtiness\" arises partly from the lack of reusability of the\n| resulting code.\n\n  reusable code is best defined as _functions_ that you can call from other\n  bodies or code than the body of code it was originally designed to serve.\n\n  reusable code is worst defined as code that can be copied (i.e., cut and\n  paste) from one body of code to another -- yet that is what most people\n  consider it to be, mostly because they don't have sufficiently powerful\n  function concepts and engage in programming-by-cut-and-paste themselves.\n\n  \"reusable code\" is nothing more than a new name for \"write library code\n  whenever you can\" which is really nothing more than a way of expressing\n  the age-old concept of \"abstraction\".  of course, when you change focus\n  or angle, but keep staring at the same old thing, you need a new name so\n  the people who got disappointed the first few times won't notice the very\n  same thing you've all been staring at.\n\n| A \"clean\" piece of code in any language should, ideally, never, EVER, for\n| ANY arguments whatsoever, do a non-local transfer of control, of any kind.\n\n  and _I_ think this argument is nothing more than the extremely naïve\n  argument used when people want 100% security or want to abolish accidents\n  completely, and then they go hunting for someone to sue whenever a\n  security violation or an accident happens, as if nature itself offended\n  them by not submitting to their wishful thinking.\n\n  the answer to such folly as \"if only the world were ideal...\" is simply:\n  \"if only the ideals were wordly...\".\n\n  I'm not afraid to implement what I think will have an ideal _interface_\n  using whatever dirty tricks are _necessary_ (but none beyond that, of\n  course).  I don't _want_ people to peek inside my function bodies and\n  reuse the code with cut and paste, nor do I want people to fuck with the\n  code so there will be hundreds of incompatible versions hacked on by\n  people who have no regard for the abstract task it was designed to\n  perform -- I want people to call the function when they can and call me\n  if they can't.\n\n  the desire to abolish accidents is _highly_ irrational.  the same goes\n  for the desire never to see \"dirty\" code.  what it means is that somebody\n  else should pay an enormous price for the wishful thinking to come true,\n  which is quite typical of irrational political desires.  for some reason,\n  the United States is the only country on earth where accidents don't\n  happen -- it's always somebody's fault, and you can sue that somebody for\n  _neglect_.  the same goes for \"dirty\" code -- if you have to code so\n  verbosely that you can't finish typing in finite time, that's somehow\n  better than using a safe mechanism for non-local transfer of control --\n  and the result is the same as the litigous American society: people lose\n  the ability to deal with the exceptional that is still within the normal.\n\n  this is not to say that certain tasks cannot be written in some \"ideal\"\n  way according to some otherwordly school of thought, but the belief that\n  anybody uses non-local transfer of control _wantonly_ is offensive to any\n  competent craftsmen.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "about_the_usage_of_throw/catch"
        },
        {
          "id": "3159477157011411@naggum.no",
          "subject": "Re: About the usage of throw/catch",
          "author_id": "erik_naggum",
          "date": "2000-02-14",
          "display_date": "02/14/2000",
          "content": "\nSubject: Re: About the usage of throw/catch\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/14\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159477157011411@naggum.no>\n\n* arolambler@aol.com (ArolAmbler)\n| I phrased it in a way subject to misintrepretation.  Since the dynamic\n| scope of a tag ends with the dynamic scope of the tagbody, it is not\n| legal tn CL to create closures over recursive tagbodies, and go to tags\n| for tagbodies that have been exited.  (Although I strongly suspect some\n| implementations do not detect the problem, and some may even support it\n| properly.).\n\n  well, I asked for an example, got it, and now I'm asking for more.  why\n  this \"strongly suspect\" point?  it seems you're creating problems for the\n  purpose of creating or showing off complexity, not for the opposing, much\n  more reasonable, purpose of solving them and reducing overall complexity.\n  (this is a more verbose version of the \"ivory tower\" accusation.)\n\n| Thus, foo is called recursively, so there are multiple closures and\n| tagbodies active.\n\n  a GO is explicitly defined to reach the innermost accessible tag, so this\n  is not a semantic problem.  it may be a pragmatic or stylistic problem in\n  that you can't easily figure out which tag is the innermost, however.\n\n| As to \"throw/catch\" being \"needed\".  That is true, WHEN you have to glue\n| together stuff in a hurry, and can't change the interfaces to some of it.\n\n  I think you should consider the possibility that you have overlooked\n  something when you make sweeping generalizations like this.  it is quite\n  annoying to have to deal with statements that are true but incomplete,\n  yet false when completed or extended to their natural context.  that is,\n  your assessment of the situation is relevant, yet not the only one that\n  needs to be considered, and therefore, the conclusion does not hold for\n  anyone but those who restrict themselves to your particular context.\n  again, \"ivory tower\" might apply to such strong yet narrow arguments.\n\n| BUT: it is far better to make the result value have one or more\n| \"exceptional\" values (such as null in ANSII SQL, or the NANs of IEEE\n| floating point arithmetic).  The operations all \"propagate\" the\n| exceptional VALUE, without any non-local control transfer.\n\n  I was disappointed when waiting for the capitalized WHEN to support the\n  \"it is far better\" sweeping generalization sans reservations or context.\n  in some contexts, what you propose is indeed a good idea.  few people use\n  CATCH/THROW or other exception-handling mechanisms in such contexts, for\n  the very simple reason that the first time they run into a problem, they\n  will most probably swear and even more probably redesign their code.  in\n  the context of an exception-handling mechanism that is ill-designed, we\n  do have the option of talking to the people who wrote the code and even\n  in many cases to do what you consider so gross -- to wrap up the code in\n  some advice or whatever to protect you from harm, but doing so in cases\n  where it clearly has no value is an argument against your generalization.\n\n| As I said in the first post on this issue: non-local transfer of control\n| is dirty, because it does not \"reuse\" well.\n\n  yes, this is so, in _some_ contexts, but I'm getting increasingly curious\n  why you exclude all _other_ contexts as inherently irrelevant to any\n  discussion of this language feature or of exception-handling in general.\n\n| Said in a more sophisticated way, incomprehensible probably to the\n| original poster, neither functors nor combinators in general, nor any\n| function that maps a function over a set of values can easily use any\n| function that sometimes throws, unless the function is first \"cleaned up\"\n| by wrapping a catch, return exceptional value piece around it.  And\n| repetitively \"cleaning up\" every time I reuse a function means the\n| function has a bad behavior.\n\n  this is obviously a bogus general claim.  most of the time, we are not\n  faced with irreversible side effects of our functions, and we are not\n  therefore in need of a transactional approach to \"committing\" or not\n  \"committing\" whole executions of complex pieces of code.  it helps, and\n  I'll easily grand you that, to know _when_ to require a simple \"completed\n  or not done at all\" result from a function, however.\n\n  \"best effort\"-functions that return some \"impossible\" values may actually\n  have the annoying consequence that the failure mode is _less_ predictable\n  than an exception, as _some_ transactions were \"committed\" after some\n  failure had occurred, meaning that the failed transactions now have to be\n  committed out of order, or not at all, which is very different from an\n  _aggregate_ \"commit\".  I hope you appreciate this distinction.\n\n  I'm not interested in your ad hominem arguments: just because you have\n  shipped so-and-so-products does not lend any credibility to any of your\n  arguments -- I'm _not_ interested in who you are or what you have done; I\n  _am_ interested in whether you can support your sweeping arguments\n  without reference to such claim to fame or credentials, the inclusion of\n  which in my view detracts very significantly from effective argumentation.\n\n#:Erik, who's beginning to discover that vacations have serious down-sides :)\n\n",
          "references": [],
          "thread_id": "about_the_usage_of_throw/catch"
        }
      ],
      "post_count": 3,
      "first_post_date": "2000-01-08",
      "last_post_date": "2000-02-14"
    },
    {
      "id": "help_with_easy_checksum",
      "title": "Help with easy checksum",
      "posts": [
        {
          "id": "3159560088216201@naggum.no",
          "subject": "Re: Help with easy checksum",
          "author_id": "erik_naggum",
          "date": "2000-02-14",
          "display_date": "02/14/2000",
          "content": "\nSubject: Re: Help with easy checksum\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/14\nNewsgroups: comp.lang.lisp,comp.text.interleaf\nMessage-ID: <3159560088216201@naggum.no>\n\n* Scott Sheffield <scott.y.sheffield@lmco.com>\n| I have created a binary file using Interleaf LISP and I need to put a\n| checksum at the end of the file so that it can be loaded into the\n| hardware.  The problem is though I have a good idea what a checksum is\n| and does I have no idea how to do this in LISP.  Here is what I am told I\n| need to do:\n\n  when you are told what to do in language-specific terms, there's a\n  serious flaw in the thinking of the person telling you what to do.  I'll\n  try to correct that serious flaw by simplifying your requirement to this\n  simple rule:\n\n    when the contents of the file is regarded as a sequence of 32-bit\n    integers, the value of the last 32-bit integer of the file is such that\n    the sum of the 32-bit integers throughout the file is 0 modulo 2^32.\n\n  this is fairly easy to hack together, but it depends on how you write to\n  your stream.  if you write 32-bit integers to the stream (which means it\n  should be opened with :ELEMENT-TYPE '(SIGNED-BYTE 32) or UNSIGNED-BYTE\n  ditto), just sum them up while you write each integer, then write\n  (LDB (BYTE 32 0) (- <SUM>)) to the same stream just before closing it.\n\n  if you don't write 32-bit integers to the file, you're probably better\n  off writing it in one pass and reading it as 32-bit integers in another\n  pass, only to tack on the same 32-bit integer as describe above at the\n  end.\n\n| 2) Write 32 bit chunks to the file, also accumulate the 32 bit chunks\n| into this 32 bit integer object. The accumulation is a add, ignoring\n| overflows (which is standard), then the final step is to take the\n| negative (2's complement) all the accumulations have been done.\n\n  no, ignoring overflows is _not_ standard, it's a a hardware-oriented\n  design decision local to particular languages.  the standard addition\n  function does not overflow to begin with.  please don't confuse the\n  internal hardware representation of a value with the value.\n\n  however, whether you ignore overflow or extract a bit field from an\n  integer is only a conceptual difference.  C-based life forms think in\n  terms of ignoring overflow because they don't know what it means not to.\n  Common Lisp programmers don't ignore overflows, but talk about values\n  _modulo_ some other value, instead.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "help_with_easy_checksum"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-02-14",
      "last_post_date": "2000-02-14"
    },
    {
      "id": "continuations_and_cl",
      "title": "continuations and cl",
      "posts": [
        {
          "id": "3159560513225052@naggum.no",
          "subject": "Re: continuations and cl",
          "author_id": "erik_naggum",
          "date": "2000-02-14",
          "display_date": "02/14/2000",
          "content": "\nSubject: Re: continuations and cl\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/14\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159560513225052@naggum.no>\n\n* Marc Hoffman\n| So I was wondering why call/cc is not implemented.\n\n  because the Common Lisp crowd doesn't want you to implement manually all\n  the control flow mechanisms that CALL/CC is used to implement, and that\n  is because there is no desire to pare the language down to \"essentials\"\n  or Scheme's ascetic/anorectic notions of \"elegance\".\n\n  I think CALL/CC is on par with giving people access to the basic building\n  blocks of a function call, without actual support for function calls.\n  sure, you _can_ do a lot of nifty stuff with those building blocks, but\n  _should_ you?  \"because I can\" is seldom a good answer.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "continuations_and_cl"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-02-14",
      "last_post_date": "2000-02-14"
    },
    {
      "id": "reading/writing_bytes_smaller_than_8_bits?",
      "title": "reading/writing bytes smaller than 8 bits?",
      "posts": [
        {
          "id": "3157825117110563@naggum.no",
          "subject": "Re: reading/writing bytes smaller than 8 bits?",
          "author_id": "erik_naggum",
          "date": "2000-01-25",
          "display_date": "01/25/2000",
          "content": "\nSubject: Re: reading/writing bytes smaller than 8 bits?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/25\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157825117110563@naggum.no>\n\n* \"Bruce L. Lambert\" <lambertb@uic.edu>\n| When I write n (unsigned-byte 4)s to my file-system (solaris 2.6 on a\n| sparc clone), and then I say ls -l to look at the size of the file, there\n| are n bytes in the file rather than n/2 as I would have expected.\n\n  why did you expect that?\n\n| Does this mean the file system can write nothing smaller than an 8-bit\n| byte?\n\n  the file system has nothing to do with it.  Unix doesn't know about file\n  contents at all, and as an operating system design, takes significant\n  pride in that fact.\n\n| If so, does this in any way affect what happens when I read an\n| (unsigned-byte 4) from the same file.\n\n  if you write (unsigned-byte 4) to a file and read it again, you should\n  get the exact same values back.  how these bits are stored is none of\n  your business.\n\n  if your expectations can be defended and you have reason to use this\n  feature to obtain improved storage performance, talk with your CL vendor\n  and have them make it work for you.\n\n| I've played with this some, and the values appear to be correct, but I'm\n| still wondering what's happening 'below the surface'.\n\n  the only people who can really answer that question is the person who\n  implemented the feature in your Common Lisp implementation.  finding that\n  person may be hard, but if you use free software, the source is there.\n  if not, you should use the customer support facilities of the vendor.\n\n| Is it still the case that an array of n 4-bit bytes will occupy (roughly)\n| n/2 bytes of main memory when loaded into lisp?\n\n  if it makes performance sense to do so, or people have argued for this\n  feature even if it didn't, it will.  you can, however, easily measure the\n  space costs of an allocation.  for instance,\n\n(time (make-array 1000 :element-type '(unsigned-byte 4) :initial-element 0))\n; cpu time (non-gc) 0 msec user, 0 msec system\n; cpu time (gc)     0 msec user, 0 msec system\n; cpu time (total)  0 msec user, 0 msec system\n; real time  14 msec\n; space allocation:\n;  9 cons cells, 0 symbols, 512 other bytes, 0 static bytes\n=> #(0 0 0 0 0 0 0 0 0 0 ...)\n(4) cl-user\n(time (make-array 1000 :element-type '(unsigned-byte 8) :initial-element 0))\n; cpu time (non-gc) 0 msec user, 0 msec system\n; cpu time (gc)     0 msec user, 0 msec system\n; cpu time (total)  0 msec user, 0 msec system\n; real time  0 msec\n; space allocation:\n;  9 cons cells, 0 symbols, 1,016 other bytes, 0 static bytes\n=> #(0 0 0 0 0 0 0 0 0 0 ...)\n(5) cl-user\n(time (make-array 1000 :element-type '(unsigned-byte 2) :initial-element 0))\n; cpu time (non-gc) 0 msec user, 0 msec system\n; cpu time (gc)     0 msec user, 0 msec system\n; cpu time (total)  0 msec user, 0 msec system\n; real time  0 msec\n; space allocation:\n;  9 cons cells, 0 symbols, 512 other bytes, 0 static bytes\n=> #(0 0 0 0 0 0 0 0 0 0 ...)\n(6) cl-user\n(time (make-array 1000 :element-type '(unsigned-byte 1) :initial-element 0))\n; cpu time (non-gc) 0 msec user, 0 msec system\n; cpu time (gc)     0 msec user, 0 msec system\n; cpu time (total)  0 msec user, 0 msec system\n; real time  0 msec\n; space allocation:\n;  9 cons cells, 0 symbols, 144 other bytes, 0 static bytes\n=> #*0000000000.. ; [abbreviated by me]\n(7) cl-user\n(time (make-array 1000 :element-type '(unsigned-byte 16) :initial-element 0))\n; cpu time (non-gc) 0 msec user, 0 msec system\n; cpu time (gc)     0 msec user, 0 msec system\n; cpu time (total)  0 msec user, 0 msec system\n; real time  0 msec\n; space allocation:\n;  9 cons cells, 0 symbols, 2,016 other bytes, 0 static bytes\n=> #(0 0 0 0 0 0 0 0 0 0 ...)\n\n  the reported results show the storage strategies and optimizations for\n  various data types.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "reading/writing_bytes_smaller_than_8_bits?"
        },
        {
          "id": "3157913150482948@naggum.no",
          "subject": "Re: reading/writing bytes smaller than 8 bits?",
          "author_id": "erik_naggum",
          "date": "2000-01-26",
          "display_date": "01/26/2000",
          "content": "\nSubject: Re: reading/writing bytes smaller than 8 bits?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/26\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157913150482948@naggum.no>\n\n* gat@jpl.nasa.gov (Erann Gat)\n| Nothing prevents a vendor from issuing a proposal that includes\n| proprietary technology or trademarks.  Politics often prevents such\n| proposals from being adopted.  That's why they tend to be rare, and also\n| why it is entirely justified to ask the question.\n\n  well, if they tend to be rare, I'd have expected some _justification_ for\n  the implicit expectation that this was one of those rare cases.\n\n  however, to zoom out a bit, if people in the Common Lisp community wonder\n  why there's so (comparatively) little communal development activity, do\n  consider the responses received to the work that _is_ being done when it\n  is published.  as far as I have seen, the response is generally \"thanks.\n  now where's the rest?\", no matter how much you do.  it almost sounds like\n  a Norwegian tax collector, one of nature's strongest de-motivating forces.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "reading/writing_bytes_smaller_than_8_bits?"
        },
        {
          "id": "3157890572406899@naggum.no",
          "subject": "Re: reading/writing bytes smaller than 8 bits?",
          "author_id": "erik_naggum",
          "date": "2000-01-26",
          "display_date": "01/26/2000",
          "content": "\nSubject: Re: reading/writing bytes smaller than 8 bits?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/26\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157890572406899@naggum.no>\n\n* Andrew Cooke <andrew@andrewcooke.free-online.co.uk>\n| Ouch!  Next week I'm planning to write code that generates binary files\n| to a certain standard (Midi music data).  I haven't checked the docs yet,\n| but this post implies that there is no way to generate files with a\n| specified binary format (at least that other people or other Lisps can\n| use with certainty).  Is that correct?  What do people do when they need\n| to write a formatted binary file?  Or does everyone use just Lisp\n| programs ;-) ?\n\n  locate your misplaced calm and _breathe_, mister, you're near hysterical.\n\n  if you know that the medium is an 8-bit medium, opening a stream for\n  writing to or reading from it as (UNSIGNED-BYTE 8) is guaranteed to\n  produce the expected results by virtue of the insanity of not doing so.\n\n  if you need control over the individual bits, you don't request a service\n  where you explicitly say \"do the smartest thing you can with my request\".\n\n  please realize that the Common Lisp community is more than 40 years old.\n  collectively, the community has already been where every clueless newbie\n  will be going for the next three years.  so relax, please.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "reading/writing_bytes_smaller_than_8_bits?"
        },
        {
          "id": "3157896071676495@naggum.no",
          "subject": "Re: reading/writing bytes smaller than 8 bits?",
          "author_id": "erik_naggum",
          "date": "2000-01-26",
          "display_date": "01/26/2000",
          "content": "\nSubject: Re: reading/writing bytes smaller than 8 bits?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/26\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157896071676495@naggum.no>\n\n* \"Bruce L. Lambert\" <lambertb@uic.edu>\n| I just figured 1 byte = 8 bits, therefore 1 (unsigned-byte 4) = 4 bits =\n| 0.5 bytes both in Lisp and in a file on disk. Simple, yet erroneous,\n| deductive logic on my part.\n\nbyte n. 1. adjacent bits within an _integer_. (The specific number of bits\ncan vary from point to point in the program; see the _function_ BYTE.)\n                     -- from the Common Lisp the Standard (ANSI X3.226-1994)\n\n| If not the OS, then what system determines how an (unsigned-byte 4) or\n| any other object gets written to disk?  Does each application make its\n| own decisions on this point?\n\n  yes.  Unix doesn't know about file contents.  it stores only bytes (still\n  of no predetermined size).  the only common byte size these days is 8,\n  but Unix was delivered in the past on machines with 9-bit bytes.  (this\n  historical fact has even escaped most C programmers.)\n\n| I just was trying to understand the space considerations of some code I'm\n| writing.  I figured there was a direct mapping from the size of the\n| internal data structure to the size of the file.\n\n  there never are.\n\n  the first tenet of information representation is that external and\n  internal data formats are incommensurate concepts.  there simply is no\n  possible way they could be conflated conceptually.  to move from external\n  to internal representation, you have to go through a process of _reading_\n  the data, and to move from internal to external representation, you have\n  to go through a process of _writing_ the data.  these processes are\n  non-trivial, programmatically, conceptually, and physically.  that some\n  languages make them appear simple is to their credit, but as always,\n  programming languages are about _pragmatics_, and it doesn't make sense\n  to make conceptually complex things complex to use and program -- quite\n  the contrary, in fact.  so the more things that are different look the\n  same to a programmer, the higher the likelihood that there is something\n  complex and worthwhile going on behind the scenes.\n\n  the second tenet of information representation is that optimizations for\n  internal representations are invalid for external representation and vice\n  versa.  the crucial difference is that data in internal representation is\n  always under the control of the exact same software at all times, while\n  data in external representation _never_ is.  therefore, decisions you\n  make when optimizing internal representation exploit the fact that you\n  have full control over the resources that are being used to represent it,\n  such as actually knowing all the assumptions that might be involved,\n  while decisions you make when optimizing external representation must\n  yield to the fact that you have no control over the resources that are\n  being used to represent it.  a corollary is that storing any data in raw,\n  memory-like form externally (_including_ network protocols) is so stupid\n  and incompetent that programmers who do it without thinking should be\n  punished under law and required to prove that they have understood the\n  simplest concepts of computer design before they are ever let near a\n  computer again.\n\n  the third tenet of information representation is that data in _any_\n  external representation is _never_ outlived by the code, and that is an\n  inherent quality of external representation: the very reason you decided\n  to write it out to begin with is the reason it won't go away when the\n  code that wrote it did.  this fact alone so fundamentally alters the\n  parameters of optimization of external representation from internal that\n  the only consequence of not heeding it is to wantonly destroy information.\n\n  now, there is one particular software company that profits by breaking\n  all possible understanding of information representation, and who makes\n  their very living from destroying the value of information previously\n  committed to the care of their software.  this _started_ through sheer,\n  idiotic incompetence on their part, but turned into company policy only a\n  few years later: the company mission is now to destroy information like\n  no company has ever done before, for the sole purpose of causing the\n  customers to continue to pay for software that renders their past useless\n  and thus in need of re-creation, data conversion, etc.\n\n| That is, if a thousand-element array of 4-bit bytes takes 512 bytes\n| (according to time), and I write the contents of that array to disk, I\n| expected to see a 512 byte file.  Not so, apparently.\n\n  avoid the temptation to confuse internal with external representation,\n  and you will do fine.  as soon as you think the two are even remotely\n  connected (as such -- going through a read/write process is precisely the\n  point showing how they are _not_ connected as such), you lose.  big time,\n  and the way back to unconfusion is long and hard.  witness all the C\n  victims who actually think it makes sense to dump memory to files.  they\n  lose so badly you'd think somebody would learn from it, but no -- their\n  whole philosophy is to remain braindamaged in the face of danger, as that\n  kept them out of the scary, scary task of having to _think_ about things,\n  not something C programmers are very good at.\n\n  a 1000-element vector of (unsigned-byte 4) may optimally be stored as 500\n  bytes on a disk file if you are willing to _know_ what the file is like.\n  typically, hwoever, you would include metainformation that is not needed\n  once it has been processed and is in memory, versioning information, some\n  form of validation clues for the information (array bounds, etc), and in\n  all likelihood if you store binary data, some compression technique.\n  many arguments to the contrary notwithstanding, binary representation,\n  when it has been made to work, is _incredibly_ bloated compared to what\n  people set out believing it will be.  making binary representation\n  efficient is so hard that most people give up, satisfied with gross\n  inefficiency.  a Microsoft Word document is the typical example of how\n  unintelligently things _can_ be done when the real dunces are let at it.\n\n  you may actually be better off writing your vector of 4-bit bytes out as\n  hexadecimal digits, pretending that it is a huge number.  Common Lisp\n  does not offer you any _huge_ help in hacking such notations back to more\n  common internal representations, but actually trying to time the work you\n  do during I/O has left many programmers bewildered by the cost of such a\n  simple operation.  a disk read can easily take millions of times longer\n  than a memory read.  whether you decode digits in that time or map bits\n  directly into memory is completely irrelevant to the system performance.\n\n  the conditions under which these low-level things matter are so different\n  from what normal people experience that they will have studied the topic\n  of internal and external representation very carefully before they need\n  to know the details.\n\n| Allegro is my vendor.\n\n  well, no, Franz Inc is the vendor behind Allegro CL.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "reading/writing_bytes_smaller_than_8_bits?"
        },
        {
          "id": "3157890087157420@naggum.no",
          "subject": "Re: reading/writing bytes smaller than 8 bits?",
          "author_id": "erik_naggum",
          "date": "2000-01-26",
          "display_date": "01/26/2000",
          "content": "\nSubject: Re: reading/writing bytes smaller than 8 bits?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/26\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157890087157420@naggum.no>\n\n* Marco Antoniotti <marcoxa@parades.rm.cnr.it>\n| Is this a X3J13 proposal or a Franz proprietary one?\n\n  how can _proposals_ be proprietary?  sheesh.\n\n  work on this topic was \"commissioned\" at the last X3J13 meeting, and\n  Franz accepted the responsibility to oversee the work if not write it.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "reading/writing_bytes_smaller_than_8_bits?"
        },
        {
          "id": "3157925691061115@naggum.no",
          "subject": "Re: reading/writing bytes smaller than 8 bits?",
          "author_id": "erik_naggum",
          "date": "2000-01-27",
          "display_date": "01/27/2000",
          "content": "\nSubject: Re: reading/writing bytes smaller than 8 bits?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/27\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157925691061115@naggum.no>\n\n* gat@jpl.nasa.gov (Erann Gat)\n| Rudeness can also be an inhibitor to communal development.  All else being\n| equal most people will choose to work with someone who is friendly and\n| gives them the benefit of the doubt rather than someone who is rude and\n| condescending and makes worst-case assumptions about their motives.\n\n  I'm happy that you, too, consider Marco Antoniotti's response _rude_\n  towards Franz Inc, and that you support my point: if you suspect the\n  worst of motives when you receive a gift from somebody, other people\n  generally don't give you much _more_ for free from then on.\n\n  as for rudeness in this particular case, maybe you just need to learn to\n  live with the fact that people find _you_ rude and _disgusting_ to deal\n  with when you don your halo and fight to save the world from a rudeness\n  you find only when _you_ make worst-case assumptions about the motives of\n  others, but I guess that's OK since you do it, wearing that halo.  I wish\n  you had learned something, but you really learned _nothing_ from the last\n  time we had this discussion.  *sigh*\n\n  and if you are such a champion of benefit of the doubt, consider making\n  some actions of yours conform to your self-serving claims some day.  it\n  would be a little less disgusting to behold a reeking hypocrite actually\n  follow his _own_ advice once in a while, at least.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "reading/writing_bytes_smaller_than_8_bits?"
        },
        {
          "id": "3158009696783450@naggum.no",
          "subject": "Re: reading/writing bytes smaller than 8 bits?",
          "author_id": "erik_naggum",
          "date": "2000-01-28",
          "display_date": "01/28/2000",
          "content": "\nSubject: Re: reading/writing bytes smaller than 8 bits?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/28\nNewsgroups: comp.lang.lisp\nMessage-ID: <3158009696783450@naggum.no>\n\n* Marco Antoniotti <marcoxa@parades.rm.cnr.it>\n| The question I had in mind was: can Harlequin implement the API described\n| in a Franz Copyrighted document?\n\n  this \"question\" is an insult to people who provide information to the\n  community.  just because they see no reason to give away everything and\n  every right to their work does not mean that they are bastards out to\n  control people's reasonable courses of action.  copyright is a fairly\n  well-defined legal concept -- it does not preclude understanding and\n  using the information and ideas whose expression is protected from\n  reproduction, and never has precluded such use.  in particular, copyright\n  does not affect the implementability of a specification.\n\n| This is what I read here.  Apologies if my question was too concise.\n\n  I really think you need to study some copyright law.  unfounded fears\n  such as the ones you have expressed can lead to no good, especially if\n  they go unchecked and you actually believe that affixing a copyright\n  notice to a specification has any bearing on its implementability.\n\n  sometimes, I wonder if the reason people favor free software is that they\n  have zero clue about the freedoms and rights they actually _have_ within\n  the boundaries of intellectual property law, and maybe the bone-headed\n  intellectual-property lawyers of, say, DVD-CCA, tend to reinforce their\n  fears, too, but hysterics like fearing that a copyright notice would not\n  allow others to implement the functions described in a document, _could_\n  explain why people who want source code to everything consistently fail\n  to grasp the meaning of \"license\", in particular, that the GPL is in fact\n  a _license_ that grants them a bunch of rights they otherwise do not\n  have, and that if they are not granted all these rights by the only legal\n  entity that can grant them, they are in fact violating intellectual\n  property laws, whether they get prosecuted for it or not, or, indeed,\n  whether they are cast as world-class heroes for it or not.  arguing such\n  topics requires people to know the rights they have _under_ the law --\n  intellectual property is one of those areas where the law grants rights\n  that cannot be abridged by contract or agreement.  few \"freedom fighters\"\n  realize that they are often storming open doors and fighting for what\n  they already have.  some \"freedom fighters\" implicitly accuse others of\n  denying them rights they cannot be denied, except to the degree that they\n  willfully reject the option of exercising them, for which hardly anyone\n  else can be held responsible.\n\n  a population which has natural rights and has also been granted rights\n  under the law, but which is so ignorant of their rights that they believe\n  anyone can take them away from them at will, will live in such fear of\n  the law itself that both rights and law lose their meaning.  this is what\n  is happening to the ignorant hacker community, quite unlike what _could_\n  happen to the knowledgeable hackers of only a few years past.  \"ignorance\n  of the law is no excuse\" cuts both ways.  incompetence in the search for\n  freedom will only cause them to find the freedom to be incompetent.\n  \n#:Erik\n\n",
          "references": [],
          "thread_id": "reading/writing_bytes_smaller_than_8_bits?"
        },
        {
          "id": "3159474410537964@naggum.no",
          "subject": "Re: reading/writing bytes smaller than 8 bits?",
          "author_id": "erik_naggum",
          "date": "2000-02-13",
          "display_date": "02/13/2000",
          "content": "\nSubject: Re: reading/writing bytes smaller than 8 bits?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/13\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159474410537964@naggum.no>\n\n* Marco Antoniotti <marcoxa@parades.rm.cnr.it>\n| Now the question for you is: is this a \"legitimate\" issue to raise?\n\n  implementing a standard is always voluntary.  this may annoy some people\n  (it annoys me _greatly_ at times, like when the stupid Norwegian Language\n  Council incredulously insists on writing \"13.2.00\" for today, for the\n  single, simple, stupid reason that the Swedes write \"2000-02-13\", and we\n  can't do anything the Swedes do unless it's really stupid and then not\n  until they figured out that it was stupid and did something else that we\n  obviously can't do at that point, but I digress irresponsibly).  even\n  when some proposal is put into a standard, the user community has to be\n  responsible and take issue with half-witted or bogus implementations.\n\n| > I really think you need to study some copyright law.\n| \n| Yes and no.  I can just ask you :)\n\n  yikes!  like most other people who give legal advice on the Net, what I\n  have said on legal matters have turned out to be wrong at some later\n  date, so this is an almost _frightening_ level of \"trust\".  like the\n  other day, British authorities came up with this bill that would make it\n  illegal _not_ to decode files or messages stored on your computer, as if\n  the bloody obvious assault on every citizen's assumption of innocence\n  until proven guilty would _not_ be to store files or messages on their\n  computer to which they did not in fact _have_ a decoding key.  the police\n  often plant evidence in drug cases to incarcerate people they just don't\n  like, and now they can do the same with computer people they just don't\n  like.  however, a few weeks ago, I would have said this was impossible to\n  implement under the European Human Rights Convention, but what do you\n  know?  I was wrong: in the interest of removing personal freedom and\n  security from people's lives when they do something politicians are\n  afraid of out of sheer, mind-numbing ignorance, _anything_ goes, and\n  _anywhere_ in the world, even England, with their Magna Carta heritage.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "reading/writing_bytes_smaller_than_8_bits?"
        }
      ],
      "post_count": 8,
      "first_post_date": "2000-01-25",
      "last_post_date": "2000-02-13"
    },
    {
      "id": "beginners_course",
      "title": "Beginners course",
      "posts": [
        {
          "id": "3159300637009358@naggum.no",
          "subject": "Re: Beginners course",
          "author_id": "erik_naggum",
          "date": "2000-02-11",
          "display_date": "02/11/2000",
          "content": "\nSubject: Re: Beginners course\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/11\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159300637009358@naggum.no>\n\n* kt-alt@SprocketShop.com (Kenneth P. Turvey)\n| I was corrected via email.  In my discussion of English grammar I often\n| referred to pronouns used for people of indeterminate sex as neuter.\n| This isn't really the case.  In English the neuter pronoun is \"it\", we\n| use \"he\" typically when we are referring to people of indeterminate sex\n| (although not always and there is no steadfast rule).  \n| \n| Should we modify the LOOP macro to accept \"he\", \"she\", and \"it\"?  \n\n  if someone ever gets the really bad idea to translate Common Lisp to New\n  Norwegian (as opposed to Old Norse, not the real Norwegian), they will\n  have to cope with the disconcerting habit in that language of referring\n  to inanimate objects with \"han\" (he) and \"hun\" (she).  try \"she went to\n  see this movie.  he was better than she expected.\" on for size.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "beginners_course"
        },
        {
          "id": "3159473417014873@naggum.no",
          "subject": "Re: Beginners course",
          "author_id": "erik_naggum",
          "date": "2000-02-13",
          "display_date": "02/13/2000",
          "content": "\nSubject: Re: Beginners course\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/13\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159473417014873@naggum.no>\n\n* Michael Dingler <mdingler@mindless.com>\n| Linguists to the rescue, isn't this more like the norm and English\n| is one of the few exceptions?\n\n  well, real Norwegian doesn't suffer from this confusion of inanimate with\n  animate objects, and usually restricts \"he\" and \"she\" to human beings.\n  inanimate objects and in most circumstances also animals are referenced\n  with our equivalents of \"it\", which may be \"den\" (male/female gender) or\n  \"det\" (neuter gender).  incidentally, furriners get this wrong all the\n  time, so it is clearly complex.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "beginners_course"
        }
      ],
      "post_count": 2,
      "first_post_date": "2000-02-11",
      "last_post_date": "2000-02-13"
    },
    {
      "id": "what_is_lisp?",
      "title": "What is LISP?",
      "posts": [
        {
          "id": "3159120191728291@naggum.no",
          "subject": "Re: What is LISP?",
          "author_id": "erik_naggum",
          "date": "2000-02-09",
          "display_date": "02/09/2000",
          "content": "\nSubject: Re: What is LISP?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/09\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159120191728291@naggum.no>\n\n* Robert Posey <muddy@raytheon.com>\n| Question 1:\n| \n| As I understand it nothing in CL standard requires an Interpreter, does\n| it even require an interactive mode?\n\n  standards always have explicitly and very strictly limited scope.  the\n  way users interact with a Common Lisp system is outside the scope of the\n  Common Lisp standard.\n\n| Question 2:\n| \n| What should LISP typing method be called?\n\n  it is already called \"dynamic typing\", \"manifest typing\", etc.\n\n| I have heard several variations, but all the more advanced code I have\n| seen makes use of typing for at least some of the symbols.\n\n  you're applying static typing terminology to dynamic typing phenomena.\n  this will hurt your understanding.  in Common Lisp, _values_ have type,\n  and variables can (normally) hold values of any type.  therefore, you\n  don't talk about the type of symbols (variables), but about the types of\n  values that a variable can hold.  in statically typed languages, the type\n  affects the layout and size of the memory allocated to a variable.  in\n  Common Lisp, a variable is always allocated the same size memory, and\n  what it holds is a pointer to the value, stored elsewhere, except in some\n  obvious optimizations like (small) integers and characters, which fit in\n  the space of such a pointer.  to make things work efficiently in this\n  model, pointers carry type information.  this is very much unlike what\n  you do in statically typed languages, where pointers are just machine\n  addresses which the compiler hopes will point to values it knows, and\n  then it tries to make sure its hopes come true by barfing on code that it\n  can see will or does violate its hopes.  it can never actually be 100%\n  certain, however.  using typed pointers, one doesn't have to deal with\n  such silly hopes, and can instead work with whatever is there.\n\n  put it another way, in a statically typed language, you may sometimes\n  need to lie to your compiler to do the right thing, like you sometimes\n  have to lie to officials who are anal-retentive about stupid laws and\n  regulations, while in dynamically typed languages, you don't have to lie,\n  because the laws and regulations can't be stupid.\n\n| Question 3:\n| \n| Is it true that you can overload(in C++ Terms) built in operators in LISP? \n\n  no.  C++-style overloading is fundamentally evil, and is therefore not\n  supported by good languages.  (note: this is not an opinion.)\n\n| Question 4:\n| \n| What does the :ntest (I think) key do for applicable functions?\n\n  whatever the function documents it to do.  the meaning of keywords\n  arguments is not added vertically to functions in Common Lisp.\n\n  :NTEST is unknown to me.  however, if you refer to the :TEST-NOT keyword,\n  common to functions which also sport a :TEST keyword, for functions that\n  support this semantics, it's a way to specify a test function to whose\n  value NOT is applied before it is used.  another way to do the same thing\n  is :TEST (COMPLEMENT <function>).\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "what_is_lisp?"
        },
        {
          "id": "3159296157829526@naggum.no",
          "subject": "Re: What is LISP?",
          "author_id": "erik_naggum",
          "date": "2000-02-11",
          "display_date": "02/11/2000",
          "content": "\nSubject: Re: What is LISP?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/11\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159296157829526@naggum.no>\n\n* Erik Naggum\n| C++-style overloading is fundamentally evil, and is therefore not\n| supported by good languages.  (note: this is not an opinion.)\n\n* Vladimir Nesterovsky\n| So far it's the only C++ feature as I know of, that has no correspondence\n| in Common LISP.  That's the only argument of the C++ people that I don't\n| know how to answer to.\n| \n| While I'll take your word for it, could you please just provide me with\n| some explanation, so that whenever that argument comes, I'd have an\n| answer.\n\n  sure.\n\n  the main semantic argument against C++-style operator overloading is that\n  there is nothing in the language that helps maintain consistency of any\n  kind for each implementation of an overloaded operator.  in particular,\n  each implementation may well have completely different argument lists,\n  commutativity may differ at will, but you still have to cope with the\n  same associativity and order of precedence.  a + is not a +, anymore.\n  (witness the absurd and decidedly overcute use of << and >> for I/O.)\n\n  the main pragmatic argument against C++-style operator overloading is a\n  fatal design decision.  the choice of which function to call makes the\n  use of overloaded operators downright dangerous: the return type of an\n  overloaded operator is _not_ taken into account when choosing the\n  particular implementation, which causes a cascade of decisions in nested\n  or sequential forms over which you have no control.  in particular, code\n  changes anywhere in an interconnected system can affect such decisions\n  adversely, without even the possibility of warning or traceability since\n  editing and (re-)compiling are so separated tasks.\n\n  the main stylistic argument is that a reader of the code has no idea what\n  to expect from _any_ expression that uses operators that _might_ have\n  been overloaded, without _manually_ checking for surprises, _remembering_\n  the types of objects, and trying to reconstruct the whole decision chain\n  made by the compiler.\n\n  so what makes a language feature evil?  first, when it wastes human brain\n  time on minutiae that language features are supposed to help _conserve_\n  or at least spend _more_ wisely.  second, when it forces people to\n  second-guess the compiler to figure out what's going on.  third, when you\n  despite second-guessing the compiler can no longer know for _certain_\n  what will happen, but have to makes guesses in the first place.  all in\n  all, a language feature is evil when it removes from the programmer's\n  control what, precisely, he is doing, at all levels of abstraction and\n  semantics and he is left with uncertainty and doubt, if not obscure bugs\n  that are extremely hard to find and which makes systems using such\n  features frightfully fragile.\n\n  even the good uses of operator overloading, for which they were added to\n  that miserable excuse for a programming language, destroy the ability of\n  _any_ \"visiting\" programmer to know what _any_ expression means, meaning\n  that the required level of intimacy with the code is tremendously high,\n  which translates to \"job security\" for Joe C++ Programmer and \"how to get\n  royally screwed\" for his employer.\n\n  so not only is operator overloading evil, programmers who want it are\n  looking for \"insurance\" if they should ever have any serious gripes with\n  their employers.  as I have said previously, in connection with the need\n  among C++ programmers to \"protect\" their data and methods, C++ is for\n  thieves and bums who expect _others_ to steal, too; operator overloading\n  is just more of the same: bad people are attracted to features with high\n  abusiveness potential along with anal-retentive protection schemes\n  because they expect everybody else to screw them, too.\n\n  (very little of this is _mere_ opinion.)\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "what_is_lisp?"
        }
      ],
      "post_count": 2,
      "first_post_date": "2000-02-09",
      "last_post_date": "2000-02-11"
    },
    {
      "id": "[n]truncate-list_?",
      "title": "[N]TRUNCATE-LIST ?",
      "posts": [
        {
          "id": "3159291352590096@naggum.no",
          "subject": "Re: [N]TRUNCATE-LIST ?",
          "author_id": "erik_naggum",
          "date": "2000-02-11",
          "display_date": "02/11/2000",
          "content": "\nSubject: Re: [N]TRUNCATE-LIST ?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/11\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159291352590096@naggum.no>\n\n* Philip Lijnzaad <lijnzaad@ebi.ac.uk>\n| after some browsing in the HyperSpec, I couldn't find a function that yields,\n| as a list, the first N elts of the list passed as an argument, sort of the\n| opposites of [N]BUTLAST.\n\n  have you looked at SUBSEQ for the non-destructive version?  or a fairly\n  plain SETF of NTHCDR for a destructive version?  if you have to check for\n  the length, use NTHCDR, see if you get a cons cell, then SETF its CDR.\n  there's absolutely _no_ need to check the length of the list, which,\n  incidentally, may be circular, so use LIST-LENGTH instead of LENGTH if\n  you think you really have to.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[n]truncate-list_?"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-02-11",
      "last_post_date": "2000-02-11"
    },
    {
      "id": "querying_whether_there_is_a_method_which_is_applic",
      "title": "Querying whether there is a method which is applicable for an arglist",
      "posts": [
        {
          "id": "3159202464932715@naggum.no",
          "subject": "Re: Querying whether there is a method which is applicable for an arglist",
          "author_id": "erik_naggum",
          "date": "2000-02-10",
          "display_date": "02/10/2000",
          "content": "\nSubject: Re: Querying whether there is a method which is applicable for an arglist\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/10\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159202464932715@naggum.no>\n\n* Robert Monfera <monfera@fisec.com>\n| Maybe (clos:compute-applicable-methods generic-function arguments) would\n| work for you, if your implementation has MOP.\n\n  COMPUTE-APPLICABLE-METHODS is in the COMMON-LISP package in ANSI Common\n  Lisps, and is unrelated to whether the implementation has MOP.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "querying_whether_there_is_a_method_which_is_applic"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-02-10",
      "last_post_date": "2000-02-10"
    },
    {
      "id": "beginner_question_on_input_from_large_files",
      "title": "beginner question on input from large files",
      "posts": [
        {
          "id": "3159210673593055@naggum.no",
          "subject": "Re: beginner question on input from large files",
          "author_id": "erik_naggum",
          "date": "2000-02-10",
          "display_date": "02/10/2000",
          "content": "\nSubject: Re: beginner question on input from large files\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/10\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159210673593055@naggum.no>\n\n* Joseph Dale <jdale@uclink4.berkeley.edu>\n| I'm trying to write a function that takes the name of a dictionary file\n| containing one word per line and returns the contents of that file as a\n| list of strings.\n\n  first off, it's a reasonable thing to do.\n\n| The latest of several versions is this one (I know it's not very elegant):\n\n  au contraire, it's _too_ elegant.\n\n| (defun get-words (filename)\n|   (let ((*words* '()))\n|     (defun read-loop (stream)\n|       (setf *words* (cons (read-line stream nil 0) *words*))\n|       (if (numberp (first *words*))\n| \t  (rest *words*)\n| \t(read-loop stream)))\n|     (with-open-file (stream filename :direction :input)\n| \t\t    (read-loop stream))))\n\n  whether this is compiled or not, this is needlessly complex and \"elegant\"\n  only in the Scheme sense, which is not elegant at all in Common Lisp.\n\n(defun stream-lines (input-stream)\n  (do ((lines nil)\n       (line #1=(read-line input-stream nil :eof) #1#))\n      ((eq line :eof) (nreverse lines))\n    (push line lines)))\n\n  if you're not as silly as to have an allergic reaction to LOOP, this is\n  even better:\n\n(defun stream-lines (input-stream)\n  (loop for line = (read-line input-stream nil :eof)\n\tuntil (eq line :eof)\n\tcollect line))\n\n  using a number for magic purposes and then testing for any number is\n  _really_ bad style.  where did you pick this up?  a Perl class?\n\n| The function works with files containing less than around 10,000 words,\n| but no matter what I do, whenever I call this function with a file\n| containing more words, I get a stack overflow or a core dump. How can I\n| do this with larger files? I feel like there must be a better way.\n\n  recursion has its uses.  using recursion for iteration is not one of\n  them.  Scheme educators got that one _seriously_ confused, and your code\n  is simply such Scheme code in Common Lisp.  this is _not_ a reasonable\n  thing to do, not even in Scheme.\n\n  my suggestions:\n\n1 get rid of the internal define.\n2 use iteration forms when that's what you do.\n3 use recursion for inherently recursive tasks, only.\n4 learn Common Lisp if you want to think in Common Lisp.\n5 use Scheme if you think in Scheme.\n\n  writing Scheme code in Common Lisp is also really bad for your karma.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "beginner_question_on_input_from_large_files"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-02-10",
      "last_post_date": "2000-02-10"
    },
    {
      "id": "interned_symbols_and_gc",
      "title": "Interned Symbols and GC",
      "posts": [
        {
          "id": "3159028659830535@naggum.no",
          "subject": "Re: Interned Symbols and GC",
          "author_id": "erik_naggum",
          "date": "2000-02-08",
          "display_date": "02/08/2000",
          "content": "\nSubject: Re: Interned Symbols and GC\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/08\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159028659830535@naggum.no>\n\n* Christian Lebiere <cl@andrew.cmu.edu>\n| For better or worse, our application generates lots of interned symbols.\n\n  well, if you don't use the Lisp reader to find symbols by name, there are\n  always a number of available solutions better than using interned\n  symbols.  if, say, you only use symbols as unique keys, but whose name\n  does not actually matter, a fresh cons cell like (nil . nil) may be used\n  as long as you keep the key around someplace else.  if the name matters,\n  you can also use a string.\n\n| MCL seems to garbage-collect interned symbols after a while when they are\n| no longer referenced (which hasn't caused a problem so far), while\n| Allegro CL seems to keep them around forever (which causes it to bog down\n| and crash if given enough time).\n| \n| I have a couple of questions:\n| \n| 0) Is the above description accurate?\n\n  no.  an interned symbol is ipso facto referenced -- by the very package\n  in which it is interned!\n\n  moreover, whether a symbol is \"useless\" or not is not determined by what\n  references the symbol, but by what the symbol references -- quite the\n  opposite of your concern.  the whole point with an interned symbol is\n  that it holds onto some values and that there might be a reference to\n  those values in the future through the symbol by its name read from an\n  outside source, so _clearly_ we can't chuck interned symbols -- it would\n  defeat the fundamental purpose of symbols.  (aggressive short-sightedness\n  is required to label this fact \"unfortunate\", as some evidently do.)\n  \n| 1) What is the correct behavior, if there is one (CLTL2 has little to say)?\n\n  since MCL is clearly in the wrong as you have described it, I'm inclined\n  to think that something else is at work.\n\n  btw, CLtL2 is no longer _the_ language reference.  use the HyperSpec (or\n  the standard).\n \n| 2) Is there a way to get rid of interned symbols that are no longer\n| needed that is safer and more efficient than to explicitely unintern them\n| individually?\n\n  DELETE-PACKAGE gets rid of the last reference to interned symbols that\n  have no references, for all symbols in that package.   you could always\n  copy the symbols you need to a new package, and do your own copying\n  garbage collection that way.\n\n  iterators over symbols are allowed to unintern the symbol it looks at.\n  you may want to use DO-SYMBOLS over the symbols in a package to get rid\n  of the ones you don't need.\n\n\n  it sounds as if what you _really_ want is a weak hash table that you\n  index with _some_ unique key, as outlined at the start of this message.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "interned_symbols_and_gc"
        },
        {
          "id": "3159121393908428@naggum.no",
          "subject": "Re: Interned Symbols and GC",
          "author_id": "erik_naggum",
          "date": "2000-02-09",
          "display_date": "02/09/2000",
          "content": "\nSubject: Re: Interned Symbols and GC\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/09\nNewsgroups: comp.lang.lisp\nMessage-ID: <3159121393908428@naggum.no>\n\n* Sam Steingold <sds@gnu.org>\n| when foo:bar (which calls read) is called from the package zot, it\n| internes in zot.  I wish I could control where the symbols are\n| interned.  (e.g., with *read-intern* which can be NIL for no interning,\n| T for interning in *package* and a package to intern in that package).\n\n  this makes _zero_ sense.  you're not calling functions \"from\" any\n  packages in Common Lisp.  the default package used by INTERN is the value\n  of *PACKAGE*, and READ doesn't do anything magical in the absence of a\n  package specification, so if you want to control the package into which\n  INTERN interns symbols, justbind *PACKAGE* to that package.\n\n  what more control do you want?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "interned_symbols_and_gc"
        }
      ],
      "post_count": 2,
      "first_post_date": "2000-02-08",
      "last_post_date": "2000-02-09"
    },
    {
      "id": "looking_up_entries_in_a_table_of_ranges",
      "title": "looking up entries in a table of ranges",
      "posts": [
        {
          "id": "3158948495513418@naggum.no",
          "subject": "Re: looking up entries in a table of ranges",
          "author_id": "erik_naggum",
          "date": "2000-02-07",
          "display_date": "02/07/2000",
          "content": "\nSubject: Re: looking up entries in a table of ranges\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/02/07\nNewsgroups: comp.lang.lisp\nMessage-ID: <3158948495513418@naggum.no>\n\n* Jason Kantz\n| I need to make a table that returns an entry for a value in a given\n| range.  And I'm wondering if a more experienced programmer can comment\n| on whether this is a common data structure with a common name.\n\n  looks like a sorted association list to me.\n\n(assoc 50.0 '((10.0 . \"this stuff\")\n\t      (40.0 . \"this other stuff\")\n\t      (100.0 . \"yet some other stuff\"))\n       :test #'<=)\n=> (100.0 . \"yet some other stuff\")\n\n  FIND would allow you to use a sequence of more complex objects and use\n  :KEY to extract the slot you want to look at.\n\n  in any case, I would expect such a function to be called FIND-foo, foo\n  being the object you're looking for.  whether you implement it as a\n  general function traversing a list or a function with a fast TYPECASE\n  dispatch on ranges is largely immaterial, though.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "looking_up_entries_in_a_table_of_ranges"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-02-07",
      "last_post_date": "2000-02-07"
    },
    {
      "id": "cl_for_windowsnt?",
      "title": "CL for WindowsNT?",
      "posts": [
        {
          "id": "3157794263893856@naggum.no",
          "subject": "Re: CL for WindowsNT?",
          "author_id": "erik_naggum",
          "date": "2000-01-25",
          "display_date": "01/25/2000",
          "content": "\nSubject: Re: CL for WindowsNT?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/25\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157794263893856@naggum.no>\n\n* \"Jonathan Coupe\" <jonathan@meanwhile.freeserve.co.uk>\n| ACL isn't really freeware, it's a very limited demo of a commercial product.\n| The main limitation is that the amount of memory you can use is *tiny*.\n\n  facts are useful, grumpy opinions not.  the heap space is limited to\n  about 35M.  this has been comfortably roomy for any educational and trial\n  use of the version, which was the stated purpose, which being a mere demo\n  version was not.  in other words, you're refusing to consider the\n  purposes for which it was given away and are instead complaining about\n  not having your will.  you should say that up front, so people can see\n  that the complaints come from someone who only wants stuff for free and\n  has no respect for those who give things away.  ungrateful people like\n  you make it harder to argue for a commercial enterprise to give stuff\n  away that people can make reasonable use of.\n\n  I'm deeply concerned that the more people complain about free versions\n  out of greed or stupidity, the less likely they are to continue to be\n  made available.  think long-range, and help _motivate_ the vendor to make\n  stuff available that is usable to you.  OK?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "cl_for_windowsnt?"
        },
        {
          "id": "3158124092664969@naggum.no",
          "subject": "Re: CL for WindowsNT?",
          "author_id": "erik_naggum",
          "date": "2000-01-29",
          "display_date": "01/29/2000",
          "content": "\nSubject: Re: CL for WindowsNT?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/29\nNewsgroups: comp.lang.lisp\nMessage-ID: <3158124092664969@naggum.no>\n\n* \"Jonathan Coupe\" <jonathan@meanwhile.freeserve.co.uk>\n| Do read posts more carefully, please.\n\n  can those of you who abide by this sage advice please notice that some of\n  us do not want mailed copies of news articles (especially not the even\n  more annoying _unidentified_ copies that show up as news articles some\n  time after you have replied by mail to some jerk who never responds\n  because he thinks others are wasting his mailbox space, too) and that we\n  use the now standard and recommended header \"Mail-Copies-To: never\" to\n  express this desire?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "cl_for_windowsnt?"
        }
      ],
      "post_count": 2,
      "first_post_date": "2000-01-25",
      "last_post_date": "2000-01-29"
    },
    {
      "id": "lisp_and_scheme.....",
      "title": "Lisp and Scheme.....",
      "posts": [
        {
          "id": "3157978564787770@naggum.no",
          "subject": "Re: Lisp and Scheme.....",
          "author_id": "erik_naggum",
          "date": "2000-01-27",
          "display_date": "01/27/2000",
          "content": "\nSubject: Re: Lisp and Scheme.....\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/27\nNewsgroups: comp.lang.scheme,comp.lang.lisp\nMessage-ID: <3157978564787770@naggum.no>\n\n* Chung-Lin Tang <u8832022@cc.nctu.edu.tw>\n| How much does Lisp and Scheme differ?\n\n  completely.  two completely different cultures, two completely different\n  measures of success, two completely different concepts of elegance and\n  usability, two completely different sets of semantics for superficially\n  similar forms of expression.  as languages, they have less in common than\n  Ada and Perl.  as user communities, only the Scheme people believe that\n  they are using a Lisp, based on the belief that retaining parentheses and\n  prefix form is enough to remain a Lisp -- and, of course, the desire in\n  the Scheme community to convert people to their pure religion, a desire\n  you won't find in any other Lisp-derived community, especially not those\n  of the languages who have any purity to boast about.  Scheme has the\n  world's most elegant, yet closed, language specification, while the other\n  Lisp family members focus on elegant language _use_ and _extension_.\n\n  while this may be taken as an exaggeration, it's less of an exaggeration\n  than the ignorant opinion that these languages are substantially the same.\n\n  Scheme is worth learning well -- no other language has a more succinct\n  way of teaching you programming language concepts, but the language also\n  has the most succinct way of teaching you language design mistakes if you\n  listen critically to its many design decision and don't accept them as\n  the gospel they are attempted sold as.\n\n  Common Lisp is worth knowing and using well -- no other language has a\n  more succinct (yet supremely readable) expression of complex, real-life\n  programming tasks and problems, and your ability to build your language\n  towards your problem is its most unique strength, yet the very concept of\n  building a language suitable to a problem is foreign to most other\n  languages and programming cultures.\n\n  incidentally, Scheme was a very good example of what happens when you\n  take a particular, favored programming methodology and hard-code it into\n  a language design -- you find that as you optimize your design too much,\n  you lose the freedom to do anything else with similar ease without having\n  to create _another_ and separate mini-language, and this means writing\n  all the support machinery all over again for every langauge -- a favored\n  academic exercise worth approximately nothing outside academia once you\n  get the degree.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "lisp_and_scheme....."
        },
        {
          "id": "3158074185873884@naggum.no",
          "subject": "Re: Lisp and Scheme.....",
          "author_id": "erik_naggum",
          "date": "2000-01-28",
          "display_date": "01/28/2000",
          "content": "\nSubject: Re: Lisp and Scheme.....\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/28\nNewsgroups: comp.lang.lisp\nMessage-ID: <3158074185873884@naggum.no>\n\n* David Rush <kumo@bellsouth.net>\n| >  -- and, of course, the desire in\n| >   the Scheme community to convert people to their pure religion,\n| \n| Which desire is *clearly* absent from your soul.\n\n  geez.  rejecting religion is not a belief, despite attitudes prevalent in\n  certain religious circles.  matter of fact, I don't want to convert\n  anyone (except to metric and ISO 8601) -- in my admittedly arrogant view,\n  if you need conversion, you're already a waste of space and time.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "lisp_and_scheme....."
        },
        {
          "id": "3158012259636814@naggum.no",
          "subject": "Re: Lisp and Scheme.....",
          "author_id": "erik_naggum",
          "date": "2000-01-28",
          "display_date": "01/28/2000",
          "content": "\nSubject: Re: Lisp and Scheme.....\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/28\nNewsgroups: comp.lang.scheme,comp.lang.lisp\nMessage-ID: <3158012259636814@naggum.no>\n\n* arthurgleckler@my-deja.com\n| Since you posted your message in <comp.lang.scheme>, ...\n\n  I apologize.  that was a mistake.  cross-posting is evil, and between\n  Scheme and Lisp communities even more so.  I have told my newsreader to\n  flag such articles when responding to them.  I'll have a stern talk with\n  it as to why it failed to alarm me this time.  bad software!  bad!\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "lisp_and_scheme....."
        }
      ],
      "post_count": 3,
      "first_post_date": "2000-01-27",
      "last_post_date": "2000-01-28"
    },
    {
      "id": "copyrighted_header_files_(was:_reading/writing...)",
      "title": "Copyrighted header files (was: reading/writing...)",
      "posts": [
        {
          "id": "3158075016590411@naggum.no",
          "subject": "Re: Copyrighted header files (was: reading/writing...)",
          "author_id": "erik_naggum",
          "date": "2000-01-28",
          "display_date": "01/28/2000",
          "content": "\nSubject: Re: Copyrighted header files (was: reading/writing...)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/28\nNewsgroups: comp.lang.lisp\nMessage-ID: <3158075016590411@naggum.no>\n\n* \"Fernando D. Mato Mira\" <matomira@iname.com>\n| Itchy question: What happens when the specification is (partly) expressed\n| in a copyrighted C header file?  Even if you type yourself every byte,\n| it'll be essentially the same thing.\n\n  invoke \"fair use\" and claim that you cannot copyright numerical constants.\n\n  copyright does not cover reproducing functional equivalence, so you could\n  argue that you're not reproducing more than you have to in order to use\n  the specification for its intended purpose (which by law is prevented\n  from being \"to screw the readers\" :).\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "copyrighted_header_files_(was:_reading/writing...)"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-01-28",
      "last_post_date": "2000-01-28"
    },
    {
      "id": "would_compiler-macro_cut_it?",
      "title": "Would COMPILER-MACRO cut it?",
      "posts": [
        {
          "id": "3157713765421792@naggum.no",
          "subject": "Re: Would COMPILER-MACRO cut it?",
          "author_id": "erik_naggum",
          "date": "2000-01-24",
          "display_date": "01/24/2000",
          "content": "\nSubject: Re: Would COMPILER-MACRO cut it?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/24\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157713765421792@naggum.no>\n\n* Robert Monfera <monfera@fisec.com>\n| I'd like to implement a custom vector type, which stores fixnums and\n| double-floats only.\n\n  from your problem description, it does not seem excessively rational to\n  want to store fixnums.  I'd just go ahead and store double-floats.\n\n| Hopefully the relative lack of discussions on compiler-macrolet is not an\n| indication that it is an esoteric facility that should be avoided.  It\n| looks wonderful to me, provided I can make it work.\n\n  it is indeed a useful facility, but it helps a lot to be able to access\n  the declarations and (other) type information (inferences) in the\n  environment it is expanded.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "would_compiler-macro_cut_it?"
        },
        {
          "id": "3157981207714177@naggum.no",
          "subject": "Re: Would COMPILER-MACRO cut it?",
          "author_id": "erik_naggum",
          "date": "2000-01-27",
          "display_date": "01/27/2000",
          "content": "\nSubject: Re: Would COMPILER-MACRO cut it?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/27\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157981207714177@naggum.no>\n\n* Christopher Browne\n| Using floats for something that is inherently rational seems to me to\n| be fundamentally irrational.  (And there are too many puns there to\n| feel comfortable...)\n\n  the machine representation of a floating point number _is_ a rational!\n  specifically, M*2^E, for Mantissa (an integer) and Exponent (an integer),\n  usually with a separate sign, but that's beside the point.  contrary to\n  common beliefs, floating point numbers _are_ exact, they just aren't the\n  numbers we'd _like_ to be exact, because we stupidly cling to decimal\n  instead of hexadecimal or octal.\n\n| The *problem* with using floats for financial operations is that this\n| causes you to enter into all the numerical stability issues that are\n| rampant in FP math.\n\n  this is sheer nonsense.  the reason we run into numerical stability\n  issues in floating point arithmetic operations is that we're asking the\n  system to find the representable (exact) number that is closest to the\n  (exact, but unrepresentable) result of a computation.  as long as the\n  result is representable, floating point arithmetic cannot but remain\n  exact and stable.\n\n| <ick-mode>\n| Common Lisp probably needs to have a BCD numeric representation for\n| this purpose.\n| </ick-mode>\n\n  supporting BCD numeric representation only makes sense when the hardware\n  also supports it.  for all common, relevant purposes, arbitrary-precision\n  integers suffice.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "would_compiler-macro_cut_it?"
        }
      ],
      "post_count": 2,
      "first_post_date": "2000-01-24",
      "last_post_date": "2000-01-27"
    },
    {
      "id": "transmeta's_crusoe_as_a_host_for_neo-lispm,_or_not",
      "title": "Transmeta's Crusoe as a host for neo-Lispm, or not?",
      "posts": [
        {
          "id": "3157383843342698@naggum.no",
          "subject": "Re: Transmeta's Crusoe as a host for neo-Lispm, or not?",
          "author_id": "erik_naggum",
          "date": "2000-01-20",
          "display_date": "01/20/2000",
          "content": "\nSubject: Re: Transmeta's Crusoe as a host for neo-Lispm, or not?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/20\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157383843342698@naggum.no>\n\n* \"Joe Marshall\" <jmarshall@alum.mit.edu>\n| Current processors are `C machines'.\n\n  this belongs in comp.arch, I guess, but isn't this why Merced is a flop\n  so far -- that is, since it _isn't_ a traditional \"C processor\"?\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "transmeta's_crusoe_as_a_host_for_neo-lispm,_or_not"
        },
        {
          "id": "3157725884436112@naggum.no",
          "subject": "Re: Transmeta's Crusoe as a host for neo-Lispm, or not?",
          "author_id": "erik_naggum",
          "date": "2000-01-24",
          "display_date": "01/24/2000",
          "content": "\nSubject: Re: Transmeta's Crusoe as a host for neo-Lispm, or not?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/24\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157725884436112@naggum.no>\n\n* Tim Bradshaw <tfb@cley.com>\n| OK, from all this I get:\n| \n| \tWe can design a lisp processor which will run Lisp about 5x as fast\n| \tas a pentium will run C, at the same clock rate.  And if the market\n| \twas equivalently large, this chip would cost about the same as a\n| \tpentium.\n| \n| This is a conclusion that I find very uncomfortable indeed.  As far as I\n| can see this means either that, in some deep sense, Lisp is a language\n| which can be made to go much faster than C, or that in fact the pentium\n| is a very poor `C machine', and much faster C machines could be designed.\n| Neither option seems very likely to me.\n\n  once upon a time, when ANSI C was fairly young and compilers for the\n  language were new enough to be simple enough for me to understand, I\n  spent a fair amount of time studying then-current processors and how they\n  would optimally \"represent\" C.  it turns out that C was a good language\n  back when PDP-11 was a good processor.  C has sucked since then, more and\n  more so over the years.  today, C is probably the crappiest language you\n  can possibly find, made worse only by its \"improvement\", C++.  neither\n  has a snowball's chance in hell of being compiled into _optimal_ machine\n  code on modern processors.  the language itself is so low-level it tries\n  to run on a \"virtual\" processor that only to the untraied eye looks like\n  modern processors.\n\n  I recently had the opportunity to study the Pentium III from the inside,\n  and I was positively amazed by what the Intel guys have managed to hide\n  behind that god-awful instruction set they have to be compatible with.\n  it's good stuff, and it isn't being used because people are still stuck\n  on the 386 and refuse to compile programs for 686s.\n\n  if you actually _used_ the Pentium III architecture for Lisp, you'd truly\n  run rings around C, but since Lisp vendors, too, tend to stay with what\n  is likely to sell well, you can't ask people to upgrade to 600MHz PIIIs\n  just to get that super performance over C when C is doing \"adequately\" on\n  a 133MHz PPro.  this _actually_ means that the performance gain for C is\n  much smaller than the performance gain for Lisp, it is taken to mean that\n  the _processors_ wouldn't provide that much performance gain for Lisp,\n  either, considering the mind-bogglingly uintelligent conflation of C with\n  \"optimal hardware performance\".\n\n  C and C++ are firmly stuck in the early 80's as far as processor design\n  is concerned.  Common Lisp never was stuck anywhere in the first place,\n  which means it has had a hard time sticking to something in particular,\n  as well, but at least it has the uncommon ability to let go.\n\n  the task of good programmers everywhere is to get rid of C, or, more\n  precisely, the C mindset and the gravely mistaken notion that C is\n  somehow \"inherently efficient\".\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "transmeta's_crusoe_as_a_host_for_neo-lispm,_or_not"
        },
        {
          "id": "3157901044670304@naggum.no",
          "subject": "Re: Transmeta's Crusoe as a host for neo-Lispm, or not?",
          "author_id": "erik_naggum",
          "date": "2000-01-26",
          "display_date": "01/26/2000",
          "content": "\nSubject: Re: Transmeta's Crusoe as a host for neo-Lispm, or not?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/26\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157901044670304@naggum.no>\n\n* Barry Margolin <barmar@bbnplanet.com>\n| I'm not familiar with the Pentium III architecture (I haven't really\n| studied an instruction set since the Z80).  Could you give some examples\n| of the features you're talking about?\n\n  I'd like to, but that needs delving back into the documentation and doing\n  quite a bit of research.  I have not found time for it in the past few\n  days, and a three-week break is coming up fast, so I have to disappoint\n  you with long response times on this one.\n\n| Are these things like the MMX instructions (those were in the Pentium II,\n| as well, weren't they)?\n\n  the simplest idea is to use published knowledge of the core architecture\n  to schedule register updates, memory transactions, etc, vastly more\n  efficiently.  several new instructions have also been added to make life\n  a lot easier for particular tasks -- but actually being able to use them\n  well requires significant effort on both the part of the programmers and\n  the compiler writers.\n\n| I know it has lots of bit-twiddling instructions that are supposed to be\n| useful for graphics, and I think some DSP-related instructions, but\n| neither of these seem like they would be of much assistance in Lisp.\n\n  once I understood what they were doing, they were useful mathematical\n  functions and transformations that required you to shape your problem in\n  a particular way to be able to use.  some of these \"contortions\" would\n  not be something a Lisp compiler would ordinarily engage in at all.\n  however, I wanted to be able to use these instructions and looked at how\n  I would have to go about that, but in the end, I decided against adding\n  instructions to the compiler.\n\n| How do other applications make use of these features?\n\n  inlined assembly, or even whole functions in assembly language.  there\n  are few compilers out there that can make full use of these things, but\n  the instruction scheduling isn't terribly hard to codify.  the best part\n  is that when it's done properly, it doesn't affect performance on the\n  older processors.  the new instructions are sometimes expanded as macros\n  by the better assemblers into instruction sequences for older processors.\n\n| Isn't there some way to use the instructions and trap into macrocode when\n| running on an older processor?\n\n  there are a whole bunch of CPU flags which tell you whether these new\n  features are available or not, so you would typically prepare a fat\n  binary that contained several versions of the same function according to\n  processor to make optimal use of these features.  many games do this.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "transmeta's_crusoe_as_a_host_for_neo-lispm,_or_not"
        }
      ],
      "post_count": 3,
      "first_post_date": "2000-01-20",
      "last_post_date": "2000-01-26"
    },
    {
      "id": "[q]_more_beginner_help",
      "title": "[Q] More beginner help",
      "posts": [
        {
          "id": "3157726537067075@naggum.no",
          "subject": "Re: [Q] More beginner help",
          "author_id": "erik_naggum",
          "date": "2000-01-24",
          "display_date": "01/24/2000",
          "content": "\nSubject: Re: [Q] More beginner help\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/24\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157726537067075@naggum.no>\n\n* Pierre De Pascale <dpa@siemens.ch>\n| Actually your solution is recursive. Look that in your loop construct you\n| call (recursively) FLATTEN depending on the type of ELEMENT.  This is\n| clearly a case of recursion.\n\n  you're right, of course.  the recursion that I find silly, and therefore\n  reacted to, is using recursion to traverse lists, or recursing on the\n  CDR.  for the sake of argument, I ignored the recursion on the CAR.  I\n  think you made a good point for why that shouldn't be done.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[q]_more_beginner_help"
        },
        {
          "id": "3157705666120505@naggum.no",
          "subject": "Re: [Q] More beginner help",
          "author_id": "erik_naggum",
          "date": "2000-01-24",
          "display_date": "01/24/2000",
          "content": "\nSubject: Re: [Q] More beginner help\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/24\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157705666120505@naggum.no>\n\n[ please look at how other Common Lisp programmers indent and present their\n  code.  parentheses are _not_ visually significant, although they are very\n  syntactically significant, in Lisp source code.  don't make them stand\n  out -- please -- you're code is so ugly it's hard to help you with it. ]\n\n* Dirt <pip3@inam3.com>\n| I am trying to \"unravel\" a list, but with little luck. I wish to take a\n| list such as:\n| \n| \t(a (b c (d e)) f)\n| \n| and create a new list that looks like one top level list:\n| \n| \t(a b c d e f)\n\n  this is normally called \"flattening\" a list.\n\n| I am trying to do this recursively but I am guessing I am way off because\n| I get a stack overflow.  What I am trying to say in my code below is:\n| \n| If the expression is a list, call the function again with the cdr of the\n| list, otherwise it is an atom so cons it to a list.\n\n  what you wish to do is to move each element of each list you encounter\n  onto a new list.  I'll try to show you with slightly more modern Common\n  Lisp that you're using:\n\n(defun flatten (list)\n  (loop for element in list\n        if (listp element) nconc (flatten element)\n        else collect element))\n\n  if you actually _need_ recursion, which will only waste space and time,\n  you should be able to unravel this iterative solution easily.  in my not\n  so humble opinion, being able to think recursively is very valuable, the\n  second most valuable ability you can have, beaten only by knowing _when_\n  to use recursion.\n\n  incidentally, this function considers an empty list a list of no elements\n  while you might want NIL to be a separate element in the resulting list.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[q]_more_beginner_help"
        },
        {
          "id": "3157804298757708@naggum.no",
          "subject": "Re: [Q] More beginner help",
          "author_id": "erik_naggum",
          "date": "2000-01-25",
          "display_date": "01/25/2000",
          "content": "\nSubject: Re: [Q] More beginner help\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/25\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157804298757708@naggum.no>\n\n* Jon K Hellan <hellan@acm.org>\n| This would have been an appropriate response if Dirt had asked a\n| typical\n\n  sigh.\n\n  Dirt's reaction would have been appropriate if anyone had actually\n  accused him of any wrong-doing.  I'm trying to tell him (and now you),\n  that you have to _listen_ to what people are saying, not just react to\n  what _you_ feel.  please heed my advice, or heed my secondary advice:\n  shut up if you have nothing to contribute.\n\n| I think Dirt should be welcome on the net.\n\n  your implication that somebody thinks he is not is insulting.  quit it.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[q]_more_beginner_help"
        },
        {
          "id": "3157793707546559@naggum.no",
          "subject": "Re: [Q] More beginner help",
          "author_id": "erik_naggum",
          "date": "2000-01-25",
          "display_date": "01/25/2000",
          "content": "\nSubject: Re: [Q] More beginner help\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/25\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157793707546559@naggum.no>\n\n* Dirt <pip3@inam3.com> -> Robert Monfera\n| I find it quite discouraging to see comments such as yours. Is this\n| not a learning enviroment?  Don't ask!! Don't learn!! Your Bad!!!\n\n  attempting to use USENET for homework has long traditions and only\n  marginally shorter traditions of rebuke, hostile reactions, and general\n  ill feelings in return.  when you ask for help in solving really simple\n  problems that any good textbook alredy explains well, you're putting\n  yourself in the homework category, whether you are doing homework on the\n  Net or not.  defensive reactions _reinforce_ that impression strongly.\n\n  if you want to learn something from the net, be prepared to listen to\n  _all_ the answers you get.  criticism is always well intended at first,\n  but the stupid, destructive people who insist on defending themselves\n  whenever something they do is criticized and on attacking people \"back\"\n  who never actually attacked them, make this a very strenous medium for\n  such people.  you see, people who are attacked this way are _not_ going\n  to give you any benefit of the doubt: you are clearly guilty of hostile\n  activities towards others, and if you respond strongly to such attacks,\n  so will everybody else.  if you feel unfairly attacked, consider the fact\n  that you attack others unfairly on purpose when you attack them for\n  having behaved badly towards you.  in short, stupid people escalate a\n  normal process of mild correction and attitude readjustment into flames\n  and out-and-out hostilities.  the solution is obvioulsy to get rid of the\n  stupid people, but until we can do that, all we can do is ask people to\n  stop behaving stupidly.\n\n  instead of getting worked up over criticism you don't understand, strive\n  to understand what made it arise in the first place.  most of the time,\n  it has simple, straightforward reasons that you can easily change, and\n  which it would be incredibly stupid of you not to change, because that\n  means you don't listen and really _are_ stupid, like one particular dude\n  here who never listens to anything he doesn't already agree to, and who\n  accuses those who try to readjust his attitude of being psychopaths and\n  maniacs, which only proves that he's just as retarded as they think he is.\n\n  incidentally, this is not really a learning environment.  it's really an\n  environment for sharing ideas and experiences with others.  the helping\n  and _learning_ part is the result of motivating those who have something\n  that you need to share it.  you don't do that by looking like you're\n  doing homework on the Net.  you can't change that by accusing people of\n  holding stupid attitudes like \"Don't ask!! Don't learn!! Your Bad!!\".\n\n  so wise up, and behave like you're asking and learning and taking part in\n  this environment, not just exploiting it and wasting people's time by not\n  doing your homework _between_ articles you post to this forum.  note the\n  \"behave like\" -- nobody cares what you actually _do_ or _think_, as they\n  can't see that in your articles and can't react to it unless they make\n  the grave error of pretending to see people's thoughts across the net.\n  (do notice how you make this mistake.)\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[q]_more_beginner_help"
        }
      ],
      "post_count": 4,
      "first_post_date": "2000-01-24",
      "last_post_date": "2000-01-25"
    },
    {
      "id": "setf_implementation",
      "title": "setf implementation",
      "posts": [
        {
          "id": "3157726372992359@naggum.no",
          "subject": "Re: setf implementation",
          "author_id": "erik_naggum",
          "date": "2000-01-24",
          "display_date": "01/24/2000",
          "content": "\nSubject: Re: setf implementation\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/24\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157726372992359@naggum.no>\n\n* mjd@op.net (Mark-Jason Dominus)\n| I was surprised by this, because I had picked up a different idea from\n| somewhere.\n\n  it's a notion from C's pointer concept.  as such, it's pretty bogus.\n\n| When you evaluate (cdr ...), you get back a pointer to the cdr, and\n| then the enclosing function receives this pointer as an argument.\n\n  that's precisely what you don't do in Common Lisp.  you don't get a\n  pointer to the CDR, you get the value of the CDR, which may or may not be\n  a pointer, depending on its type.  in any case, you're not getting a\n  pointer to something settable.\n\n  consider this schematic (yikes, I'm having to resort to graphics!):\n\n        +-------+-------+\n    X:  |  CAR  |  CDR  |--> ZOT\n        +-------+-------+\n            |\n            V\n           FOO\n\n  when you evaluate (CDR X), you get ZOT back.  if you wish the CDR of X to\n  point to something else, you would do (setf (cdr x) 'bar), but if you\n  have already obtained ZOT, you don't know where to store BAR.\n\n  therefore, in C terminology, what SETF gives you is the address of the\n  slot you wish to change, but that is not at all similar to a pointer to\n  the value _in_ that slot.\n\n  therefore, your approach won't work, since it misses out on the crucial\n  level of indirection.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "setf_implementation"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-01-24",
      "last_post_date": "2000-01-24"
    },
    {
      "id": "[q]:_recursion_help",
      "title": "[Q]: Recursion help",
      "posts": [
        {
          "id": "3157638343605377@naggum.no",
          "subject": "Re: [Q]: Recursion help",
          "author_id": "erik_naggum",
          "date": "2000-01-23",
          "display_date": "01/23/2000",
          "content": "\nSubject: Re: [Q]: Recursion help\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/23\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157638343605377@naggum.no>\n\n* Dirt <pip3@inam3.com>\n| >Here's something to try for you with your implementation:\n| >\n| >> (eq 7391827918273091 7391827918273091)\n| >NIL\n| >> (eq 2.0 2.0)\n| >NIL\n| >>\n| \n| Yea, I tried that out and it didn't work just like you said. Thanks\n| for pointing this out to me guys.\n\n  note that (EQL 2.0 2.0) => T, but (EQL 2 2.0) => NIL.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[q]:_recursion_help"
        },
        {
          "id": "3157638303325956@naggum.no",
          "subject": "Re: [Q]: Recursion help",
          "author_id": "erik_naggum",
          "date": "2000-01-23",
          "display_date": "01/23/2000",
          "content": "\nSubject: Re: [Q]: Recursion help\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/23\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157638303325956@naggum.no>\n\n* Dirt <pip3@inam3.com>\n| So, it is safe to recommend to my professor that we should be taught\n| to use '=' to compare numbers rather than 'eq'?\n\n  your professor should never teach EQ in the first place.  EQ should be\n  discovered by good students on their own.  novices should always use EQL\n  for typeless object comparison, and try not to think about EQ.\n\n  = signals an error for non-numbers.  this is often a major pain.  EQL\n  yields false if the objects are of different types.  this can sometimes\n  be exactly what you want.  = yields true for _numeric_ equality, which\n  can sometimes be very expensive to compute, but is often worth the cost,\n  except when you control the types of both objects and you would have to\n  be a real klutz to introduce that cost wantonly.  therefore, EQL will\n  tell you about suboptimal programming practices if it yields false on two\n  numbers that appear \"alike\", and this fact alone will teach most students\n  better programming practices.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[q]:_recursion_help"
        }
      ],
      "post_count": 2,
      "first_post_date": "2000-01-23",
      "last_post_date": "2000-01-23"
    },
    {
      "id": "[q]:_need_help_with_cons",
      "title": "[Q]: Need help with cons",
      "posts": [
        {
          "id": "3157402011629405@naggum.no",
          "subject": "Re: [Q]: Need help with cons",
          "author_id": "erik_naggum",
          "date": "2000-01-21",
          "display_date": "01/21/2000",
          "content": "\nSubject: Re: [Q]: Need help with cons\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/21\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157402011629405@naggum.no>\n\n* Dirt <pipe@rochester.rr<.>com>\n| Is there a way to create the following list using 'cons'\n| \n|      ( ( (a (b (x) d) ) ) )\n\n  sure.  (cons '((a (b (x) d))) nil)\n\n  you take your homework from there.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "[q]:_need_help_with_cons"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-01-21",
      "last_post_date": "2000-01-21"
    },
    {
      "id": "how_to_append_an_item_to_a_list_?",
      "title": "how to append an item to a list ?",
      "posts": [
        {
          "id": "3157378406727027@naggum.no",
          "subject": "Re: how to append an item to a list ?",
          "author_id": "erik_naggum",
          "date": "2000-01-20",
          "display_date": "01/20/2000",
          "content": "\nSubject: Re: how to append an item to a list ?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/20\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157378406727027@naggum.no>\n\n* Arseny Slobodjuck\n| Actually i need something like push, but unlike push it have to insert\n| new item to the end of list.\n\n  if you don't need a list, consider VECTOR-PUSH.\n\n| So, i need an equivalent to \n| \n|        (setq a (concatenate 'list a (list b)))\n\n(append a (list b))\n\n|       (rplacd (last a) (list b))\n\n(setf (setf tail (cdr tail)) (cons b nil))\n\n  is better, once you keep two variables to point into the list:\n\n(setf tail (cons nil nil))\n(setf head (cdr tail))\n\n  you might want to do this in a structure or class to capture it in a\n  unit, but most of the time, you can use this technique in a short piece\n  of code without the overhead of extra datatypes and their accessors.\n\n  however, the most common way to do this is to collect the items in a list\n  in reverse, and then reverse the list (destructively, with NREVERSE).\n  this won't work if you need access to the list elements along the way, in\n  which case only the HEAD/TAIL approach outlined above will do.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "how_to_append_an_item_to_a_list_?"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-01-20",
      "last_post_date": "2000-01-20"
    },
    {
      "id": "entirely_off-topic_(is_oo_any_good)",
      "title": "Entirely off-topic (is OO any good)",
      "posts": [
        {
          "id": "3157299588639428@naggum.no",
          "subject": "Re: Entirely off-topic (is OO any good)",
          "author_id": "erik_naggum",
          "date": "2000-01-19",
          "display_date": "01/19/2000",
          "content": "\nSubject: Re: Entirely off-topic (is OO any good)\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/19\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157299588639428@naggum.no>\n\n* Janos Blazi -> Robert Monfera\n| Your recent responses to my questions consist of three parts:\n| (i) pretty informative and interesting\n| (ii) breathtakingly naive (as though I had not been struggling with OO for\n| years; as though I had not read about it;)\n| (iii) plainly offensive.\n| \n| And it is difficult to part the wheat and the chaff.  I think I am not\n| going to.\n\n  being able to handle information productively when it runs counter to\n  one's existing beliefs is perhaps the defining attribute of an operative\n  intelligence, since it defines how we deal with information from which we\n  can either learn or recoil, if we don't ignore it as \"not grasped\".\n\n  there is ample evidence that you lack this defining attribute and there\n  are few redeeming qualities to your many _really_ stupid postings in this\n  newsgroup.  had you actually been interested in the topic at hand, you\n  would also have been willing to learn whatever was learnable here -- yet\n  this is where you fail miserable, evidently on _purpose_.\n\n  I wonder why people even bother to reply to you with anything technically\n  useful that you are clearly _unwilling_ to grasp unless you already agree\n  with it, in which case you insult people for being naive.\n\n  please, go annoy people someplace else with your breathtaking stupidity.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "entirely_off-topic_(is_oo_any_good)"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-01-19",
      "last_post_date": "2000-01-19"
    },
    {
      "id": "returning_the_name_of_a_function",
      "title": "Returning the name of a function",
      "posts": [
        {
          "id": "3157153555377756@naggum.no",
          "subject": "Re: Returning the name of a function",
          "author_id": "erik_naggum",
          "date": "2000-01-18",
          "display_date": "01/18/2000",
          "content": "\nSubject: Re: Returning the name of a function\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/18\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157153555377756@naggum.no>\n\n* \"Coby Beck\" <cbeck@mercury.bc.ca>\n| Admittedly not a big deal in this example, but it got me curious.\n\n  I suggest reading the manual on Allegro CL's TRACE top-level command.  as\n  far as I understand your question, it does what you want, and much more.\n\n  debugging by inserting code is generally considered to be very intrusive\n  to the code in question, and even more unlikely to produce efficient\n  bug-hunting.  consider ADVICE, TRACE, STEP, etc, instead.  debugging in\n  Common Lisp and C are as different as the languages are.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "returning_the_name_of_a_function"
        },
        {
          "id": "3157214622741552@naggum.no",
          "subject": "Re: Returning the name of a function",
          "author_id": "erik_naggum",
          "date": "2000-01-18",
          "display_date": "01/18/2000",
          "content": "\nSubject: Re: Returning the name of a function\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/18\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157214622741552@naggum.no>\n\n* sashank@vuse.vanderbilt.edu (Sashank Varma)\n| they can definitely differ if the magic-defuned function returns\n| a closure, e.g.:\n\n  this illustrates the incompleteness of the \"solution\".  take a hint and\n  realize that when a \"solution\" causes more new problems than it solves,\n  it's time to garbage collect it and look for what _solves_ the problem.\n\n  all in all, this \"what's my name\" question about functions is entirely\n  bogus, and we're just improving the way we get lost, instead of trying to\n  find our way home.  see the manual on debugging if you use Allegro CL.\n  I'm sure the other professional Common Lisps have similar debugging\n  capabilities.  (the free Lisps are lacking in this department to an\n  extent that those who reject commercial software will never understand\n  until they overcome their rejection.)\n\n  the way we deal with \"what's my name\" in recursive functions is to use\n  FLET inside the function, call it with suitable arguments, and avoid the\n  entire overhead of calling through a symbol's function slot.  this also\n  works well with anonymous functions.  however, it's a lexical name, and\n  there's no guarantee that no other function will do the same, so there's\n  no point in externalizing the name -- in fact, the opposite is the point:\n  to avoid externalizing the name.\n  \n  Allegro CL comes with sufficient documentation and source code for\n  regular licencees that you can easily figure out how to get the function\n  object of the current frame.  in most cases, you can query the function\n  object for the symbol (actually, function name) to which it was bound at\n  some time in the past.  you have no guarantee that you get back the same\n  function object if you ask for the FDEFINITION of that function name.\n\n  it seems I'm repeating myself, but you are debugging up the wrong tree.\n  learn to use the Common Lisp debugger, don't try to emulate the behavior\n  you have been forced to accept from some inferior language -- it will\n  make Common Lisp seem inferior because we don't solve problems that never\n  should have had a solution in the first place, and the cost of which\n  solution actually carries severe penalties on the language design.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "returning_the_name_of_a_function"
        },
        {
          "id": "3157207388993059@naggum.no",
          "subject": "Re: Returning the name of a function",
          "author_id": "erik_naggum",
          "date": "2000-01-18",
          "display_date": "01/18/2000",
          "content": "\nSubject: Re: Returning the name of a function\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/18\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157207388993059@naggum.no>\n\n* Sashank Varma\n| how about something like the following?\n| \n| ? (defmacro magic-defun (name lambda-list . body)\n|     `(defun ,name ,lambda-list\n|        (flet ((magic-function ()\n|                 ',name))\n|          ,@body)))\n\n  while it appears to solve a problem, it actually doesn't.  the problem is\n  to know where you are in the code you are trying to figure out why is not\n  working as it should.  the solution is a backtrace.  the solution is to\n  read the manual and understand how Common Lisp differs from C in such a\n  way that debugging code in them differs also.\n\n  what would we do without C?  we would have PASAL, BASI, OBOL, and Ommon Lisp.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "returning_the_name_of_a_function"
        }
      ],
      "post_count": 3,
      "first_post_date": "2000-01-18",
      "last_post_date": "2000-01-18"
    },
    {
      "id": "xlisp,_xlisp-plus_and_xlisp-stat",
      "title": "XLISP, XLISP-PLUS and XLISP-STAT",
      "posts": [
        {
          "id": "3157214986560286@naggum.no",
          "subject": "Re: XLISP, XLISP-PLUS and XLISP-STAT",
          "author_id": "erik_naggum",
          "date": "2000-01-18",
          "display_date": "01/18/2000",
          "content": "\nSubject: Re: XLISP, XLISP-PLUS and XLISP-STAT\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/18\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157214986560286@naggum.no>\n\n* Robert Posey <muddy@raytheon.com>\n| Since there doesn't seem to be a dominate vendor/provider of a LISP\n| system, I doubt there is a lot of support for migration like there is for\n| VC++ or Gcc.\n\n  there is.  Common Lisp vendors take very good care of their customers,\n  and if they can help you overcome your association with another vendor,\n  they are likely to take very good care of you while in transition.\n  that's why competition is so great.\n\n  however, related to the question to which you assume you have the same\n  answer you would have for VC++ and GCC: you don't _need_ much help to\n  migrate from one Common Lisp implementation to another.  that's one thing\n  that is really great about the language: it's actually complete enough to\n  do useful things in the language itself.  imagine that!\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "xlisp,_xlisp-plus_and_xlisp-stat"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-01-18",
      "last_post_date": "2000-01-18"
    },
    {
      "id": "speed,_faster..._faster..._slower?",
      "title": "Speed, Faster... Faster... Slower?",
      "posts": [
        {
          "id": "3157208830761229@naggum.no",
          "subject": "Re: Speed, Faster... Faster... Slower?",
          "author_id": "erik_naggum",
          "date": "2000-01-18",
          "display_date": "01/18/2000",
          "content": "\nSubject: Re: Speed, Faster... Faster... Slower?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/18\nNewsgroups: comp.lang.lisp\nMessage-ID: <3157208830761229@naggum.no>\n\n* Tony <TonyNOToSPAM@chice.force9.co.uk.invalid>\n| Some of the data is contained in simple-vectors, other bits\n| in arrays, within the structures, but the use of arrays is\n| wastefull in this situation as the ultimate size is unknown.\n\n  well, you _could_ use adjustable vectors with fill pointers if such is\n  your concern.  Common Lisp knows that the tradeoff that people made with\n  lists carried a performance penalty.  look at VECTOR-PUSH and VECTOR-POP\n  for ways to deal with unknown sizes and still get O(1) access times.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "speed,_faster..._faster..._slower?"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-01-18",
      "last_post_date": "2000-01-18"
    },
    {
      "id": "inspect",
      "title": "inspect",
      "posts": [
        {
          "id": "3156777199553156@naggum.no",
          "subject": "Re: inspect",
          "author_id": "erik_naggum",
          "date": "2000-01-13",
          "display_date": "01/13/2000",
          "content": "\nSubject: Re: inspect\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/13\nNewsgroups: comp.lang.lisp\nMessage-ID: <3156777199553156@naggum.no>\n\n* Frode Vatvedt Fjeld <frodef@acm.org>\n| Are there functions to access the same information that I can dig up\n| interactively with INSPECT?\n\n  usually, but not necessarily.\n\n| For example, in ACL, I can (interactively) inspect a compiled function,\n| and retrieve its machine-code (vector) object through the function's CODE\n| cell. Is there some function I can use to obtain the same information\n| programmatically, like\n| \n|   (get-cell-or-something #'myfun 'code) => #<CODE vector object>\n\n  some of these slots are so low-level that there aren't any regular\n  CL-level code to access them.  however, the code for the inspector is\n  part of the source code offering that comes with a regular license.\n\n  it seems that you're digging so deep into Allegro CL that you would\n  benefit from Franz Inc's excellent support, and I think it's fair to pay\n  for a license.  I could argue that it's not in the best interest of the\n  continued existence free versions that people reverse-engineer a free\n  product -- it may turn out to be hostile to the commercial operation\n  whose profitability spawned the ability to give something away...\n\n  however, you should check out the results of (apropos \"_CODE\").\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "inspect"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-01-13",
      "last_post_date": "2000-01-13"
    },
    {
      "id": "postings_screened?",
      "title": "postings screened?",
      "posts": [
        {
          "id": "3156682255729619@naggum.no",
          "subject": "Re: postings screened?",
          "author_id": "erik_naggum",
          "date": "2000-01-12",
          "display_date": "01/12/2000",
          "content": "\nSubject: Re: postings screened?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/12\nNewsgroups: comp.lang.lisp\nMessage-ID: <3156682255729619@naggum.no>\n\n* jajwuth@aol.com (Jajwuth)\n| i notice that there is a delay in postings to newsgroup. Are they prescreened\n| by someone. Sometimes i see replies but not my original posting.\n\n  USENET news is a fickle medium.  do not expect synchronicity or perfect\n  distribution, you will be seriouly disaapointed.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "postings_screened?"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-01-12",
      "last_post_date": "2000-01-12"
    },
    {
      "id": "quick_guide",
      "title": "quick guide",
      "posts": [
        {
          "id": "3156682579602125@naggum.no",
          "subject": "Re: quick guide",
          "author_id": "erik_naggum",
          "date": "2000-01-12",
          "display_date": "01/12/2000",
          "content": "\nSubject: Re: quick guide\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/12\nNewsgroups: comp.lang.lisp\nMessage-ID: <3156682579602125@naggum.no>\n\n* Richard Billington <billpeople@mindspring.com>\n| Also - not exactly quick, but very complete and free is the Common Lisp\n| Hyperspce available at http://www.harlequin.com/support/books/HyperSpec\n\n  spend the necessary time to transfer the whole tarball to your own\n  computer.  if it still isn't exactly quick, upgrade your computer.  :)\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "quick_guide"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-01-12",
      "last_post_date": "2000-01-12"
    },
    {
      "id": "format_directive_\"~{...~}\"",
      "title": "format directive \"~{...~}\"",
      "posts": [
        {
          "id": "3156500787965612@naggum.no",
          "subject": "Re: format directive \"~{...~}\"",
          "author_id": "erik_naggum",
          "date": "2000-01-10",
          "display_date": "01/10/2000",
          "content": "\nSubject: Re: format directive \"~{...~}\"\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/10\nNewsgroups: comp.lang.lisp\nMessage-ID: <3156500787965612@naggum.no>\n\n* \"David J. Cooper\" <dcooper8@genworks.com>\n| Now I am wondering if there is a way to use this or a similar directive\n| to put something before all but the first element in the list, as in:\n:\n| that is, I want an extra space *before* all but the *first*  element in\n| the argument list, so that the rest of the elements line up under the\n| first one which has a parenthesis to the left of it.\n\n  PPRINT-LOGICAL-BLOCK can handle this requirement easily.  its FORMAT\n  interface is documented in section 22.3.5.2 of the standard.\n\n  for a list like (one two three) to be formatted nicely, this suffices:\n\n(format nil \"~:<~@{~S~^~:@_~}~:>\" '(one two three))\n\n  untangling this example is left as an exercise for the reader...\n  \n#:Erik\n\n",
          "references": [],
          "thread_id": "format_directive_\"~{...~}\""
        },
        {
          "id": "3156569413180279@naggum.no",
          "subject": "Re: format directive \"~{...~}\"",
          "author_id": "erik_naggum",
          "date": "2000-01-11",
          "display_date": "01/11/2000",
          "content": "\nSubject: Re: format directive \"~{...~}\"\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/11\nNewsgroups: comp.lang.lisp\nMessage-ID: <3156569413180279@naggum.no>\n\n* Shin <fxn@retemail.es>\n| USER(1): (format nil \"(~{~a~^,~% ~}))\" (list 'one 'two 'three))\n| \"(ONE,\n|  TWO,\n|  THREE))\"\n\n  for this to work, you would need to do ~& first, and it will fail to\n  produce the correct output if any forms are nested.  using the\n  pretty-printer interface will work in such cases.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "format_directive_\"~{...~}\""
        }
      ],
      "post_count": 2,
      "first_post_date": "2000-01-10",
      "last_post_date": "2000-01-11"
    },
    {
      "id": "would_you_please_criticize_this_routine?",
      "title": "Would you please criticize this routine?",
      "posts": [
        {
          "id": "3156569854878998@naggum.no",
          "subject": "Re: Would you please criticize this routine?",
          "author_id": "erik_naggum",
          "date": "2000-01-11",
          "display_date": "01/11/2000",
          "content": "\nSubject: Re: Would you please criticize this routine?\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/11\nNewsgroups: comp.lang.lisp\nMessage-ID: <3156569854878998@naggum.no>\n\n* Shin <fxn@retemail.es>\n| Should read:\n| \n|     (do* ((to-filter result (rest to-filter))\n|           (p (first to-filter) (first to-filter)))\n|       ((< upper-bound p) (cons 2 result))\n|       (rplacd to-filter\n|          (delete-if (lambda (a) (zerop (mod a p))) (rest to-filter))))))\n\n  I'd highly recommend (setf (rest to-filter) ...) over RPLACD, or at least\n  using CDR instead of REST if you use RPLACD.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "would_you_please_criticize_this_routine?"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-01-11",
      "last_post_date": "2000-01-11"
    },
    {
      "id": "comparison_of_lisp_compilers_and_translators",
      "title": "Comparison of LISP Compilers and translators",
      "posts": [
        {
          "id": "3156359331778161@naggum.no",
          "subject": "Re: Comparison of LISP Compilers and translators",
          "author_id": "erik_naggum",
          "date": "2000-01-08",
          "display_date": "01/08/2000",
          "content": "\nSubject: Re: Comparison of LISP Compilers and translators\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/08\nNewsgroups: comp.lang.lisp\nMessage-ID: <3156359331778161@naggum.no>\n\n* lisp_lover@my-deja.com\n| I am interested in asking the opinion of the readership of this newsgroup\n| on the subject of this post.\n\n  this goes without saying, really.\n\n| Is a converter to C better than a compiler?\n\n  no.\n\n| I am looking for a free OR commercial product that runs on linux and has\n| source code.  It should interface with X if it is gui.\n\n  how much source code?  all of it?  if so, why?  I have all the source\n  code to the Linux kernel and almost all the Linux tools, and yet I find\n  it nearly unreadable and almost completely useless.  investing the time\n  it takes to understand a piece of source code in order to modify a tool\n  is a decision that should be made after investigating the needs and the\n  options very closely.  the probability that the effort will be worth it\n  is very slim, indeed.  having the _option_ to do so in a particular case,\n  is, however, priceless.  this means you would want the source to specific\n  fragments of the entire system as you encounter specific problems.  this\n  will be easy to come by if you're a paying customer.\n\n| AT EVERY STAGE, IF THE PREPARATION IS CORRECT, ONE CAN READILY PERCEIVE\n| THE NEXT STAGE OF KNOWLEDGE.  THIS IS MY EXPERIENCE WITH LEARNING\n| RELATIVITY, AND QUANTUM MECHANICS.  I SAW INTELLECTUALLY PERVERTED,\n| MASOCHISTIC, TRECHEROUS AND HIGHLY COMPETETIVE PROFS AT MIT AND CALTECH\n| WHO WOULD WRITE BOOKS FOR _IMPRESSING THEIR COLLEGUES_ AND AT THE SAME\n| TIME MAKING MONEY.  READING THE REVIEWS ON STRUCTURE AND INTERPRETATION\n| OF COMPUTER PROGRAMS AT AMAZON, IT SEEMS THAT THE BOOK WAS WRITTEN BY\n| THESE POMPOUS PEOPLE FROM SNOBISH MIT TO IMPRESS THEIR COLLEAGUES.  THUS\n| I WANT PEOPLE NOT TO MISGUIDE ME TOWARDS SUCH BOOKS AND PAPERS. ANYWAY\n| COMING BACK TO THE SUBJECT, A FEW QUESTIONS.\n\n1 writing in capital letters is reserved for lawyers and retards.\n\n2 judgmental attitudes are severely incompatible with learning.\n\n3 SICP is intended to teach _programming_ to fairly intelligent people.  it\n  is very good at that.  less intelligent people struggle, but love it if\n  they have indeed struggled.  most people who want to learn \"programming\"\n  these days are fairly stupid and are mainly interested in making quick\n  bucks through an activity whose similarity to programming is restricted\n  to looking at a computer monitor.\n\n4 you're the only person so far who comes across as pompous.\n\n| Where can we get this and other MIT memo's for free?  I have enough money\n| for compiler but these publicly funded reports should be available free.\n\n  MIT was a private institution last time I checked.  has that changed?\n\n| I wish I could remember the honeywell reference, but I will inform the\n| readership of cll as soon as I find it.\n\n  most people here know about this reference, already.  just like Alexander\n  Graham Bell didn't invent the telephone and Thomas Alva Edison didn't\n  invent the light bulb, Richard Stallman didn't first use Lisp in Emacs.\n  he did, however, invent Emacs (based on TECO), and took great advantage\n  of the few first steps towards a Lisp-based Emacs made elsewhere and made\n  it what it is today.\n\n  it's actually quite arrogant of you to believe that you are the first\n  person to have come across a report that you think is \"damaging\" to Lisp\n  because you know so little.\n\n  I suggest the following:\n\n1 tune down the attitude to approximately zero\n\n2 read SICP for yourself -- it's a widely acclaimed book\n\n3 hold the judgment until you know of what you speak\n\n4 check your facts and references before you post them\n\n5 re-examine your needs -- and make them practical if they are political\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "comparison_of_lisp_compilers_and_translators"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-01-08",
      "last_post_date": "2000-01-08"
    },
    {
      "id": "lisp_compiler",
      "title": "lisp compiler",
      "posts": [
        {
          "id": "3155808540636802@naggum.no",
          "subject": "Re: lisp compiler",
          "author_id": "erik_naggum",
          "date": "2000-01-02",
          "display_date": "01/02/2000",
          "content": "\nSubject: Re: lisp compiler\nFrom: Erik Naggum <erik@naggum.no>\nDate: 2000/01/02\nNewsgroups: comp.lang.lisp\nMessage-ID: <3155808540636802@naggum.no>\n\n* \"Janos Blazi\" <jblazi@netsurf.de>\n| But don't they say it becomes invalid after a month?\n\n  didn't your parents feed you enough for your brain to develop?\n\n  in case you don't like the question, consider what it communicates about\n  you.  then consider what your question communicates about Franz Inc and\n  their free (gratis) versions of Allegro CL.  if you see a reason for you\n  to be annoyed by my question, but not any reason for anybody to be\n  annoyed by your question, consider suing your parents for malnutrition.\n  \n  nothing \"becomes invalid\" (even allowing for extremely poor grasp of\n  English).  the licence is clear: Allegro CL Trial Edition for Linux and\n  Lite Edition for Windows is licensed for use by anyone who gets a copy of\n  it up until 2000-11-01.  it's like the Y2K \"problem\": nothing happens.\n  if you think this means you may continue to use it, the answer is the\n  same as to whether committing crimes in ways that makes you believe you\n  won't get caught is legal.  (in case that's too difficult for you: no,\n  you may not use it after 2000-11-01, but the software itself won't\n  enforce the license agreement.)  like all honor-based systems, they may\n  have to change if a sufficient number of morons violate it, and that is\n  why the memory limitations were changed between 5.0 and 5.0.1: too many\n  idiots tried to use the free version in production systems without paying\n  for a license, so those who would like to play with a free version and\n  complex applications got a problem.  it's always like this: idiots make\n  intelligent people lose freedom, time or money.  this is of course\n  acceptable to the idiots.  this is also why most postings by Janos Blazi\n  are NOT acceptable.\n\n#:Erik\n\n",
          "references": [],
          "thread_id": "lisp_compiler"
        }
      ],
      "post_count": 1,
      "first_post_date": "2000-01-02",
      "last_post_date": "2000-01-02"
    }
  ],
  "authors": [
    {
      "id": "erik_naggum",
      "name": "Erik Naggum",
      "email": "",
      "post_count": 300
    }
  ],
  "stats": {
    "total_threads": 105,
    "total_posts": 300,
    "total_authors": 1
  }
}